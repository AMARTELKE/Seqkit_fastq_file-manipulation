{
    "docs": [
        {
            "location": "/", 
            "text": "SeqKit - a cross-platform and ultrafast toolkit for FASTA/Q file manipulation\n\n\n\n\nDocuments:\n \nhttp://bioinf.shenwei.me/seqkit\n\n(\nUsage\n,\n\nFAQ\n,\n\nTutorial\n,\n\nBenchmark\n\nand \nDevelopment Notes\n)\n\n\nSource code:\n \nhttps://github.com/shenwei356/seqkit\n\n\n\n\n\n\n\n\n\n\nLatest version:\n \n\n\n\n\n\n\n\n\n\n\nCitation\n:\n \n\n\n\n\nIntroduction\n\n\nFASTA and FASTQ are basic and ubiquitous formats for storing nucleotide and\nprotein sequences. Common manipulations of FASTA/Q file include converting,\nsearching, filtering, deduplication, splitting, shuffling, and sampling.\nExisting tools only implement some of these manipulations,\nand not particularly efficiently, and some are only available for certain\noperating systems. Furthermore, the complicated installation process of\nrequired packages and running environments can render these programs less\nuser friendly.\n\n\nThis project describes a cross-platform ultrafast comprehensive\ntoolkit for FASTA/Q processing. SeqKit provides executable binary files for\nall major operating systems, including Windows, Linux, and Mac OS X, and can\nbe directly used without any dependencies or pre-configurations.\nSeqKit demonstrates competitive performance in execution time and memory\nusage compared to similar tools. The efficiency and usability of SeqKit\nenable researchers to rapidly accomplish common FASTA/Q file manipulations.\n\n\nTable of Contents\n\n\n\n\n\n\n\n\n\n\nFeatures\n\n\nSubcommands\n\n\nInstallation\n\n\nTechnical details and guides for use\n\n\nUsage \n Examples\n\n\nBenchmark\n\n\nCitation\n\n\nAcknowledgements\n\n\nContact\n\n\nLicense\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nCross-platform\n (Linux/Windows/Mac OS X/OpenBSD/FreeBSD,\n  see \ndownload\n)\n\n\nLight weight and out-of-the-box, no dependencies, no compilation, no configuration\n\n  (see \ndownload\n)\n\n\nUltraFast\n (see \nbenchmark\n),\n  \nmultiple-CPUs supported\n.\n\n\nPractical functions supported by 20 subcommands\n (see subcommands and\n  \nusage\n )\n\n\nWell documented\n (detailed \nusage\n\n  and \nbenchmark\n )\n\n\nSeamlessly parses both FASTA and FASTQ formats\n\n\nSupport STDIN and gziped input/output file, easy being used in pipe\n\n\nSupport custom sequence ID regular expression\n (especially useful for searching with ID list)\n\n\nReproducible results (configurable rand seed in \nsample\n and \nshuffle\n)\n\n\nWell organized source code, friendly to use and easy to extend.\n\n\n\n\nFeatures comparison\n\n\n\n\n\n\n\n\nCategories\n\n\nFeatures\n\n\nseqkit\n\n\nfasta_utilities\n\n\nfastx_toolkit\n\n\npyfaidx\n\n\nseqmagick\n\n\nseqtk\n\n\n\n\n\n\n\n\n\n\nFormats support\n\n\nMulti-line FASTA\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nFASTQ\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nMulti-line  FASTQ\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nValidating sequences\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nSupporting RNA\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFunctions\n\n\nSearching by motifs\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nSampling\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nExtracting sub-sequence\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nRemoving duplicates\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nPartly\n\n\n--\n\n\n\n\n\n\n\n\nSplitting\n\n\nYes\n\n\nYes\n\n\n--\n\n\nPartly\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nSplitting by seq\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nShuffling\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nSorting\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nLocating motifs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nCommon sequences\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nCleaning bases\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nTranscription\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nTranslation\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nFiltering by size\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nRenaming header\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nOther features\n\n\nCross-platform\n\n\nYes\n\n\nPartly\n\n\nPartly\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nReading STDIN\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nReading gzipped file\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nWriting gzip file\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nNote 1\n: See \nversion information\n of the softwares.\n\n\nNote 2\n: See \nusage\n for detailed options of seqkit.\n\n\nSubcommands\n\n\n20 subcommands in total.\n\n\nSequence and subsequence\n\n\n\n\nseq\n        transform sequences (revserse, complement, extract ID...)\n\n\nsubseq\n     get subsequences by region/gtf/bed, including flanking sequences\n\n\nsliding\n    sliding sequences, circular genome supported\n\n\nstats\n       simple statistics of FASTA files\n\n\nfaidx\n      create FASTA index file\n\n\n\n\nFormat conversion\n\n\n\n\nfx2tab\n     covert FASTA/Q to tabular format (and length/GC content/GC skew)\n\n\ntab2fx\n     covert tabular format to FASTA/Q format\n\n\nfq2fa\n      covert FASTQ to FASTA\n\n\n\n\nSearching\n\n\n\n\ngrep\n       search sequences by pattern(s) of name or sequence motifs\n\n\nlocate\n     locate subsequences/motifs\n\n\n\n\nSet operations\n\n\n\n\nrmdup\n      remove duplicated sequences by id/name/sequence\n\n\ncommon\n     find common sequences of multiple files by id/name/sequence\n\n\nsplit\n      split sequences into files by id/seq region/size/parts\n\n\nsample\n     sample sequences by number or proportion\n\n\nhead\n       print first N FASTA/Q records\n\n\n\n\nEdit\n\n\n\n\nreplace\n    replace name/sequence by regular expression\n\n\nrename\n     rename duplicated IDs\n\n\nrestart\n    reset start position for circular genome\n\n\n\n\nOrdering\n\n\n\n\nshuffle\n    shuffle sequences\n\n\nsort\n       sort sequences by id/name/sequence\n\n\n\n\nMisc\n\n\n\n\nversion\n   print version information and check for update\n\n\n\n\nInstallation\n\n\nGo to \nDownload Page\n for more download options and changelogs.\n\n\nSeqKit\n is implemented in \nGo\n programming language,\n executable binary files \nfor most popular operating systems\n are freely available\n  in \nrelease\n page.\n\n\nMethod 1: Download binaries\n\n\nJust \ndownload\n compressed\nexecutable file of your operating system,\nand decompress it with \ntar -zxvf *.tar.gz\n command or other tools.\nAnd then:\n\n\n\n\n\n\nFor Linux-like systems\n\n\n\n\n\n\nIf you have root privilege simply copy it to \n/usr/local/bin\n:\n\n\nsudo cp seqkit /usr/local/bin/\n\n\n\n\n\n\n\nOr add the current directory of the executable file to environment variable\n\nPATH\n:\n\n\necho export PATH=\\$PATH:\\\"$(pwd)\\\" \n ~/.bashrc\nsource ~/.bashrc\n\n\n\n\n\n\n\n\n\n\n\nFor windows\n, just copy \nseqkit.exe\n to \nC:\\WINDOWS\\system32\n.\n\n\n\n\n\n\nMethod 2: Install via conda \n \n \n\n\nconda install -c bioconda seqkit\n\n\n\nMethod 3: For Go developer\n\n\ngo get -u github.com/shenwei356/seqkit/seqkit\n\n\n\nTechnical details and guides for use\n\n\nFASTA/Q format parsing\n\n\nSeqKit uses author's lightweight and high-performance bioinformatics packages\n\nbio\n for FASTA/Q parsing,\nwhich has \nhigh performance\n\nclose to the\nfamous C lib \nklib\n (\nkseq.h\n).\n\n\n\n\nSequence formats and types\n\n\nSeqKit seamlessly support FASTA and FASTQ format.\nSequence format is automatically detected.\nAll subcommands except for \nfaidx\n can handle both formats.\nAnd only when some commands (\nsubseq\n, \nsplit\n, \nsort\n and \nshuffle\n)\nwhich utilise FASTA index to improve perfrmance for large files in two pass mode\n(by flag \n--two-pass\n), only FASTA format is supported.\n\n\nSequence type (DNA/RNA/Protein) is automatically detected by leading subsequences\nof the first sequences in file or STDIN. The length of the leading subsequences\nis configurable by global flag \n--alphabet-guess-seq-length\n with default value\nof 10000. If length of the sequences is less than that, whole sequences will\nbe checked.\n\n\nSequence ID\n\n\nBy default, most softwares, including \nseqkit\n, take the leading non-space\nletters as sequence identifier (ID). For example,\n\n\n\n\n\n\n\n\nFASTA header\n\n\nID\n\n\n\n\n\n\n\n\n\n\n123456 gene name\n\n\n123456\n\n\n\n\n\n\nlongname\n\n\nlongname\n\n\n\n\n\n\ngi\n110645304\nref\nNC_002516.2\n Pseudomona\n\n\ngi\n110645304\nref\nNC_002516.2\n\n\n\n\n\n\n\n\nBut for some sequences from NCBI,\ne.g. \ngi|110645304|ref|NC_002516.2| Pseudomona\n, the ID is \nNC_002516.2\n.\nIn this case, we could set sequence ID parsing regular expression by global flag\n\n--id-regexp \"\\|([^\\|]+)\\| \"\n or just use flag \n--id-ncbi\n. If you want\nthe \ngi\n number, then use \n--id-regexp \"^gi\\|([^\\|]+)\\|\"\n.\n\n\nFASTA index\n\n\nFor some commands, including \nsubseq\n, \nsplit\n, \nsort\n and \nshuffle\n,\nwhen input files are (plain or gzipped) FASTA files,\nFASTA index would be optional used for\nrapid access of sequences and reducing memory occupation.\n\n\nATTENTION: the \n.seqkit.fai\n file created by SeqKit is slightly different from \n.fai\n file\ncreated by \nsamtools\n. SeqKit uses full sequence head instead of just ID as key.\n\n\nParallelization of CPU intensive jobs\n\n\nThe validation of sequences bases and complement process of sequences\nare parallelized for large sequences.\n\n\nParsing of line-based files, including BED/GFF file and ID list file are also parallelized.\n\n\nThe Parallelization is implemented by multiple goroutines in golang\n which are similar to but much\nlighter weight than threads. The concurrency number is configurable with global\nflag \n-j\n or \n--threads\n (default value: 1 for single-CPU PC, 2 for others).\n\n\nMemory occupation\n\n\nMost of the subcommands do not read whole FASTA/Q records in to memory,\nincluding \nstat\n, \nfq2fa\n, \nfx2tab\n, \ntab2fx\n, \ngrep\n, \nlocate\n, \nreplace\n,\n \nseq\n, \nsliding\n, \nsubseq\n.\n\n\nNote that when using \nsubseq --gtf | --bed\n, if the GTF/BED files are too\nbig, the memory usage will increase.\nYou could use \n--chr\n to specify chromesomes and \n--feature\n to limit features.\n\n\nSome subcommands need to store sequences or heads in memory, but there are\nstrategy to reduce memory occupation, including \nrmdup\n and \ncommon\n.\nWhen comparing with sequences, MD5 digest could be used to replace sequence by\nflag \n-m\n (\n--md5\n).\n\n\nSome subcommands could either read all records or read the files twice by flag\n\n-2\n (\n--two-pass\n), including \nsample\n, \nsplit\n, \nshuffle\n and \nsort\n.\nThey use FASTA index for rapid acccess of sequences and reducing memory occupation.\n\n\nReproducibility\n\n\nSubcommands \nsample\n and \nshuffle\n use random function, random seed could be\ngiven by flag \n-s\n (\n--rand-seed\n). This makes sure that sampling result could be\nreproduced in different environments with same random seed.\n\n\nUsage \n Examples\n\n\nUsage and examples\n\n\nTutorial\n\n\nBenchmark\n\n\nMore details: \nhttp://bioinf.shenwei.me/seqkit/benchmark/\n\n\nDatasets:\n\n\n$ seqkit stat *.fa\nfile          format  type   num_seqs        sum_len  min_len       avg_len      max_len\ndataset_A.fa  FASTA   DNA      67,748  2,807,643,808       56      41,442.5    5,976,145\ndataset_B.fa  FASTA   DNA         194  3,099,750,718      970  15,978,096.5  248,956,422\ndataset_C.fq  FASTQ   DNA   9,186,045    918,604,500      100           100          100\n\n\n\nSeqKit version: v0.3.1.1\n\n\nFASTA:\n\n\n\n\nFASTQ:\n\n\n\n\nCitation\n\n\nW Shen\n, S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation.\n\nPLOS ONE\n. \ndoi:10.1371/journal.pone.0163962\n.\n\n\nAcknowledgements\n\n\nWe thank \nLei Zhang\n for testing of SeqKit,\nand also thank \nJim Hester\n,\nauthor of \nfasta_utilities\n,\nfor advice on early performance improvements of for FASTA parsing\nand \nBrian Bushnell\n,\nauthor of \nBBMaps\n,\nfor advice on naming SeqKit and adding accuracy evaluation in benchmarks.\nWe also thank Nicholas C. Wu from the Scripps Research Institute,\nUSA for commenting on the manuscript\nand \nGuangchuang Yu\n\nfrom State Key Laboratory of Emerging Infectious Diseases,\nThe University of Hong Kong, HK for advice on the manuscript.\n\n\nWe thank \nLi Peng\n for reporting many bugs.\n\n\nContact\n\n\nEmail me for any problem when using seqkit. shenwei356(at)gmail.com\n\n\nCreate an issue\n to report bugs,\npropose new functions or ask for help.\n\n\nLicense\n\n\nMIT License", 
            "title": "Home"
        }, 
        {
            "location": "/#seqkit-a-cross-platform-and-ultrafast-toolkit-for-fastaq-file-manipulation", 
            "text": "Documents:   http://bioinf.shenwei.me/seqkit \n( Usage , FAQ , Tutorial , Benchmark \nand  Development Notes )  Source code:   https://github.com/shenwei356/seqkit      Latest version:        Citation :", 
            "title": "SeqKit - a cross-platform and ultrafast toolkit for FASTA/Q file manipulation"
        }, 
        {
            "location": "/#introduction", 
            "text": "FASTA and FASTQ are basic and ubiquitous formats for storing nucleotide and\nprotein sequences. Common manipulations of FASTA/Q file include converting,\nsearching, filtering, deduplication, splitting, shuffling, and sampling.\nExisting tools only implement some of these manipulations,\nand not particularly efficiently, and some are only available for certain\noperating systems. Furthermore, the complicated installation process of\nrequired packages and running environments can render these programs less\nuser friendly.  This project describes a cross-platform ultrafast comprehensive\ntoolkit for FASTA/Q processing. SeqKit provides executable binary files for\nall major operating systems, including Windows, Linux, and Mac OS X, and can\nbe directly used without any dependencies or pre-configurations.\nSeqKit demonstrates competitive performance in execution time and memory\nusage compared to similar tools. The efficiency and usability of SeqKit\nenable researchers to rapidly accomplish common FASTA/Q file manipulations.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#table-of-contents", 
            "text": "Features  Subcommands  Installation  Technical details and guides for use  Usage   Examples  Benchmark  Citation  Acknowledgements  Contact  License", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/#features", 
            "text": "Cross-platform  (Linux/Windows/Mac OS X/OpenBSD/FreeBSD,\n  see  download )  Light weight and out-of-the-box, no dependencies, no compilation, no configuration \n  (see  download )  UltraFast  (see  benchmark ),\n   multiple-CPUs supported .  Practical functions supported by 20 subcommands  (see subcommands and\n   usage  )  Well documented  (detailed  usage \n  and  benchmark  )  Seamlessly parses both FASTA and FASTQ formats  Support STDIN and gziped input/output file, easy being used in pipe  Support custom sequence ID regular expression  (especially useful for searching with ID list)  Reproducible results (configurable rand seed in  sample  and  shuffle )  Well organized source code, friendly to use and easy to extend.", 
            "title": "Features"
        }, 
        {
            "location": "/#features-comparison", 
            "text": "Categories  Features  seqkit  fasta_utilities  fastx_toolkit  pyfaidx  seqmagick  seqtk      Formats support  Multi-line FASTA  Yes  Yes  --  Yes  Yes  Yes     FASTQ  Yes  Yes  Yes  --  Yes  Yes     Multi-line  FASTQ  Yes  Yes  --  --  Yes  Yes     Validating sequences  Yes  --  Yes  Yes  --  --     Supporting RNA  Yes  Yes  --  --  Yes  Yes    Functions  Searching by motifs  Yes  Yes  --  --  Yes  --     Sampling  Yes  --  --  --  Yes  Yes     Extracting sub-sequence  Yes  Yes  --  Yes  Yes  Yes     Removing duplicates  Yes  --  --  --  Partly  --     Splitting  Yes  Yes  --  Partly  --  --     Splitting by seq  Yes  --  Yes  Yes  --  --     Shuffling  Yes  --  --  --  --  --     Sorting  Yes  Yes  --  --  Yes  --     Locating motifs  Yes  --  --  --  --  --     Common sequences  Yes  --  --  --  --  --     Cleaning bases  Yes  Yes  Yes  Yes  --  --     Transcription  Yes  Yes  Yes  Yes  Yes  Yes     Translation  --  Yes  Yes  Yes  Yes  --     Filtering by size  Yes  Yes  --  Yes  Yes  --     Renaming header  Yes  Yes  --  --  Yes  Yes    Other features  Cross-platform  Yes  Partly  Partly  Yes  Yes  Yes     Reading STDIN  Yes  Yes  Yes  --  Yes  Yes     Reading gzipped file  Yes  Yes  --  --  Yes  Yes     Writing gzip file  Yes  --  --  --  Yes  --     Note 1 : See  version information  of the softwares.  Note 2 : See  usage  for detailed options of seqkit.", 
            "title": "Features comparison"
        }, 
        {
            "location": "/#subcommands", 
            "text": "20 subcommands in total.  Sequence and subsequence   seq         transform sequences (revserse, complement, extract ID...)  subseq      get subsequences by region/gtf/bed, including flanking sequences  sliding     sliding sequences, circular genome supported  stats        simple statistics of FASTA files  faidx       create FASTA index file   Format conversion   fx2tab      covert FASTA/Q to tabular format (and length/GC content/GC skew)  tab2fx      covert tabular format to FASTA/Q format  fq2fa       covert FASTQ to FASTA   Searching   grep        search sequences by pattern(s) of name or sequence motifs  locate      locate subsequences/motifs   Set operations   rmdup       remove duplicated sequences by id/name/sequence  common      find common sequences of multiple files by id/name/sequence  split       split sequences into files by id/seq region/size/parts  sample      sample sequences by number or proportion  head        print first N FASTA/Q records   Edit   replace     replace name/sequence by regular expression  rename      rename duplicated IDs  restart     reset start position for circular genome   Ordering   shuffle     shuffle sequences  sort        sort sequences by id/name/sequence   Misc   version    print version information and check for update", 
            "title": "Subcommands"
        }, 
        {
            "location": "/#installation", 
            "text": "Go to  Download Page  for more download options and changelogs.  SeqKit  is implemented in  Go  programming language,\n executable binary files  for most popular operating systems  are freely available\n  in  release  page.", 
            "title": "Installation"
        }, 
        {
            "location": "/#method-1-download-binaries", 
            "text": "Just  download  compressed\nexecutable file of your operating system,\nand decompress it with  tar -zxvf *.tar.gz  command or other tools.\nAnd then:    For Linux-like systems    If you have root privilege simply copy it to  /usr/local/bin :  sudo cp seqkit /usr/local/bin/    Or add the current directory of the executable file to environment variable PATH :  echo export PATH=\\$PATH:\\\"$(pwd)\\\"   ~/.bashrc\nsource ~/.bashrc      For windows , just copy  seqkit.exe  to  C:\\WINDOWS\\system32 .", 
            "title": "Method 1: Download binaries"
        }, 
        {
            "location": "/#method-2-install-via-conda", 
            "text": "conda install -c bioconda seqkit", 
            "title": "Method 2: Install via conda"
        }, 
        {
            "location": "/#method-3-for-go-developer", 
            "text": "go get -u github.com/shenwei356/seqkit/seqkit", 
            "title": "Method 3: For Go developer"
        }, 
        {
            "location": "/#technical-details-and-guides-for-use", 
            "text": "", 
            "title": "Technical details and guides for use"
        }, 
        {
            "location": "/#fastaq-format-parsing", 
            "text": "SeqKit uses author's lightweight and high-performance bioinformatics packages bio  for FASTA/Q parsing,\nwhich has  high performance \nclose to the\nfamous C lib  klib  ( kseq.h ).", 
            "title": "FASTA/Q format parsing"
        }, 
        {
            "location": "/#sequence-formats-and-types", 
            "text": "SeqKit seamlessly support FASTA and FASTQ format.\nSequence format is automatically detected.\nAll subcommands except for  faidx  can handle both formats.\nAnd only when some commands ( subseq ,  split ,  sort  and  shuffle )\nwhich utilise FASTA index to improve perfrmance for large files in two pass mode\n(by flag  --two-pass ), only FASTA format is supported.  Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences\nof the first sequences in file or STDIN. The length of the leading subsequences\nis configurable by global flag  --alphabet-guess-seq-length  with default value\nof 10000. If length of the sequences is less than that, whole sequences will\nbe checked.", 
            "title": "Sequence formats and types"
        }, 
        {
            "location": "/#sequence-id", 
            "text": "By default, most softwares, including  seqkit , take the leading non-space\nletters as sequence identifier (ID). For example,     FASTA header  ID      123456 gene name  123456    longname  longname    gi 110645304 ref NC_002516.2  Pseudomona  gi 110645304 ref NC_002516.2     But for some sequences from NCBI,\ne.g.  gi|110645304|ref|NC_002516.2| Pseudomona , the ID is  NC_002516.2 .\nIn this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \"  or just use flag  --id-ncbi . If you want\nthe  gi  number, then use  --id-regexp \"^gi\\|([^\\|]+)\\|\" .", 
            "title": "Sequence ID"
        }, 
        {
            "location": "/#fasta-index", 
            "text": "For some commands, including  subseq ,  split ,  sort  and  shuffle ,\nwhen input files are (plain or gzipped) FASTA files,\nFASTA index would be optional used for\nrapid access of sequences and reducing memory occupation.  ATTENTION: the  .seqkit.fai  file created by SeqKit is slightly different from  .fai  file\ncreated by  samtools . SeqKit uses full sequence head instead of just ID as key.", 
            "title": "FASTA index"
        }, 
        {
            "location": "/#parallelization-of-cpu-intensive-jobs", 
            "text": "The validation of sequences bases and complement process of sequences\nare parallelized for large sequences.  Parsing of line-based files, including BED/GFF file and ID list file are also parallelized.  The Parallelization is implemented by multiple goroutines in golang\n which are similar to but much\nlighter weight than threads. The concurrency number is configurable with global\nflag  -j  or  --threads  (default value: 1 for single-CPU PC, 2 for others).", 
            "title": "Parallelization of CPU intensive jobs"
        }, 
        {
            "location": "/#memory-occupation", 
            "text": "Most of the subcommands do not read whole FASTA/Q records in to memory,\nincluding  stat ,  fq2fa ,  fx2tab ,  tab2fx ,  grep ,  locate ,  replace ,\n  seq ,  sliding ,  subseq .  Note that when using  subseq --gtf | --bed , if the GTF/BED files are too\nbig, the memory usage will increase.\nYou could use  --chr  to specify chromesomes and  --feature  to limit features.  Some subcommands need to store sequences or heads in memory, but there are\nstrategy to reduce memory occupation, including  rmdup  and  common .\nWhen comparing with sequences, MD5 digest could be used to replace sequence by\nflag  -m  ( --md5 ).  Some subcommands could either read all records or read the files twice by flag -2  ( --two-pass ), including  sample ,  split ,  shuffle  and  sort .\nThey use FASTA index for rapid acccess of sequences and reducing memory occupation.", 
            "title": "Memory occupation"
        }, 
        {
            "location": "/#reproducibility", 
            "text": "Subcommands  sample  and  shuffle  use random function, random seed could be\ngiven by flag  -s  ( --rand-seed ). This makes sure that sampling result could be\nreproduced in different environments with same random seed.", 
            "title": "Reproducibility"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "Usage and examples  Tutorial", 
            "title": "Usage &amp;&amp; Examples"
        }, 
        {
            "location": "/#benchmark", 
            "text": "More details:  http://bioinf.shenwei.me/seqkit/benchmark/  Datasets:  $ seqkit stat *.fa\nfile          format  type   num_seqs        sum_len  min_len       avg_len      max_len\ndataset_A.fa  FASTA   DNA      67,748  2,807,643,808       56      41,442.5    5,976,145\ndataset_B.fa  FASTA   DNA         194  3,099,750,718      970  15,978,096.5  248,956,422\ndataset_C.fq  FASTQ   DNA   9,186,045    918,604,500      100           100          100  SeqKit version: v0.3.1.1  FASTA:   FASTQ:", 
            "title": "Benchmark"
        }, 
        {
            "location": "/#citation", 
            "text": "W Shen , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE .  doi:10.1371/journal.pone.0163962 .", 
            "title": "Citation"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "We thank  Lei Zhang  for testing of SeqKit,\nand also thank  Jim Hester ,\nauthor of  fasta_utilities ,\nfor advice on early performance improvements of for FASTA parsing\nand  Brian Bushnell ,\nauthor of  BBMaps ,\nfor advice on naming SeqKit and adding accuracy evaluation in benchmarks.\nWe also thank Nicholas C. Wu from the Scripps Research Institute,\nUSA for commenting on the manuscript\nand  Guangchuang Yu \nfrom State Key Laboratory of Emerging Infectious Diseases,\nThe University of Hong Kong, HK for advice on the manuscript.  We thank  Li Peng  for reporting many bugs.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/#contact", 
            "text": "Email me for any problem when using seqkit. shenwei356(at)gmail.com  Create an issue  to report bugs,\npropose new functions or ask for help.", 
            "title": "Contact"
        }, 
        {
            "location": "/#license", 
            "text": "MIT License", 
            "title": "License"
        }, 
        {
            "location": "/download/", 
            "text": "Download\n\n\nSeqKit is implemented in \nGo\n programming language,\n executable binary files \nfor most popular operating systems\n are freely available\n  in \nrelease\n page.\n\n\nLatest Version\n\n\nSeqKit v0.5.2\n\n\n\n\n\n\nseqkit seq\n and \nseqkit stat\n: change default gap letters from \n-\n to \n- .\n.\n\n\n\n\nLinks\n\n\n\n\n\n\n\n\nOS\n\n\nArch\n\n\nFile, (Mirror for Chinese Users)\n\n\nDownload Count\n\n\n\n\n\n\n\n\n\n\nLinux\n\n\n32-bit\n\n\nseqkit_linux_386.tar.gz\n, (\nmirror\n)\n\n\n\n\n\n\n\n\nLinux\n\n\n64-bit\n\n\nseqkit_linux_amd64.tar.gz\n, (\nmirror\n)\n\n\n\n\n\n\n\n\nOS X\n\n\n32-bit\n\n\nseqkit_darwin_386.tar.gz\n, (\nmirror\n)\n\n\n\n\n\n\n\n\nOS X\n\n\n64-bit\n\n\nseqkit_darwin_amd64.tar.gz\n, (\nmirror\n)\n\n\n\n\n\n\n\n\nWindows\n\n\n32-bit\n\n\nseqkit_windows_386.exe.tar.gz\n, (\nmirror\n)\n\n\n\n\n\n\n\n\nWindows\n\n\n64-bit\n\n\nseqkit_windows_amd64.exe.tar.gz\n, (\nmirror\n)\n\n\n\n\n\n\n\n\n\n\nInstallation\n\n\nMethod 1: Download binaries\n\n\nJust \ndownload\n compressed\nexecutable file of your operating system,\nand decompress it with \ntar -zxvf *.tar.gz\n command or other tools.\nAnd then:\n\n\n\n\n\n\nFor Linux-like systems\n\n\n\n\n\n\nIf you have root privilege simply copy it to \n/usr/local/bin\n:\n\n\nsudo cp seqkit /usr/local/bin/\n\n\n\n\n\n\n\nOr add the current directory of the executable file to environment variable\n\nPATH\n:\n\n\necho export PATH=\\$PATH:\\\"$(pwd)\\\" \n ~/.bashrc\nsource ~/.bashrc\n\n\n\n\n\n\n\n\n\n\n\nFor windows\n, just copy \nseqkit.exe\n to \nC:\\WINDOWS\\system32\n.\n\n\n\n\n\n\nMethod 2: Install via conda \n \n \n\n\nconda install -c bioconda seqkit\n\n\n\nMethod 3: For Go developer\n\n\ngo get -u github.com/shenwei356/seqkit/seqkit\n\n\n\nRelease History\n\n\n\n\nSeqKit v0.5.1\n\n\n\n\nseqkit restart\n: fix bug of flag parsing\n\n\n\n\n\n\nSeqKit v0.5.0\n\n\n\n\nnew command \nseqkit restart\n, for resetting start position for circular genome\n.\n\n\nseqkit sliding\n: add flag \n-g/--greedy\n, exporting last subsequences even shorter than windows size.\n\n\nseqkit seq\n:\n\n\nadd flag \n-m/--min-len\n and \n-M/--max-len\n to filter sequences by length\n.\n\n\nrename flag \n-G/--gap-letter\n to \n-G/--gap-letters\n.\n\n\n\n\n\n\nseqkit stat\n:\n\n\nrenamed to \nseqkit stats\n, don't worry, old name is still available as an alias.\n\n\nadd new flag \n-a/all\n, for all statistics, including \nsum_gap\n, \nN50\n, and \nL50\n.\n\n\n\n\n\n\n\n\n\n\nSeqKit v0.4.5\n\n\n\n\nseqkit seq\n: fix bug of failing to reverse quality of FASTQ sequence\n\n\n\n\n\n\nSeqKit v0.4.4\n\n\n\n\nseqkit locate\n: fix bug of missing regular-expression motifs containing\n non-DNA characters (e.g., \nACT.{6,7}CGG\n) from motif file (\n-f\n).\n\n\ncompiled with go v1.8.\n\n\n\n\n\n\nSeqKit v0.4.3\n\n\n\n\nfix bug of \nseqkit stat\n: \nmin_len\n always be \n0\n in versions: v0.4.0, v0.4.1, v0.4.2\n\n\n\n\n\n\nSeqKit v0.4.2\n\n\n\n\nfix header information of \nseqkit subseq\n when restriving up- and down-steam\nsequences using GTF/BED file.\n\n\n\n\n\n\nSeqKit v0.4.1\n\n\n\n\nenchancement: remove redudant regions for \nseqkit locate\n.\n\n\n\n\n\n\nSeqKit v0.4.0\n\n\n\n\nfix bug of \nseqkit locate\n, e.g, only find two locations\n(\n1-4\n, \n7-10\n, missing \n4-7\n) of \nACGA\n in \nACGACGACGA\n.\n\n\nbetter output of \nseqkit stat\n for empty file.\n\n\n\n\n\n\nSeqKit v0.3.9\n\n\n\n\nfix bug of region selection for blank sequences. affected commands include\n\nseqkit subseq --region\n, \nseqkit grep --region\n, \nseqkit split --by-region\n.\n\n\ncompile with go1.8beta1.\n\n\n\n\n\n\nSeqKit v0.3.8.1\n\n\n\n\nenhancement and bugfix of \nseqkit common\n: two or more same files allowed,\nfix log information of number of extracted sequences in the first file.\n\n\n\n\n\n\nSeqKit v0.3.8\n\n\n\n\nenhancement of \nseqkit common\n: better handling of files containing replicated sequences\n\n\n\n\n\n\nSeqKit v0.3.7\n\n\n\n\nfix bug in \nseqkit split --by-id\n when sequence ID contains invalid characters for system path.\n\n\nadd more flags validation for \nseqkit replace\n.\n\n\nenhancement: raise error when key pattern matches multiple targes in cases of replacing with key-value files and more controls are added.\n\n\nchanges: do not wrap sequence and quality in output for FASTQ  format.\n\n\n\n\n\n\nSeqKit v0.3.6\n\n\n\n\nadd new feature for \nseqkit grep\n: new flag \n-R\n (\n--region\n) for specifying sequence region for searching.\n\n\n\n\n\n\nSeqKit v0.3.5\n\n\n\n\nfig bug of \nseqkit grep\n: flag \n-i\n (\n--ignore-case\n) did not work when not using regular expression\n\n\n\n\n\n\nSeqKit v0.3.4.1\n\n\n\n\nimprove performance of reading (~10%) and writing (100%) gzip-compressed file\nby using \ngithub.com/klauspost/pgzip\n package\n\n\nadd citation\n\n\n\n\n\n\nSeqKit v0.3.4\n\n  \n\n\nbugfix: \nseq\n wrongly handles only the first one sequence file when multiple files given\n\n\nnew feature: \nfx2tab\n can output alphabet letters of a sequence by flag \n-a\n (\n--alphabet\n)\n\n\nnew feature: new flag \n-K\n (\n--keep-key\n) for \nreplace\n,  when replacing\nwith key-value file, one can choose keeping the key as value or not.\n\n\n\n\n\n\nSeqKit v0.3.3\n\n  \n\n\nfix bug of \nseqkit replace\n, wrongly starting from 2 when using \n{nr}\n\n  in \n-r\n (\n--replacement\n)\n\n\nnew feature: \nseqkit replace\n supports replacement symbols \n{nr}\n (record number)\n  and \n{kv}\n (corresponding value of the key ($1) by key-value file)\n\n\n\n\n\n\nSeqKit v0.3.2\n\n  \n\n\nfix bug of \nseqkit split\n, error when target file is in a directory.\n\n\nimprove performance of \nseqkit spliding\n for big sequences, and output\n  last part even if it's shorter than window sze,\n  output of FASTQ is also supported.\n\n\n\n\n\n\nSeqKit v0.3.1.1\n\n  \n\n\ncompile with go1.7rc5, with \nhigher performance and smaller size of binary file\n\n\n\n\n\n\nSeqKit v0.3.1\n\n  \n\n\nimprove speed of \nseqkit locate\n\n\n\n\n\n\nSeqKit v0.3.0\n\n  \n\n\nuse fork of github.com/brentp/xopen, using \nzcat\n for speedup of .gz file\n  reading on *nix systems.\n\n\nimprove speed of parsing sequence ID when creating FASTA index\n\n\nreduce memory usage of \nseqkit subseq --gtf\n\n\nfix bug of \nseqkit subseq\n when using flag \n--id-ncbi\n\n\nfix bug of \nseqkit split\n, outdir error\n\n\nfix bug of \nseqkit seq -p\n, last base is wrongly failed to convert when\n  sequence length is odd.\n\n\nadd \"sum_len\" result for output of \nseqkit stat\n\n\n\n\n\n\nseqkit v0.2.9\n\n  \n\n\nfix minor bug of \nseqkit split\n and \nseqkit shuffle\n,\n  header name error due to improper use of pointer\n\n\nadd option \n-O (--out-dir)\n to \nseqkit split\n\n\n\n\n\n\nseqkit v0.2.8\n\n  \n\n\nimprove speed of parsing sequence ID, not using regular expression for default \n--id-regexp\n\n\nimprove speed of record outputing for small-size sequences\n\n\nfix minor bug: \nseqkit seq\n for blank record\n\n\nupdate benchmark result\n\n\n\n\n\n\nseqkit v0.2.7\n\n  \n\n\nreduce memory usage\n by optimize the outputing of sequences.\n  detail: using \nBufferedByteSliceWrapper\n to resuse bytes.Buffer.\n\n\nreduce memory usage and improve speed\n by using custom buffered\n reading mechanism, instead of using standard library \nbufio\n,\n  which is slow for large genome sequence.\n\n\ndiscard strategy of \"buffer\" and \"chunk\" of FASTA/Q records,\n  just parse records one by one.\n\n\ndelete global flags \n-c (--chunk-size)\n and \n-b (--buffer-size)\n.\n\n\nadd function testing scripts\n\n\n\n\n\n\nseqkit v0.2.6\n\n  \n\n\nfix bug of \nseqkit subseq\n: Inplace subseq method leaded to wrong result\n\n\n\n\n\n\nseqkit v0.2.5.1\n\n  \n\n\nfix a bug of \nseqkit subseq\n: chromesome name was not be converting to lower case when using \n--gtf\n or \n--bed\n\n\n\n\n\n\nseqkit v0.2.5\n\n  \n\n\nfix a serious bug brought in \nv0.2.3\n, using unsafe method to convert \nstring\n to \n[]byte\n\n\nadd awk-like built-in variable of record number (\n{NR}\n) for \nseqkit replace\n\n\n\n\n\n\nseqkit v0.2.4.1\n\n  \n\n\nfix several bugs from library \nbio\n, affected situations:\n\n\nLocating patterns in sequences by pattern FASTA file: \nseqkit locate -f\n\n\nReading FASTQ file with record of which the quality starts with \n+\n\n\n\n\n\n\nadd command \nversion\n\n\n\n\n\n\nseqkit v0.2.4\n\n  \n\n\nadd subcommand \nhead\n\n\n\n\n\n\nseqkit v0.2.3\n\n  \n\n\nreduce memory occupation by avoid copy data when convert \nstring\n to \n[]byte\n\n\nspeedup reverse-complement by avoid repeatly calling functions\n\n\n\n\n\n\nseqkit v0.2.2\n\n  \n\n\nreduce memory occupation of subcommands that use FASTA index\n\n\n\n\n\n\nseqkit v0.2.1\n\n  \n\n\nimprove performance of outputing.\n\n\nfix bug of \nseqkit seq -g\n for FASTA fromat\n\n\nsome other minor fix of code and docs\n\n\nupdate benchmark results\n\n\n\n\n\n\nseqkit v0.2.0\n\n  \n\n\nreduce memory usage of writing output\n\n\nfix bug of \nsubseq\n, \nshuffle\n, \nsort\n when reading from stdin\n\n\nreduce memory usage of \nfaidx\n\n\nmake validating sequences an optional option in \nseq\n command, it saves some time.\n\n\n\n\n\n\nseqkit v0.1.9\n\n  \n\n\nusing custom FASTA index file extension: \n.seqkit.fai\n\n\nreducing memory usage of \nsample --number --two-pass\n\n\nchange default CPU number to 2 for multi-cpus computer, and 1 for single-CPU computer\n\n\n\n\n\n\nseqkit v0.1.8\n\n  \n\n\nadd subcommand \nrename\n to rename duplicated IDs\n\n\nadd subcommand \nfaidx\n to create FASTA index file\n\n\nutilize faidx to improve performance of \nsubseq\n\n\nshuffle\n, \nsort\n and split support two-pass mode (by flag \n-2\n) with faidx to reduce memory usage.\n\n\ndocument update\n\n\n\n\n\n\nseqkit v0.1.7\n\n  \n\n\nadd support for (multi-line) FASTQ format\n\n\nupdate document, add technical details\n\n\nrename subcommands \nfa2tab\n and \ntab2fa\n to \nfx2tab\n and \ntab2fx\n\n\nadd subcommand \nfq2fa\n\n\nadd column \"seq_format\" to \nstat\n\n\nadd global flag \n-b\n (\n--bufer-size\n)\n\n\nlittle change of flag in \nsubseq\n and some other commands\n\n\n\n\n\n\nseqkit v0.1.6\n\n  \n\n\nadd subcommand \nreplace\n\n\n\n\n\n\nseqkit v0.1.5.2\n\n  \n\n\nfix bug of \ngrep\n, when not using flag \n-r\n, flag \n-i\n will not take effect.\n\n\n\n\n\n\nseqkit v0.1.5.1\n\n  \n\n\nfix result of \nseqkit sample -n\n\n\nfix benchmark script\n\n\n\n\n\n\nseqkit v0.1.5\n\n  \n\n\nadd global flag \n--id-ncbi\n\n\nadd flag \n-d\n (\n--dup-seqs-file\n) and \n-D\n (\n--dup-num-file\n) for subcommand \nrmdup\n\n\nmake using MD5 as an optional flag \n-m\n (\n--md5\n) in subcommand \nrmdup\n and \ncommon\n\n\nfix file name suffix of \nseqkit split\n result\n\n\nminor modification of \nsliding\n output\n\n\n\n\n\n\nseqkit v0.1.4.1\n\n  \n\n\nchange alignment of \nstat\n output\n\n\npreciser CPUs number control\n\n\n\n\n\n\nseqkit v0.1.4\n\n  \n\n\nadd subcommand \nsort\n\n\nimprove subcommand \nsubseq\n: supporting of getting subsequences by GTF and BED files\n\n\nchange name format of \nsliding\n result\n\n\nprettier output of \nstat\n\n\n\n\n\n\nseqkit v0.1.3.1\n\n  \n\n\nPerformance improvement by reducing time of cleaning spaces\n\n\nDocument update\n\n\n\n\n\n\nseqkit v0.1.3\n\n  \n\n\nFurther performance improvement\n\n\nRename sub command \nextract\n to \ngrep\n\n\nChange default value of flag \n--threads\n back CPU number of current device,\n  change default value of flag \n--chunk-size\n back 10000 sequences.\n\n\nUpdate benchmark\n\n\n\n\n\n\nseqkit v0.1.2\n\n  \n\n\nAdd flag \n--dna2rna\n and \n--rna2dna\n to subcommand \nseq\n.\n\n\n\n\n\n\nseqkit v0.1.1\n\n  \n\n\n5.5X speedup of FASTA file parsing\n by avoid using regular expression to remove spaces (\ndetail\n ) and using slice indexing instead of map to validate letters (\ndetail\n)\n\n\nChange default value of global flag \n-- thread\n to 1. Since most of the subcommands are I/O intensive,  For computation intensive jobs, like extract and locate, you may set a bigger value.\n\n\nChange default value of global flag \n--chunk-size\n to 100.\n\n\nAdd subcommand \nstat\n\n\nFix bug of failing to automatically detect alphabet when only one record in file.\n\n\n\n\n\n\nseqkit v0.1\n\n  \n\n\nfirst release of seqkit\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n\n\n\n\nPlease enable JavaScript to view the \ncomments powered by Disqus.", 
            "title": "Download"
        }, 
        {
            "location": "/download/#download", 
            "text": "SeqKit is implemented in  Go  programming language,\n executable binary files  for most popular operating systems  are freely available\n  in  release  page.", 
            "title": "Download"
        }, 
        {
            "location": "/download/#latest-version", 
            "text": "SeqKit v0.5.2    seqkit seq  and  seqkit stat : change default gap letters from  -  to  - . .", 
            "title": "Latest Version"
        }, 
        {
            "location": "/download/#links", 
            "text": "OS  Arch  File, (Mirror for Chinese Users)  Download Count      Linux  32-bit  seqkit_linux_386.tar.gz , ( mirror )     Linux  64-bit  seqkit_linux_amd64.tar.gz , ( mirror )     OS X  32-bit  seqkit_darwin_386.tar.gz , ( mirror )     OS X  64-bit  seqkit_darwin_amd64.tar.gz , ( mirror )     Windows  32-bit  seqkit_windows_386.exe.tar.gz , ( mirror )     Windows  64-bit  seqkit_windows_amd64.exe.tar.gz , ( mirror )", 
            "title": "Links"
        }, 
        {
            "location": "/download/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/download/#method-1-download-binaries", 
            "text": "Just  download  compressed\nexecutable file of your operating system,\nand decompress it with  tar -zxvf *.tar.gz  command or other tools.\nAnd then:    For Linux-like systems    If you have root privilege simply copy it to  /usr/local/bin :  sudo cp seqkit /usr/local/bin/    Or add the current directory of the executable file to environment variable PATH :  echo export PATH=\\$PATH:\\\"$(pwd)\\\"   ~/.bashrc\nsource ~/.bashrc      For windows , just copy  seqkit.exe  to  C:\\WINDOWS\\system32 .", 
            "title": "Method 1: Download binaries"
        }, 
        {
            "location": "/download/#method-2-install-via-conda", 
            "text": "conda install -c bioconda seqkit", 
            "title": "Method 2: Install via conda"
        }, 
        {
            "location": "/download/#method-3-for-go-developer", 
            "text": "go get -u github.com/shenwei356/seqkit/seqkit", 
            "title": "Method 3: For Go developer"
        }, 
        {
            "location": "/download/#release-history", 
            "text": "SeqKit v0.5.1   seqkit restart : fix bug of flag parsing    SeqKit v0.5.0   new command  seqkit restart , for resetting start position for circular genome .  seqkit sliding : add flag  -g/--greedy , exporting last subsequences even shorter than windows size.  seqkit seq :  add flag  -m/--min-len  and  -M/--max-len  to filter sequences by length .  rename flag  -G/--gap-letter  to  -G/--gap-letters .    seqkit stat :  renamed to  seqkit stats , don't worry, old name is still available as an alias.  add new flag  -a/all , for all statistics, including  sum_gap ,  N50 , and  L50 .      SeqKit v0.4.5   seqkit seq : fix bug of failing to reverse quality of FASTQ sequence    SeqKit v0.4.4   seqkit locate : fix bug of missing regular-expression motifs containing\n non-DNA characters (e.g.,  ACT.{6,7}CGG ) from motif file ( -f ).  compiled with go v1.8.    SeqKit v0.4.3   fix bug of  seqkit stat :  min_len  always be  0  in versions: v0.4.0, v0.4.1, v0.4.2    SeqKit v0.4.2   fix header information of  seqkit subseq  when restriving up- and down-steam\nsequences using GTF/BED file.    SeqKit v0.4.1   enchancement: remove redudant regions for  seqkit locate .    SeqKit v0.4.0   fix bug of  seqkit locate , e.g, only find two locations\n( 1-4 ,  7-10 , missing  4-7 ) of  ACGA  in  ACGACGACGA .  better output of  seqkit stat  for empty file.    SeqKit v0.3.9   fix bug of region selection for blank sequences. affected commands include seqkit subseq --region ,  seqkit grep --region ,  seqkit split --by-region .  compile with go1.8beta1.    SeqKit v0.3.8.1   enhancement and bugfix of  seqkit common : two or more same files allowed,\nfix log information of number of extracted sequences in the first file.    SeqKit v0.3.8   enhancement of  seqkit common : better handling of files containing replicated sequences    SeqKit v0.3.7   fix bug in  seqkit split --by-id  when sequence ID contains invalid characters for system path.  add more flags validation for  seqkit replace .  enhancement: raise error when key pattern matches multiple targes in cases of replacing with key-value files and more controls are added.  changes: do not wrap sequence and quality in output for FASTQ  format.    SeqKit v0.3.6   add new feature for  seqkit grep : new flag  -R  ( --region ) for specifying sequence region for searching.    SeqKit v0.3.5   fig bug of  seqkit grep : flag  -i  ( --ignore-case ) did not work when not using regular expression    SeqKit v0.3.4.1   improve performance of reading (~10%) and writing (100%) gzip-compressed file\nby using  github.com/klauspost/pgzip  package  add citation    SeqKit v0.3.4 \n    bugfix:  seq  wrongly handles only the first one sequence file when multiple files given  new feature:  fx2tab  can output alphabet letters of a sequence by flag  -a  ( --alphabet )  new feature: new flag  -K  ( --keep-key ) for  replace ,  when replacing\nwith key-value file, one can choose keeping the key as value or not.    SeqKit v0.3.3 \n    fix bug of  seqkit replace , wrongly starting from 2 when using  {nr} \n  in  -r  ( --replacement )  new feature:  seqkit replace  supports replacement symbols  {nr}  (record number)\n  and  {kv}  (corresponding value of the key ($1) by key-value file)    SeqKit v0.3.2 \n    fix bug of  seqkit split , error when target file is in a directory.  improve performance of  seqkit spliding  for big sequences, and output\n  last part even if it's shorter than window sze,\n  output of FASTQ is also supported.    SeqKit v0.3.1.1 \n    compile with go1.7rc5, with  higher performance and smaller size of binary file    SeqKit v0.3.1 \n    improve speed of  seqkit locate    SeqKit v0.3.0 \n    use fork of github.com/brentp/xopen, using  zcat  for speedup of .gz file\n  reading on *nix systems.  improve speed of parsing sequence ID when creating FASTA index  reduce memory usage of  seqkit subseq --gtf  fix bug of  seqkit subseq  when using flag  --id-ncbi  fix bug of  seqkit split , outdir error  fix bug of  seqkit seq -p , last base is wrongly failed to convert when\n  sequence length is odd.  add \"sum_len\" result for output of  seqkit stat    seqkit v0.2.9 \n    fix minor bug of  seqkit split  and  seqkit shuffle ,\n  header name error due to improper use of pointer  add option  -O (--out-dir)  to  seqkit split    seqkit v0.2.8 \n    improve speed of parsing sequence ID, not using regular expression for default  --id-regexp  improve speed of record outputing for small-size sequences  fix minor bug:  seqkit seq  for blank record  update benchmark result    seqkit v0.2.7 \n    reduce memory usage  by optimize the outputing of sequences.\n  detail: using  BufferedByteSliceWrapper  to resuse bytes.Buffer.  reduce memory usage and improve speed  by using custom buffered\n reading mechanism, instead of using standard library  bufio ,\n  which is slow for large genome sequence.  discard strategy of \"buffer\" and \"chunk\" of FASTA/Q records,\n  just parse records one by one.  delete global flags  -c (--chunk-size)  and  -b (--buffer-size) .  add function testing scripts    seqkit v0.2.6 \n    fix bug of  seqkit subseq : Inplace subseq method leaded to wrong result    seqkit v0.2.5.1 \n    fix a bug of  seqkit subseq : chromesome name was not be converting to lower case when using  --gtf  or  --bed    seqkit v0.2.5 \n    fix a serious bug brought in  v0.2.3 , using unsafe method to convert  string  to  []byte  add awk-like built-in variable of record number ( {NR} ) for  seqkit replace    seqkit v0.2.4.1 \n    fix several bugs from library  bio , affected situations:  Locating patterns in sequences by pattern FASTA file:  seqkit locate -f  Reading FASTQ file with record of which the quality starts with  +    add command  version    seqkit v0.2.4 \n    add subcommand  head    seqkit v0.2.3 \n    reduce memory occupation by avoid copy data when convert  string  to  []byte  speedup reverse-complement by avoid repeatly calling functions    seqkit v0.2.2 \n    reduce memory occupation of subcommands that use FASTA index    seqkit v0.2.1 \n    improve performance of outputing.  fix bug of  seqkit seq -g  for FASTA fromat  some other minor fix of code and docs  update benchmark results    seqkit v0.2.0 \n    reduce memory usage of writing output  fix bug of  subseq ,  shuffle ,  sort  when reading from stdin  reduce memory usage of  faidx  make validating sequences an optional option in  seq  command, it saves some time.    seqkit v0.1.9 \n    using custom FASTA index file extension:  .seqkit.fai  reducing memory usage of  sample --number --two-pass  change default CPU number to 2 for multi-cpus computer, and 1 for single-CPU computer    seqkit v0.1.8 \n    add subcommand  rename  to rename duplicated IDs  add subcommand  faidx  to create FASTA index file  utilize faidx to improve performance of  subseq  shuffle ,  sort  and split support two-pass mode (by flag  -2 ) with faidx to reduce memory usage.  document update    seqkit v0.1.7 \n    add support for (multi-line) FASTQ format  update document, add technical details  rename subcommands  fa2tab  and  tab2fa  to  fx2tab  and  tab2fx  add subcommand  fq2fa  add column \"seq_format\" to  stat  add global flag  -b  ( --bufer-size )  little change of flag in  subseq  and some other commands    seqkit v0.1.6 \n    add subcommand  replace    seqkit v0.1.5.2 \n    fix bug of  grep , when not using flag  -r , flag  -i  will not take effect.    seqkit v0.1.5.1 \n    fix result of  seqkit sample -n  fix benchmark script    seqkit v0.1.5 \n    add global flag  --id-ncbi  add flag  -d  ( --dup-seqs-file ) and  -D  ( --dup-num-file ) for subcommand  rmdup  make using MD5 as an optional flag  -m  ( --md5 ) in subcommand  rmdup  and  common  fix file name suffix of  seqkit split  result  minor modification of  sliding  output    seqkit v0.1.4.1 \n    change alignment of  stat  output  preciser CPUs number control    seqkit v0.1.4 \n    add subcommand  sort  improve subcommand  subseq : supporting of getting subsequences by GTF and BED files  change name format of  sliding  result  prettier output of  stat    seqkit v0.1.3.1 \n    Performance improvement by reducing time of cleaning spaces  Document update    seqkit v0.1.3 \n    Further performance improvement  Rename sub command  extract  to  grep  Change default value of flag  --threads  back CPU number of current device,\n  change default value of flag  --chunk-size  back 10000 sequences.  Update benchmark    seqkit v0.1.2 \n    Add flag  --dna2rna  and  --rna2dna  to subcommand  seq .    seqkit v0.1.1 \n    5.5X speedup of FASTA file parsing  by avoid using regular expression to remove spaces ( detail  ) and using slice indexing instead of map to validate letters ( detail )  Change default value of global flag  -- thread  to 1. Since most of the subcommands are I/O intensive,  For computation intensive jobs, like extract and locate, you may set a bigger value.  Change default value of global flag  --chunk-size  to 100.  Add subcommand  stat  Fix bug of failing to automatically detect alphabet when only one record in file.    seqkit v0.1 \n    first release of seqkit      \n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();  Please enable JavaScript to view the  comments powered by Disqus.", 
            "title": "Release History"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage and Examples\n\n\n\n\n\n\n\n\nTable of Contents\n\n\n\n\nTechnical details and guides for use\n\n\nseqkit\n\n\n\n\nSequence and subsequence\n\n\n\n\nseq\n\n\nsubseq\n\n\nsliding\n\n\nstats\n\n\n\n\nFormat conversion\n\n\n\n\nfq2fa\n\n\nfx2tab \n tab2fx\n\n\n\n\nSearching\n\n\n\n\ngrep\n\n\nlocate\n\n\n\n\nSet operations\n\n\n\n\nrmdup\n\n\ncommon\n\n\nsplit\n\n\nsample\n\n\nhead\n\n\n\n\nEdit\n\n\n\n\nreplace\n\n\nrename\n\n\nrestart\n\n\n\n\nOrdering\n\n\n\n\nshuffle\n\n\nsort\n\n\n\n\n\n\n\nTechnical details and guides for use\n\n\nFASTA/Q format parsing\n\n\nSeqKit uses author's lightweight and high-performance bioinformatics packages\n\nbio\n for FASTA/Q parsing,\nwhich has \nhigh performance\n\nclose to the\nfamous C lib \nklib\n (\nkseq.h\n).\n\n\n\n\nSequence formats and types\n\n\nSeqKit seamlessly support FASTA and FASTQ format.\nSequence format is automatically detected.\nAll subcommands except for \nfaidx\n can handle both formats.\nAnd only when some commands (\nsubseq\n, \nsplit\n, \nsort\n and \nshuffle\n)\nwhich utilise FASTA index to improve perfrmance for large files in two pass mode\n(by flag \n--two-pass\n), only FASTA format is supported.\n\n\nSequence type (DNA/RNA/Protein) is automatically detected by leading subsequences\nof the first sequences in file or STDIN. The length of the leading subsequences\nis configurable by global flag \n--alphabet-guess-seq-length\n with default value\nof 10000. If length of the sequences is less than that, whole sequences will\nbe checked.\n\n\nSequence ID\n\n\nBy default, most softwares, including \nseqkit\n, take the leading non-space\nletters as sequence identifier (ID). For example,\n\n\n\n\n\n\n\n\nFASTA header\n\n\nID\n\n\n\n\n\n\n\n\n\n\n123456 gene name\n\n\n123456\n\n\n\n\n\n\nlongname\n\n\nlongname\n\n\n\n\n\n\ngi\n110645304\nref\nNC_002516.2\n Pseudomona\n\n\ngi\n110645304\nref\nNC_002516.2\n\n\n\n\n\n\n\n\nBut for some sequences from NCBI,\ne.g. \ngi|110645304|ref|NC_002516.2| Pseudomona\n, the ID is \nNC_002516.2\n.\nIn this case, we could set sequence ID parsing regular expression by global flag\n\n--id-regexp \"\\|([^\\|]+)\\| \"\n or just use flag \n--id-ncbi\n. If you want\nthe \ngi\n number, then use \n--id-regexp \"^gi\\|([^\\|]+)\\|\"\n.\n\n\nFASTA index\n\n\nFor some commands, including \nsubseq\n, \nsplit\n, \nsort\n and \nshuffle\n,\nwhen input files are (plain or gzipped) FASTA files,\nFASTA index would be optional used for\nrapid access of sequences and reducing memory occupation.\n\n\nATTENTION: the \n.seqkit.fai\n file created by SeqKit is a little different from \n.fai\n file\ncreated by \nsamtools\n. SeqKit uses full sequence head instead of just ID as key.\n\n\nParallelization of CPU intensive jobs\n\n\nThe validation of sequences bases and complement process of sequences\nare parallelized for large sequences.\n\n\nParsing of line-based files, including BED/GFF file and ID list file are also parallelized.\n\n\nThe Parallelization is implemented by multiple goroutines in golang\n which are similar to but much\nlighter weight than threads. The concurrency number is configurable with global\nflag \n-j\n or \n--threads\n (default value: 1 for single-CPU PC, 2 for others).\n\n\nMemory occupation\n\n\nMost of the subcommands do not read whole FASTA/Q records in to memory,\nincluding \nstat\n, \nfq2fa\n, \nfx2tab\n, \ntab2fx\n, \ngrep\n, \nlocate\n, \nreplace\n,\n \nseq\n, \nsliding\n, \nsubseq\n.\n\n\nNote that when using \nsubseq --gtf | --bed\n, if the GTF/BED files are too\nbig, the memory usage will increase.\nYou could use \n--chr\n to specify chromesomes and \n--feature\n to limit features.\n\n\nSome subcommands need to store sequences or heads in memory, but there are\nstrategy to reduce memory occupation, including \nrmdup\n and \ncommon\n.\nWhen comparing with sequences, MD5 digest could be used to replace sequence by\nflag \n-m\n (\n--md5\n).\n\n\nSome subcommands could either read all records or read the files twice by flag\n\n-2\n (\n--two-pass\n), including \nsample\n, \nsplit\n, \nshuffle\n and \nsort\n.\nThey use FASTA index for rapid acccess of sequences and reducing memory occupation.\n\n\nReproducibility\n\n\nSubcommands \nsample\n and \nshuffle\n use random function, random seed could be\ngiven by flag \n-s\n (\n--rand-seed\n). This makes sure that sampling result could be\nreproduced in different environments with same random seed.\n\n\nseqkit\n\n\nUsage\n\n\nSeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation\n\nVersion: 0.5.0\n\nAuthor: Wei Shen \nshenwei356@gmail.com\n\n\nDocuments  : http://bioinf.shenwei.me/seqkit\nSource code: https://github.com/shenwei356/seqkit\nPlease cite: https://doi.org/10.1371/journal.pone.0163962\n\nUsage:\n  seqkit [command]\n\nAvailable Commands:\n  common      find common sequences of multiple files by id/name/sequence\n  faidx       create FASTA index file\n  fq2fa       covert FASTQ to FASTA\n  fx2tab      covert FASTA/Q to tabular format (with length/GC content/GC skew)\n  grep        search sequences by pattern(s) of name or sequence motifs\n  head        print first N FASTA/Q records\n  help        Help about any command\n  locate      locate subsequences/motifs\n  rename      rename duplicated IDs\n  replace     replace name/sequence by regular expression\n  restart     reset start position for circular genome\n  rmdup       remove duplicated sequences by id/name/sequence\n  sample      sample sequences by number or proportion\n  seq         transform sequences (revserse, complement, extract ID...)\n  shuffle     shuffle sequences\n  sliding     sliding sequences, circular genome supported\n  sort        sort sequences by id/name/sequence/length\n  split       split sequences into files by id/seq region/size/parts\n  stats       simple statistics of FASTA files\n  subseq      get subsequences by region/gtf/bed, including flanking sequences\n  tab2fx      covert tabular format to FASTA/Q format\n  version     print version information and check for update\n\nFlags:\n      --alphabet-guess-seq-length int   length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000)\n      --id-ncbi                         FASTA head is NCBI-style, e.g. \ngi|110645304|ref|NC_002516.2| Pseud...\n      --id-regexp string                regular expression for parsing ID (default \n^([^\\s]+)\\s?\n)\n  -w, --line-width int                  line width when outputing FASTA format (0 for no wrap) (default 60)\n  -o, --out-file string                 out file (\n-\n for stdout, suffix .gz for gzipped out) (default \n-\n)\n      --quiet                           be quiet and do not show extra information\n  -t, --seq-type string                 sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \nauto\n)\n  -j, --threads int                     number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)\n\nUse \nseqkit [command] --help\n for more information about a command.\n\n\n\n\n\nDatasets\n\n\nDatasets from \nThe miRBase Sequence Database -- Release 21\n\n\n\n\nhairpin.fa.gz\n\n\nmature.fa.gz\n\n\nmiRNA.diff.gz\n\n\n\n\nHuman genome from \nensembl\n\n(For \nseqkit subseq\n)\n\n\n\n\nHomo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz\n\n\nHomo_sapiens.GRCh38.84.gtf.gz\n\n\nHomo_sapiens.GRCh38.84.bed.gz\n is converted from \nHomo_sapiens.GRCh38.84.gtf.gz\n\nby \ngtf2bed\n\nwith command\nzcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c \n Homo_sapiens.GRCh38.84.bed.gz\n\n\n\n\n\n\n\nOnly DNA and gtf/bed data of Chr1 were used:\n\n\n\n\n\n\nchr1.fa.gz\n\n\nseqkit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz\n\n\n\n\n\n\n\nchr1.gtf.gz\n\n\nzcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c \n chr1.gtf.gz\n\n\n\n\n\n\n\nchr1.bed.gz\n\n\nzcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c \n chr1.bed.gz\n\n\n\n\n\n\n\nseq\n\n\nUsage\n\n\ntransform sequences (revserse, complement, extract ID...)\n\nUsage:\n  seqkit seq [flags]\n\nFlags:\n  -p, --complement                complement sequence (blank for Protein sequence)\n      --dna2rna                   DNA to RNA\n  -G, --gap-letter string         gap letters (default \n- \n)\n  -l, --lower-case                print sequences in lower case\n  -n, --name                      only print names\n  -i, --only-id                   print ID instead of full head\n  -q, --qual                      only print qualities\n  -g, --remove-gaps               remove gaps\n  -r, --reverse                   reverse sequence\n      --rna2dna                   RNA to DNA\n  -s, --seq                       only print sequences\n  -u, --upper-case                print sequences in upper case\n  -v, --validate-seq              validate bases according to the alphabet\n  -V, --validate-seq-length int   length of sequence to validate (0 for whole seq) (default 10000)\n\n\n\n\n\nExamples\n\n\n\n\n\n\nRead and print\n\n\n\n\n\n\nFrom file:\n\n\n$ seqkit seq hairpin.fa.gz\n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC\nUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\n\n$ seqkit seq read_1.fq.gz\n@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG\nTGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG\n+\nHIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII\n\n\n\n\n\n\n\nFrom stdin:\n\n\nzcat hairpin.fa.gz | seqkit seq\n\n\n\n\n\n\n\n\n\n\n\nSequence types\n\n\n\n\n\n\nBy default, \nseqkit seq\n automatically detect the sequence type\n\n\n$ echo -e \"\nseq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | seqkit stats\nfile  format  type  num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTA   DNA          1       28       28       28       28\n\n$ echo -e \"\nseq\\nACGUN ACGUN\" | seqkit stats\nfile  format  type  num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTA   RNA          1       11       11       11       11\n\n$ echo -e \"\nseq\\nabcdefghijklmnpqrstvwyz\" | seqkit stats\nfile  format  type     num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTA   Protein         1       23       23       23       23\n\n$ echo -e \"@read\\nACTGCN\\n+\\n@IICCG\" | seqkit stats\nfile  format  type  num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTQ   DNA          1        6        6        6        6\n\n\n\n\n\n\n\nYou can also set sequence type by flag \n-t\n (\n--seq-type\n).\n  But this only take effect on subcommands \nseq\n and \nlocate\n.\n\n\n$ echo -e \"\nseq\\nabcdefghijklmnpqrstvwyz\" | seqkit seq -t dna\n[INFO] when flag -t (--seq-type) given, flag -v (--validate-seq) is automatically switched on\n[ERRO] error when parsing seq: seq (invalid DNAredundant letter: e)\n\n\n\n\n\n\n\n\n\n\n\nOnly print names\n\n\n\n\n\n\nFull name:\n\n\n$ seqkit seq hairpin.fa.gz -n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop\n\n\n\n\n\n\n\nOnly ID:\n\n\n$ seqkit seq hairpin.fa.gz -n -i\ncel-let-7\ncel-lin-4\ncel-mir-1\n\n\n\n\n\n\n\nCustom ID region by regular expression (this could be applied to all subcommands):\n\n\n$ seqkit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\"\nMI0000001\nMI0000002\nMI0000003\n\n\n\n\n\n\n\n\n\n\n\nOnly print seq (global flag \n-w\n defines the output line width, 0 for no wrap)\n\n\n$ seqkit seq hairpin.fa.gz -s -w 0\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\nAUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU\nAAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU\n\n\n\n\n\n\n\nConvert multi-line FASTQ to 4-line FASTQ\n\n\n$ seqkit seq reads_1.fq.gz -w 0\n\n\n\n\n\n\n\nReverse comlement sequence\n\n\n$ seqkit seq hairpin.fa.gz -r -p\n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC\nAAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA\n\n\n\n\n\n\n\nRemove gaps and to lower/upper case\n\n\n$ echo -e \"\nseq\\nACGT-ACTGC-ACC\" | seqkit seq -g -u\n\nseq\nACGTACTGCACC\n\n\n\n\n\n\n\nRNA to DNA\n\n\n$ echo -e \"\nseq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | seqkit seq --rna2dna\n\nseq\nTCATATGCTTGTCTCAAAGATTA\n\n\n\n\n\n\n\nFilter by sequence length\n\n\n$ cat hairpin.fa | seqkit seq | seqkit stats\nfile  format  type  num_seqs    sum_len  min_len  avg_len  max_len\n-     FASTA   RNA     28,645  2,949,871       39      103    2,354\n\n$ cat hairpin.fa | seqkit seq -m 100 | seqkit stats\nfile  format  type  num_seqs    sum_len  min_len  avg_len  max_len\n-     FASTA   RNA     10,975  1,565,486      100    142.6    2,354\n\n$ cat hairpin.fa | seqkit seq -m 100 -M 1000 | seqkit stats\nfile  format  type  num_seqs    sum_len  min_len  avg_len  max_len\n-     FASTA   RNA     10,972  1,560,270      100    142.2      938\n\n\n\n\n\n\n\nsubseq\n\n\nUsage\n\n\nget subsequences by region/gtf/bed, including flanking sequences.\n\nRecommendation: use plain FASTA file, so seqkit could utilize FASTA index.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n          1:12    A C G T N a c g t n\n        -12:-1    A C G T N a c g t n\n\nUsage:\n  seqkit subseq [flags]\n\nFlags:\n      --bed string        by BED file\n      --chr value         select limited sequence with sequence IDs (multiple value supported, case ignored) (default [])\n  -d, --down-stream int   down stream length\n      --feature value     select limited feature types (multiple value supported, case ignored, only works with GTF) (default [])\n      --gtf string        by GTF (version 2.2) file\n  -f, --only-flank        only return up/down stream sequence\n  -r, --region string     by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type \nseqkit subseq -h\n for more examples\n  -u, --up-stream int     up stream length\n\n\n\n\n\nExamples\n\n\nRecommendation: use plain FASTA file, so seqkit could utilize FASTA index.\n\n\n\n\n\n\nFirst 12 bases\n\n\n$ zcat hairpin.fa.gz | seqkit subseq -r 1:12\n\n\n\n\n\n\n\nLast 12 bases\n\n\n$ zcat hairpin.fa.gz | seqkit subseq -r -12:-1\n\n\n\n\n\n\n\nSubsequences without first and last 12 bases\n\n\n$ zcat hairpin.fa.gz | seqkit subseq -r 13:-13\n\n\n\n\n\n\n\nGet subsequence by GTF file\n\n\n$ cat t.fa\n\nseq\nactgACTGactgn\n\n$ cat t.gtf\nseq     test    CDS     5       8       .       .       .       gene_id \"A\"; transcript_id \"\";\nseq     test    CDS     5       8       .       -       .       gene_id \"B\"; transcript_id \"\";\n\n$ seqkit subseq --gtf t.gtf t.fa\n\nseq_5:8:. A\nACTG\n\nseq_5:8:- B\nCAGT\n\n\n\nHuman genome example:\n\n\nAVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz,\nthe uncompressed data are so big and may exhaust your RAM.\n\n\nWe could specify chromesomes and features.\n\n\n$ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds  hsa.fa \n chr1.gtf.cds.fa\n\n$ seqkit stats chr1.gtf.cds.fa\nfile             format  type  num_seqs    sum_len  min_len  avg_len  max_len\nchr1.gtf.cds.fa  FASTA   DNA     65,012  9,842,274        1    151.4   12,045\n\n\n\n\n\n\n\nGet CDS and 3bp up-stream sequences\n\n\n$ seqkit subseq --gtf t.gtf t.fa -u 3\n\nseq_5:8:._us:3 A\nctgACTG\n\nseq_5:8:-_us:3 B\nagtCAGT\n\n\n\n\n\n\n\nGet 3bp up-stream sequences of CDS, not including CDS\n\n\n$ seqkit subseq --gtf t.gtf t.fa -u 3 -f\n\nseq_5:8:._usf:3 A\nctg\n\nseq_5:8:-_usf:3 B\nagt\n\n\n\n\n\n\n\nGet subsequences by BED file.\n\n\nAVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz,\nthe uncompressed data are so big and may exhaust your RAM.\n\n\n$  seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \n  chr1.bed.gz.fa\n\n\n\nWe may need to remove duplicated sequences\n\n\n$ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa | seqkit rmdup \n chr1.bed.rmdup.fa\n[INFO] 141060 duplicated records removed\n\n\n\nSummary:\n\n\n$ seqkit stats chr1.gz.*.gz\nfile               seq_format   seq_type   num_seqs   min_len   avg_len     max_len\nchr1.gz.fa         FASTA        DNA         231,974         1   3,089.5   1,551,957\nchr1.gz.rmdup.fa   FASTA        DNA          90,914         1   6,455.8   1,551,957\n\n\n\n\n\n\n\nsliding\n\n\nUsage\n\n\nsliding sequences, circular genome supported\n\nUsage:\n  seqkit sliding [flags]\n\nFlags:\n  -C, --circular-genome   circular genome.\n  -g, --greedy            greedy mode, i.e., exporting last subsequences even shorter than windows size\n  -s, --step int          step size\n  -W, --window int        window size\n\n\n\n\n\nExamples\n\n\n\n\n\n\nGeneral use\n\n\n$ echo -e \"\nseq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6\n\nseq_sliding:1-6\nACGTac\n\nseq_sliding:4-9\nTacgtN\n\n\n\n\n\n\n\nGreedy mode\n\n\n$ echo -e \"\nseq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -g\n\nseq_sliding:1-6\nACGTac\n\nseq_sliding:4-9\nTacgtN\n\nseq_sliding:7-12\ngtNN\n\nseq_sliding:10-15\nN\n\n\n\n\n\n\n\nCircular genome\n\n\n$ echo -e \"\nseq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -C\n\nseq_sliding:1-6\nACGTac\n\nseq_sliding:4-9\nTacgtN\n\nseq_sliding:7-2\ngtNNAC\n\nseq_sliding:10-5\nNACGTa\n\n\n\n\n\n\n\nGenerate GC content for ploting\n\n\n$ zcat hairpin.fa.gz | seqkit fx2tab | head -n 1 | seqkit tab2fx | seqkit sliding -s 5 -W 30 | seqkit fx2tab -n -g\ncel-let-7_sliding:1-30          50.00\ncel-let-7_sliding:6-35          46.67\ncel-let-7_sliding:11-40         43.33\ncel-let-7_sliding:16-45         36.67\ncel-let-7_sliding:21-50         33.33\ncel-let-7_sliding:26-55         40.00\n...\n\n\n\n\n\n\n\nstats\n\n\nUsage\n\n\nsimple statistics of FASTA files\n\nUsage:\n  seqkit stats [flags]\n\nAliases:\n  stats, stat\n\n\nFlags:\n  -a, --all                  all statistics, including sum_gap, N50, L50\n  -G, --gap-letters string   gap letters (default \n- \n)\n\n\n\n\n\nEexamples\n\n\n\n\n\n\nGeneral use\n\n\n$ seqkit stats *.f{a,q}.gz\nfile           format  type  num_seqs    sum_len  min_len  avg_len  max_len\nhairpin.fa.gz  FASTA   RNA     28,645  2,949,871       39      103    2,354\nmature.fa.gz   FASTA   RNA     35,828    781,222       15     21.8       34\nreads_1.fq.gz  FASTQ   DNA      2,500    567,516      226      227      229\nreads_2.fq.gz  FASTQ   DNA      2,500    560,002      223      224      225\n\n\n\n\n\n\n\nExtra information\n\n\n$ seqkit stats *.f{a,q}.gz -a\nfile           format  type  num_seqs    sum_len  min_len  avg_len  max_len  sum_gap  N50     L50\nhairpin.fa.gz  FASTA   RNA     28,645  2,949,871       39      103    2,354        0  101  10,075\nmature.fa.gz   FASTA   RNA     35,828    781,222       15     21.8       34        0   22  17,144\nreads_1.fq.gz  FASTQ   DNA      2,500    567,516      226      227      229        0  227   1,250\nreads_2.fq.gz  FASTQ   DNA      2,500    560,002      223      224      225        0  224   1,250\n\n\n\n\n\n\n\nfq2fa\n\n\nUsage\n\n\ncovert FASTQ to FASTA\n\nUsage:\n  seqkit fq2fa [flags]\n\n\n\n\n\nExamples\n\n\nseqkit fq2fa reads_1.fq.gz -o reads1_.fa.gz\n\n\n\nfx2tab \n tab2fx\n\n\nUsage (fx2tab)\n\n\ncovert FASTA/Q to tabular format, and provide various information,\nlike sequence length, GC content/GC skew.\n\nUsage:\n  seqkit fx2tab [flags]\n\nFlags:\n  -B, --base-content value   print base content. (case ignored, multiple values supported) e.g. -B AT -B N (default [])\n  -g, --gc                   print GC content\n  -G, --gc-skew              print GC-Skew\n  -H, --header-line          print header line\n  -l, --length               print sequence length\n  -n, --name                 only print names (no sequences and qualities)\n  -i, --only-id              print ID instead of full head\n\n\n\n\n\nUsage (tab2fx)\n\n\ncovert tabular format (first two/three columns) to FASTA/Q format\n\nUsage:\n  seqkit tab2fx [flags]\n\nFlags:\n  -p, --comment-line-prefix value   comment line prefix (default [#,//])\n\n\n\n\n\n\nExamples\n\n\n\n\n\n\nDefault output\n\n\n$ seqkit fx2tab hairpin.fa.gz | head -n 2\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop      UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU\n\n\n\n\n\n\n\nPrint sequence length, GC content, and only print names (no sequences),\nwe could also print title line by flag \n-T\n.\n\n\n$ seqkit fx2tab hairpin.fa.gz -l -g -n -i -H | head -n 4 | csvtk -t -C '\n' pretty\n#name       seq   qual   length   GC\ncel-let-7                99       43.43\ncel-lin-4                94       54.26\ncel-mir-1                96       40.62\n\n\n\n\n\n\n\nUse fx2tab and tab2fx in pipe\n\n\n$ zcat hairpin.fa.gz | seqkit fx2tab | seqkit tab2fx\n\n$ zcat reads_1.fq.gz | seqkit fx2tab | seqkit tab2fx\n\n\n\n\n\n\n\nSort sequences by length (use \nseqkit sort -l\n)\n\n\n$ zcat hairpin.fa.gz | seqkit fx2tab -l | sort -t\"`echo -e '\\t'`\" -n -k4,4 | seqkit tab2fx\n\ncin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop\nUUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC\n\nmmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop\nUGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU\n\ncin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop\nACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU\n\n$ seqkit sort -l hairpin.fa.gz\n\n\n\nSorting or filtering by GC (or other base by -flag \n-B\n) content could also achieved in similar way.\n\n\n\n\n\n\nGet first 1000 sequences (use \nseqkit head -n 1000\n)\n\n\n$ seqkit fx2tab hairpin.fa.gz | head -n 1000 | seqkit tab2fx\n\n$ seqkit fx2tab reads_1.fq.gz | head -n 1000 | seqkit tab2fx\n\n\n\n\n\n\n\nExtension\n\n\nAfter converting FASTA to tabular format with \nseqkit fx2tab\n,\nit could be handled with CSV/TSV tools,\n e.g. \ncsvtk\n, a cross-platform, efficient and practical CSV/TSV toolkit\n\n\n\n\ncsvtk grep\n could be used to filter sequences (similar with \nseqkit grep\n)\n\n\ncsvtk inter\n\ncomputates intersection of multiple files. It could achieve similar function\nas \nseqkit common -n\n along with shell.\n\n\ncsvtk join\n joins multiple CSV/TSV files by multiple IDs.\n\n\ncsv_melt\n\nprovides melt function, could be used in preparation of data for ploting.\n\n\n\n\ngrep\n\n\nUsage\n\n\nsearch sequences by pattern(s) of name or sequence motifs\n\nYou can specify the sequence region for searching with flag -R/--region.\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n          1:12    A C G T N a c g t n\n        -12:-1    A C G T N a c g t n\n\nUsage:\n  seqkit grep [flags]\n\nFlags:\n  -n, --by-name               match by full name instead of just id\n  -s, --by-seq                match by seq\n  -d, --degenerate            pattern/motif contains degenerate base\n      --delete-matched        delete matched pattern to speedup\n  -i, --ignore-case           ignore case\n  -v, --invert-match          invert the sense of matching, to select non-matching records\n  -p, --pattern stringSlice   search pattern (multiple values supported)\n  -f, --pattern-file string   pattern file\n  -R, --region string         specify sequence region for searching. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases\n  -r, --use-regexp            patterns are regular expression\n\n\n\n\n\nExamples\n\n\n\n\n\n\nExtract human hairpins (i.e. sequences with name starting with \nhsa\n)\n\n\n$ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa\n\nhsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop\nUGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU\nACAAUCUACUGUCUUUCCUA\n\nhsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop\nAGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU\nCCUAGCUUUCCU\n\n\n\n\n\n\n\nRemove human and mice hairpins.\n\n\n$ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v\n\n\n\n\n\n\n\nExtract new entries by information from miRNA.diff.gz\n\n\n\n\n\n\nGet IDs of new entries.\n\n\n$ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2 \n list\n$ more list\ncfa-mir-486\ncfa-mir-339-1\npmi-let-7\n\n\n\n\n\n\n\nExtract by ID list file\n\n\n$ zcat hairpin.fa.gz | seqkit grep -f list \n new.fa\n\n\n\n\n\n\n\n\n\n\n\nExtract sequences starting with AGGCG\n\n\n$ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg\n\n\n\n\n\n\n\nExtract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G.\n\n\n$ zcat hairpin.fa.gz | seqkit grep -s -d -i -p TTSAA\n\n\n\nIt's equal to but simpler than:\n\n\n$ zcat hairpin.fa.gz | seqkit grep -s -r -i -p TT[CG]AA\n\n\n\n\n\n\n\nSpecify sequence regions for searching. e.g., leading 30 bases.\n\n\n$ seqkit grep -s -R 1:30 -i -r -p GCTGG\n\n\n\n\n\n\n\nlocate\n\n\nUsage\n\n\nlocate subsequences/motifs\n\nMotifs could be EITHER plain sequence containing \nACTGN\n OR regular\nexpression like \nA[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\n for ORFs.\nDegenerate bases like \nRYMM..\n are also supported by flag -d.\n\nBy default, motifs are treated as regular expression.\nWhen flag -d given, regular expression may be wrong.\nFor example: \n\\w\n will be wrongly converted to \n\\[AT]\n.\n\nUsage:\n  seqkit locate [flags]\n\nFlags:\n  -d, --degenerate                pattern/motif contains degenerate base\n  -i, --ignore-case               ignore case\n  -P, --only-positive-strand      only search on positive strand\n  -p, --pattern stringSlice       pattern/motif (multiple values supported. use double quotation marks for patterns containing comma, e.g., -p '\nA{2,}\n')\n  -f, --pattern-file string       pattern/motif file (FASTA format)\n  -V, --validate-seq-length int   length of sequence to validate (0 for whole seq) (default 10000)\n\n\n\n\n\nExamples\n\n\n\n\n\n\nLocate ORFs.\n\n\n$ zcat hairpin.fa.gz | seqkit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\"\nseqID   patternName     pattern strand  start   end     matched\ncel-lin-4       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  136      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  54       95      AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        -  43       51      AUGAUAUAG\n\n\n\n\n\n\n\nLocate Motif.\n\n\n$ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN\nseqID         patternName   pattern    strand   start   end   matched\ncel-mir-58a   AUGGACUN      AUGGACUN   +        81      88    AUGGACUG\nath-MIR163    AUGGACUN      AUGGACUN   -        122     129   AUGGACUC\n\n\n\nNotice that \nseqkit grep\n only searches in positive strand, but \nseqkit loate\n could recognize both strand\n\n\n\n\n\n\nrmdup\n\n\nUsage\n\n\nremove duplicated sequences by id/name/sequence\n\nUsage:\n  seqkit rmdup [flags]\n\nFlags:\n    -n, --by-name                by full name instead of just id\n    -s, --by-seq                 by seq\n    -D, --dup-num-file string    file to save number and list of duplicated seqs\n    -d, --dup-seqs-file string   file to save duplicated seqs\n    -i, --ignore-case            ignore case\n    -m, --md5                    use MD5 instead of original seqs to reduce memory usage when comparing by seqs\n\n\n\n\n\nExamples\n\n\nSimilar to \ncommon\n.\n\n\n\n\n\n\nGeneral use\n\n\n$ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz\n[INFO] 2226 duplicated records removed\n\n$ zcat reads_1.fq.gz | seqkit rmdup -s -o clean.fa.gz\n[INFO] 1086 duplicated records removed\n\n\n\n\n\n\n\nSave duplicated sequences to file\n\n\n$ zcat hairpin.fa.gz | seqkit rmdup -s -i -m -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ cat duplicated.detail.txt   # here is not the entire list\n3   hsa-mir-424, mml-mir-424, ppy-mir-424\n3   hsa-mir-342, mml-mir-342, ppy-mir-342\n2   ngi-mir-932, nlo-mir-932\n2   ssc-mir-9784-1, ssc-mir-9784-2\n\n\n\n\n\n\n\ncommon\n\n\nUsage\n\n\nfind common sequences of multiple files by id/name/sequence\n\nUsage:\n  seqkit common [flags]\n\nFlags:\n    -n, --by-name       match by full name instead of just id\n    -s, --by-seq        match by sequence\n    -i, --ignore-case   ignore case\n    -m, --md5           use MD5 instead of original seqs to reduce memory usage when comparing by seqs\n\n\n\n\n\nExamples\n\n\n\n\n\n\nBy ID (default)\n\n\nseqkit common file*.fa -o common.fasta\n\n\n\n\n\n\n\nBy full name\n\n\nseqkit common file*.fa -n -o common.fasta\n\n\n\n\n\n\n\nBy sequence\n\n\nseqkit common file*.fa -s -i -o common.fasta\n\n\n\n\n\n\n\nBy sequence (\nfor large sequences\n)\n\n\nseqkit common file*.fa -s -i -o common.fasta --md5\n\n\n\n\n\n\n\nsplit\n\n\nUsage\n\n\nsplit sequences into files by name ID, subsequence of given region,\npart size or number of parts.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n          1:12    A C G T N a c g t n\n        -12:-1    A C G T N a c g t n\n\nUsage:\n  seqkit split [flags]\n\nFlags:\nFlags:\n  -i, --by-id              split squences according to sequence ID\n  -p, --by-part int        split squences into N parts\n  -r, --by-region string   split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type \nseqkit split -h\n for more examples\n  -s, --by-size int        split squences into multi parts with N sequences\n  -d, --dry-run            dry run, just print message and no files will be created.\n  -f, --force              overwrite output directory\n  -k, --keep-temp          keep tempory FASTA and .fai file when using 2-pass mode\n  -m, --md5                use MD5 instead of region sequence in output file when using flag -r (--by-region)\n  -O, --out-dir string     output directory (default value is infile.split)\n  -2, --two-pass           two-pass mode read files twice to lower memory usage. (only for FASTA format)\n\n\n\n\n\nExamples\n\n\n\n\n\n\nSplit sequences into parts with at most 10000 sequences\n\n\n$ seqkit split hairpin.fa.gz -s 10000\n[INFO] split into 10000 seqs per file\n[INFO] write 10000 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 10000 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 8645 sequences to file: hairpin.fa.part_003.gz\n\n\n\n\n\n\n\nSplit sequences into 4 parts\n\n\n$ seqkit split hairpin.fa.gz -p 4\n[INFO] split into 4 parts\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz\n[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz\n\n\n\nTo reduce memory usage when spliting big file, we should alwasy use flag \n--two-pass\n\n\n$ seqkit split hairpin.fa.gz -p 4 -2\n[INFO] split into 4 parts\n[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 28645 sequences loaded\n[INFO] write 7162 sequences to file: hairpin.part_001.fa.gz\n[INFO] write 7162 sequences to file: hairpin.part_002.fa.gz\n[INFO] write 7162 sequences to file: hairpin.part_003.fa.gz\n[INFO] write 7159 sequences to file: hairpin.part_004.fa.gz\n\n\n\n\n\n\n\nSplit sequences by species. i.e. by custom IDs (first three letters)\n\n\n$ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" -2\n[INFO] split by ID. idRegexp: ^([\\w]+)\\-\n[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...\n[INFO] create and read FASTA index ...\n[INFO] create FASTA index for hairpin.fa.gz.fa\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 28645 sequences loaded\n[INFO] write 48 sequences to file: hairpin.id_cca.fa.gz\n[INFO] write 3 sequences to file: hairpin.id_hci.fa.gz\n[INFO] write 106 sequences to file: hairpin.id_str.fa.gz\n[INFO] write 1 sequences to file: hairpin.id_bkv.fa.gz\n...\n\n\n\n\n\n\n\nSplit sequences by sequence region (for example, sequence barcode)\n\n\n$ seqkit split hairpin.fa.gz -r 1:3 -2\n[INFO] split by region: 1:3\n[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...\n[INFO] read sequence IDs and sequence region from FASTA file ...\n[INFO] create and read FASTA index ...\n[INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz\n[INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz\n[INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz\n\n\n\nIf region is too long, we could use falg \n--md5\n,\ni.e. use MD5 instead of region sequence in output file.\n\n\nSequence suffix could be defined as \n-r -12:-1\n\n\n\n\n\n\nsample\n\n\nUsage\n\n\nsample sequences by number or proportion.\n\nUsage:\n  seqkit sample [flags]\n\nFlags:\n  -n, --number int         sample by number (result may not exactly match)\n  -p, --proportion float   sample by proportion\n  -s, --rand-seed int      rand seed (default 11)\n  -2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin\n\n\n\n\n\nExamples\n\n\n\n\n\n\nSample by proportion\n\n\n$ zcat hairpin.fa.gz | seqkit sample -p 0.1 -o sample.fa.gz\n[INFO] sample by proportion\n[INFO] 2814 sequences outputed\n\n\n\n\n\n\n\nSample by number\n\n\n$ zcat hairpin.fa.gz | seqkit sample -n 1000 -o sample.fa.gz\n[INFO] sample by number\n[INFO] 949 sequences outputed\n\n\n\nTo reduce memory usage when spliting big file, we could use flag \n--two-pass\n\n\nWe can also use \nseqkit sample -p\n followed with \nseqkit head -n\n:\n\n\n$ zcat hairpin.fa.gz | seqkit sample -p 0.1 | seqkit head -n 1000 -o sample.fa.gz\n\n\n\n\n\n\n\nSet rand seed to reproduce the result\n\n\n$ zcat hairpin.fa.gz | seqkit sample -p 0.1 -s 11\n\n\n\n\n\n\n\nMost of the time, we could shuffle after sampling\n\n\n$ zcat hairpin.fa.gz | seqkit sample -p 0.1 | seqkit shuffle -o sample.fa.gz\n\n\n\n\n\n\n\nNote that when sampling on FASTQ files, make sure using same random seed by\nflag \n-s\n (\n--rand-seed\n)\n\n\nhead\n\n\nUsage\n\n\nprint first N FASTA/Q records\n\nUsage:\n  seqkit head [flags]\n\nFlags:\n  -n, --number int   print first N FASTA/Q records (default 10)\n\n\n\n\n\nExamples\n\n\n\n\n\n\nFASTA\n\n\n$ seqkit head -n 1 hairpin.fa.gz\n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC\nUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\n\n\n\n\n\n\n\nFASTQ\n\n\n$ seqkit head -n 1 reads_1.fq.gz\n@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG\nTGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGGTTGTAA\n+\nHIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIIIIIIIII\n\n\n\n\n\n\n\nreplace\n\n\nUsage\n\n\nreplace name/sequence by regular expression.\n\nNote that the replacement supports capture variables.\ne.g. $1 represents the text of the first submatch.\nATTENTION: use SINGLE quote NOT double quotes in *nix OS.\n\nExamples: Adding space to all bases.\n\n    seqkit replace -p \n(.)\n -r '$1 ' -s\n\nOr use the \\ escape character.\n\n    seqkit replace -p \n(.)\n -r \n\\$1 \n -s\n\nmore on: http://bioinf.shenwei.me/seqkit/usage/#replace\n\nSpecial replacement symbols (only for replacing name not sequence):\n\n        {nr}    Record number, starting from 1\n        {kv}    Corresponding value of the key (captured variable $n) by key-value file,\n                n can be specified by flag -I (--key-capt-idx) (default: 1)\n\nUsage:\n  seqkit replace [flags]\n\nFlags:\n  -s, --by-seq                 replace seq\n  -i, --ignore-case            ignore case\n  -K, --keep-key               keep the key as value when no value found for the key (only for sequence name)\n  -I, --key-capt-idx int       capture variable index of key (1-based) (default 1)\n      --key-miss-repl string   replacement for key with no corresponding value\n  -k, --kv-file string         tab-delimited key-value file for replacing key with value when using \n{kv}\n in -r (--replacement) (only for sequence name)\n  -p, --pattern string         search regular expression\n  -r, --replacement string     replacement. supporting capture variables.  e.g. $1 represents the text of the first submatch. ATTENTION: for *nix OS, use SINGLE quote NOT double quotes or use the \\ escape character. Record number is also supported by \n{nr}\n.use ${1} instead of $1 when {kv} given!\n\n\n\n\n\nExamples\n\n\n\n\n\n\nRemove descriptions\n\n\n$ echo -e \"\nseq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \" .+\"\n\nseq1\nACGT-ACGT\n\n\n\n\n\n\n\nReplace \"-\" with \"=\"\n\n\n$ echo -e \"\nseq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \"\\-\" -r '='\n\nseq1 abc=123\nACGT-ACGT\n\n\n\n\n\n\n\nRemove gaps in sequences.\n\n\n$ echo -e \"\nseq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \" |-\" -s\n\nseq1 abc-123\nACGTACGT\n\n\n\n\n\n\n\nAdd space to every base. \nATTENTION: use SINGLE quote NOT double quotes in *nix OS\n\n\n$ echo -e \"\nseq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \"(.)\" -r '$1 ' -s\n\nseq1 abc-123\nA C G T - A C G T\n\n\n\n\n\n\n\nTranspose sequence with \ncsvtk\n\n\n$ echo -e \"\nseq1\\nACTGACGT\\n\nseq2\\nactgccgt\" | seqkit replace -p \"(.)\" -r     \"\\$1 \" -s | seqkit seq -s -u | csvtk space2tab | csvtk -t transpose\nA       A\nC       C\nT       T\nG       G\nA       C\nC       C\nG       G\nT       T\n\n\n\n\n\n\n\nRename with number of record\n\n\necho -e \"\nabc\\nACTG\\n\n123\\nATTT\" |  seqkit replace -p .+ -r \"seq_{nr}\"\n\nseq_1\nACTG\n\nseq_2\nATTT\n\n\n\n\n\n\n\nReplace key with value by key-value file\n\n\n$ more test.fa\n\nseq1 name1\nCCCCAAAACCCCATGATCATGGATC\n\nseq2 name2\nCCCCAAAACCCCATGGCATCATTCA\n\nseq3 name3\nCCCCAAAACCCCATGTTGCTACTAG\n\n$ more alias.txt\nname0   ABC\nname1   123\nname3   Hello\nname4   World\n\n$ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa\n[INFO] read key-value file: alias.txt\n[INFO] 4 pairs of key-value loaded\n\nseq1 123\nCCCCAAAACCCCATGATCATGGATC\n\nseq2\nCCCCAAAACCCCATGGCATCATTCA\n\nseq3 Hello\nCCCCAAAACCCCATGTTGCTACTAG\n\n$ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa --keep-key\n[INFO] read key-value file: alias.txt\n[INFO] 4 pairs of key-value loaded\n\nseq1 123\nCCCCAAAACCCCATGATCATGGATC\n\nseq2 name2\nCCCCAAAACCCCATGGCATCATTCA\n\nseq3 Hello\nCCCCAAAACCCCATGTTGCTACTAG\n\n\n\n\n\n\n\nrename\n\n\nUsage\n\n\nrename duplicated IDs\n\nUsage:\n  seqkit rename [flags]\n\nFlags:\n  -n, --by-name   check duplicated by full name instead of just id\n\n\n\n\n\nExamples\n\n\n$ echo -e \na comment\\nacgt\\n\nb comment of b\\nACTG\\n\na comment\\naaaa\n  \n\na comment\nacgt\n\nb comment of b\nACTG\n\na comment\naaaa\n$ echo -e \na comment\\nacgt\\n\nb comment of b\\nACTG\\n\na comment\\naaaa\n | seqkit rename\n\na comment\nacgt\n\nb comment of b\nACTG\n\na_2 a comment\naaaa\n\n\n\n\nrestart\n\n\nUsage\n\n\nreset start position for circular genome\n\nExamples\n\n    $ echo -e \nseq\\nacgtnACGTN\n\n    \nseq\n    acgtnACGTN\n\n    $ echo -e \nseq\\nacgtnACGTN\n | seqkit restart -i 2\n    \nseq\n    cgtnACGTNa\n\n    $ echo -e \nseq\\nacgtnACGTN\n | seqkit restart -i -2\n    \nseq\n    TNacgtnACG\n\nUsage:\n  seqkit restart [flags]\n\nFlags:\n  -i, --new-start int   new start position (1-base, supporting negative value counting from the end) (default 1)\n\n\n\n\n\nshuffle\n\n\nUsage\n\n\nshuffle sequences.\n\nBy default, all records will be readed into memory.\nFor FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not\nsupported.\n\nFirstly, seqkit reads the sequence IDs. If the file is not plain FASTA file,\nseqkit will write the sequences to tempory files, and create FASTA index.\n\nSecondly, seqkit shuffles sequence IDs and extract sequences by FASTA index.\n\nUsage:\n  seqkit shuffle [flags]\n\nFlags:\n  -k, --keep-temp       keep tempory FASTA and .fai file when using 2-pass mode\n  -s, --rand-seed int   rand seed for shuffle (default 23)\n  -2, --two-pass        two-pass mode read files twice to lower memory usage. (only for FASTA format)\n\n\n\n\n\nExamples\n\n\n\n\n\n\nGeneral use.\n\n\n$ seqkit shuffle hairpin.fa.gz \n shuffled.fa\n[INFO] read sequences ...\n[INFO] 28645 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...\n\n\n\n\n\n\n\nFor big genome, you'd better use two-pass mode\n so seqkit could use\n   FASTA index to reduce memory usage\n\n\n$ time seqkit shuffle -2 hsa.fa \n shuffle.fa\n[INFO] create and read FASTA index ...\n[INFO] create FASTA index for hsa.fa\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...\n\nreal    0m35.080s\nuser    0m45.521s\nsys     0m3.411s\n\n\n\n\n\n\n\nNote that when sampling on FASTQ files, make sure using same random seed by\nflag \n-s\n (\n--rand-seed\n) for read 1 and 2 files.\n\n\nsort\n\n\nUsage\n\n\nsort sequences by id/name/sequence/length.\n\nBy default, all records will be readed into memory.\nFor FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not\nsupported.\n\nFirstly, seqkit reads the sequence head and length information.\nIf the file is not plain FASTA file,\nseqkit will write the sequences to tempory files, and create FASTA index.\n\nSecondly, seqkit sort sequence by head and length information\nand extract sequences by FASTA index.\n\nUsage:\n  seqkit sort [flags]\n\nFlags:\n  -l, --by-length               by sequence length\n  -n, --by-name                 by full name instead of just id\n  -s, --by-seq                  by sequence\n  -i, --ignore-case             ignore case\n  -k, --keep-temp               keep tempory FASTA and .fai file when using 2-pass mode\n  -r, --reverse                 reverse the result\n  -L, --seq-prefix-length int   length of sequence prefix on which seqkit sorts by sequences (0 for whole sequence) (default 10000)\n  -2, --two-pass                two-pass mode read files twice to lower memory usage. (only for FASTA format)\n\n\n\n\n\nExamples\n\n\nFor FASTA format, use flag -2 (--two-pass) to reduce memory usage\n\n\n\n\n\n\nsort by ID\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAA\" | seqkit sort --quiet\n\nSEQ2\nacgtnAAAA\n\nseq1\nACGTNcccc\n\n\n\n\n\n\n\nsort by ID, ignoring case.\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAA\" | seqkit sort --quiet -i\n\nseq1\nACGTNcccc\n\nSEQ2\nacgtnAAAA\n\n\n\n\n\n\n\nsort by seq, ignoring case.\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAA\" | seqkit sort --quiet -s -i\n\nSEQ2\nacgtnAAAA\n\nseq1\nACGTNcccc\n\n\n\n\n\n\n\nsort by sequence length\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAAnnn\\n\nseq3\\nacgt\" | seqkit sort --quiet -l\n\nseq3\nacgt\n\nseq1\nACGTNcccc\n\nSEQ2\nacgtnAAAAnnn\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n\n\n\n\nPlease enable JavaScript to view the \ncomments powered by Disqus.", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage-and-examples", 
            "text": "", 
            "title": "Usage and Examples"
        }, 
        {
            "location": "/usage/#table-of-contents", 
            "text": "Technical details and guides for use  seqkit   Sequence and subsequence   seq  subseq  sliding  stats   Format conversion   fq2fa  fx2tab   tab2fx   Searching   grep  locate   Set operations   rmdup  common  split  sample  head   Edit   replace  rename  restart   Ordering   shuffle  sort", 
            "title": "Table of Contents"
        }, 
        {
            "location": "/usage/#technical-details-and-guides-for-use", 
            "text": "", 
            "title": "Technical details and guides for use"
        }, 
        {
            "location": "/usage/#fastaq-format-parsing", 
            "text": "SeqKit uses author's lightweight and high-performance bioinformatics packages bio  for FASTA/Q parsing,\nwhich has  high performance \nclose to the\nfamous C lib  klib  ( kseq.h ).", 
            "title": "FASTA/Q format parsing"
        }, 
        {
            "location": "/usage/#sequence-formats-and-types", 
            "text": "SeqKit seamlessly support FASTA and FASTQ format.\nSequence format is automatically detected.\nAll subcommands except for  faidx  can handle both formats.\nAnd only when some commands ( subseq ,  split ,  sort  and  shuffle )\nwhich utilise FASTA index to improve perfrmance for large files in two pass mode\n(by flag  --two-pass ), only FASTA format is supported.  Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences\nof the first sequences in file or STDIN. The length of the leading subsequences\nis configurable by global flag  --alphabet-guess-seq-length  with default value\nof 10000. If length of the sequences is less than that, whole sequences will\nbe checked.", 
            "title": "Sequence formats and types"
        }, 
        {
            "location": "/usage/#sequence-id", 
            "text": "By default, most softwares, including  seqkit , take the leading non-space\nletters as sequence identifier (ID). For example,     FASTA header  ID      123456 gene name  123456    longname  longname    gi 110645304 ref NC_002516.2  Pseudomona  gi 110645304 ref NC_002516.2     But for some sequences from NCBI,\ne.g.  gi|110645304|ref|NC_002516.2| Pseudomona , the ID is  NC_002516.2 .\nIn this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \"  or just use flag  --id-ncbi . If you want\nthe  gi  number, then use  --id-regexp \"^gi\\|([^\\|]+)\\|\" .", 
            "title": "Sequence ID"
        }, 
        {
            "location": "/usage/#fasta-index", 
            "text": "For some commands, including  subseq ,  split ,  sort  and  shuffle ,\nwhen input files are (plain or gzipped) FASTA files,\nFASTA index would be optional used for\nrapid access of sequences and reducing memory occupation.  ATTENTION: the  .seqkit.fai  file created by SeqKit is a little different from  .fai  file\ncreated by  samtools . SeqKit uses full sequence head instead of just ID as key.", 
            "title": "FASTA index"
        }, 
        {
            "location": "/usage/#parallelization-of-cpu-intensive-jobs", 
            "text": "The validation of sequences bases and complement process of sequences\nare parallelized for large sequences.  Parsing of line-based files, including BED/GFF file and ID list file are also parallelized.  The Parallelization is implemented by multiple goroutines in golang\n which are similar to but much\nlighter weight than threads. The concurrency number is configurable with global\nflag  -j  or  --threads  (default value: 1 for single-CPU PC, 2 for others).", 
            "title": "Parallelization of CPU intensive jobs"
        }, 
        {
            "location": "/usage/#memory-occupation", 
            "text": "Most of the subcommands do not read whole FASTA/Q records in to memory,\nincluding  stat ,  fq2fa ,  fx2tab ,  tab2fx ,  grep ,  locate ,  replace ,\n  seq ,  sliding ,  subseq .  Note that when using  subseq --gtf | --bed , if the GTF/BED files are too\nbig, the memory usage will increase.\nYou could use  --chr  to specify chromesomes and  --feature  to limit features.  Some subcommands need to store sequences or heads in memory, but there are\nstrategy to reduce memory occupation, including  rmdup  and  common .\nWhen comparing with sequences, MD5 digest could be used to replace sequence by\nflag  -m  ( --md5 ).  Some subcommands could either read all records or read the files twice by flag -2  ( --two-pass ), including  sample ,  split ,  shuffle  and  sort .\nThey use FASTA index for rapid acccess of sequences and reducing memory occupation.", 
            "title": "Memory occupation"
        }, 
        {
            "location": "/usage/#reproducibility", 
            "text": "Subcommands  sample  and  shuffle  use random function, random seed could be\ngiven by flag  -s  ( --rand-seed ). This makes sure that sampling result could be\nreproduced in different environments with same random seed.", 
            "title": "Reproducibility"
        }, 
        {
            "location": "/usage/#seqkit", 
            "text": "Usage  SeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation\n\nVersion: 0.5.0\n\nAuthor: Wei Shen  shenwei356@gmail.com \n\nDocuments  : http://bioinf.shenwei.me/seqkit\nSource code: https://github.com/shenwei356/seqkit\nPlease cite: https://doi.org/10.1371/journal.pone.0163962\n\nUsage:\n  seqkit [command]\n\nAvailable Commands:\n  common      find common sequences of multiple files by id/name/sequence\n  faidx       create FASTA index file\n  fq2fa       covert FASTQ to FASTA\n  fx2tab      covert FASTA/Q to tabular format (with length/GC content/GC skew)\n  grep        search sequences by pattern(s) of name or sequence motifs\n  head        print first N FASTA/Q records\n  help        Help about any command\n  locate      locate subsequences/motifs\n  rename      rename duplicated IDs\n  replace     replace name/sequence by regular expression\n  restart     reset start position for circular genome\n  rmdup       remove duplicated sequences by id/name/sequence\n  sample      sample sequences by number or proportion\n  seq         transform sequences (revserse, complement, extract ID...)\n  shuffle     shuffle sequences\n  sliding     sliding sequences, circular genome supported\n  sort        sort sequences by id/name/sequence/length\n  split       split sequences into files by id/seq region/size/parts\n  stats       simple statistics of FASTA files\n  subseq      get subsequences by region/gtf/bed, including flanking sequences\n  tab2fx      covert tabular format to FASTA/Q format\n  version     print version information and check for update\n\nFlags:\n      --alphabet-guess-seq-length int   length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000)\n      --id-ncbi                         FASTA head is NCBI-style, e.g.  gi|110645304|ref|NC_002516.2| Pseud...\n      --id-regexp string                regular expression for parsing ID (default  ^([^\\s]+)\\s? )\n  -w, --line-width int                  line width when outputing FASTA format (0 for no wrap) (default 60)\n  -o, --out-file string                 out file ( -  for stdout, suffix .gz for gzipped out) (default  - )\n      --quiet                           be quiet and do not show extra information\n  -t, --seq-type string                 sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default  auto )\n  -j, --threads int                     number of CPUs. (default value: 1 for single-CPU PC, 2 for others) (default 2)\n\nUse  seqkit [command] --help  for more information about a command.", 
            "title": "seqkit"
        }, 
        {
            "location": "/usage/#datasets", 
            "text": "Datasets from  The miRBase Sequence Database -- Release 21   hairpin.fa.gz  mature.fa.gz  miRNA.diff.gz   Human genome from  ensembl \n(For  seqkit subseq )   Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz  Homo_sapiens.GRCh38.84.gtf.gz  Homo_sapiens.GRCh38.84.bed.gz  is converted from  Homo_sapiens.GRCh38.84.gtf.gz \nby  gtf2bed \nwith command zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c   Homo_sapiens.GRCh38.84.bed.gz    Only DNA and gtf/bed data of Chr1 were used:    chr1.fa.gz  seqkit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz    chr1.gtf.gz  zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c   chr1.gtf.gz    chr1.bed.gz  zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c   chr1.bed.gz", 
            "title": "Datasets"
        }, 
        {
            "location": "/usage/#seq", 
            "text": "Usage  transform sequences (revserse, complement, extract ID...)\n\nUsage:\n  seqkit seq [flags]\n\nFlags:\n  -p, --complement                complement sequence (blank for Protein sequence)\n      --dna2rna                   DNA to RNA\n  -G, --gap-letter string         gap letters (default  -  )\n  -l, --lower-case                print sequences in lower case\n  -n, --name                      only print names\n  -i, --only-id                   print ID instead of full head\n  -q, --qual                      only print qualities\n  -g, --remove-gaps               remove gaps\n  -r, --reverse                   reverse sequence\n      --rna2dna                   RNA to DNA\n  -s, --seq                       only print sequences\n  -u, --upper-case                print sequences in upper case\n  -v, --validate-seq              validate bases according to the alphabet\n  -V, --validate-seq-length int   length of sequence to validate (0 for whole seq) (default 10000)  Examples    Read and print    From file:  $ seqkit seq hairpin.fa.gz cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC\nUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\n\n$ seqkit seq read_1.fq.gz\n@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG\nTGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG\n+\nHIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII    From stdin:  zcat hairpin.fa.gz | seqkit seq      Sequence types    By default,  seqkit seq  automatically detect the sequence type  $ echo -e \" seq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | seqkit stats\nfile  format  type  num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTA   DNA          1       28       28       28       28\n\n$ echo -e \" seq\\nACGUN ACGUN\" | seqkit stats\nfile  format  type  num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTA   RNA          1       11       11       11       11\n\n$ echo -e \" seq\\nabcdefghijklmnpqrstvwyz\" | seqkit stats\nfile  format  type     num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTA   Protein         1       23       23       23       23\n\n$ echo -e \"@read\\nACTGCN\\n+\\n@IICCG\" | seqkit stats\nfile  format  type  num_seqs  sum_len  min_len  avg_len  max_len\n-     FASTQ   DNA          1        6        6        6        6    You can also set sequence type by flag  -t  ( --seq-type ).\n  But this only take effect on subcommands  seq  and  locate .  $ echo -e \" seq\\nabcdefghijklmnpqrstvwyz\" | seqkit seq -t dna\n[INFO] when flag -t (--seq-type) given, flag -v (--validate-seq) is automatically switched on\n[ERRO] error when parsing seq: seq (invalid DNAredundant letter: e)      Only print names    Full name:  $ seqkit seq hairpin.fa.gz -n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop    Only ID:  $ seqkit seq hairpin.fa.gz -n -i\ncel-let-7\ncel-lin-4\ncel-mir-1    Custom ID region by regular expression (this could be applied to all subcommands):  $ seqkit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\"\nMI0000001\nMI0000002\nMI0000003      Only print seq (global flag  -w  defines the output line width, 0 for no wrap)  $ seqkit seq hairpin.fa.gz -s -w 0\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\nAUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU\nAAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU    Convert multi-line FASTQ to 4-line FASTQ  $ seqkit seq reads_1.fq.gz -w 0    Reverse comlement sequence  $ seqkit seq hairpin.fa.gz -r -p cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC\nAAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA    Remove gaps and to lower/upper case  $ echo -e \" seq\\nACGT-ACTGC-ACC\" | seqkit seq -g -u seq\nACGTACTGCACC    RNA to DNA  $ echo -e \" seq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | seqkit seq --rna2dna seq\nTCATATGCTTGTCTCAAAGATTA    Filter by sequence length  $ cat hairpin.fa | seqkit seq | seqkit stats\nfile  format  type  num_seqs    sum_len  min_len  avg_len  max_len\n-     FASTA   RNA     28,645  2,949,871       39      103    2,354\n\n$ cat hairpin.fa | seqkit seq -m 100 | seqkit stats\nfile  format  type  num_seqs    sum_len  min_len  avg_len  max_len\n-     FASTA   RNA     10,975  1,565,486      100    142.6    2,354\n\n$ cat hairpin.fa | seqkit seq -m 100 -M 1000 | seqkit stats\nfile  format  type  num_seqs    sum_len  min_len  avg_len  max_len\n-     FASTA   RNA     10,972  1,560,270      100    142.2      938", 
            "title": "seq"
        }, 
        {
            "location": "/usage/#subseq", 
            "text": "Usage  get subsequences by region/gtf/bed, including flanking sequences.\n\nRecommendation: use plain FASTA file, so seqkit could utilize FASTA index.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n          1:12    A C G T N a c g t n\n        -12:-1    A C G T N a c g t n\n\nUsage:\n  seqkit subseq [flags]\n\nFlags:\n      --bed string        by BED file\n      --chr value         select limited sequence with sequence IDs (multiple value supported, case ignored) (default [])\n  -d, --down-stream int   down stream length\n      --feature value     select limited feature types (multiple value supported, case ignored, only works with GTF) (default [])\n      --gtf string        by GTF (version 2.2) file\n  -f, --only-flank        only return up/down stream sequence\n  -r, --region string     by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type  seqkit subseq -h  for more examples\n  -u, --up-stream int     up stream length  Examples  Recommendation: use plain FASTA file, so seqkit could utilize FASTA index.    First 12 bases  $ zcat hairpin.fa.gz | seqkit subseq -r 1:12    Last 12 bases  $ zcat hairpin.fa.gz | seqkit subseq -r -12:-1    Subsequences without first and last 12 bases  $ zcat hairpin.fa.gz | seqkit subseq -r 13:-13    Get subsequence by GTF file  $ cat t.fa seq\nactgACTGactgn\n\n$ cat t.gtf\nseq     test    CDS     5       8       .       .       .       gene_id \"A\"; transcript_id \"\";\nseq     test    CDS     5       8       .       -       .       gene_id \"B\"; transcript_id \"\";\n\n$ seqkit subseq --gtf t.gtf t.fa seq_5:8:. A\nACTG seq_5:8:- B\nCAGT  Human genome example:  AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz,\nthe uncompressed data are so big and may exhaust your RAM.  We could specify chromesomes and features.  $ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds  hsa.fa   chr1.gtf.cds.fa\n\n$ seqkit stats chr1.gtf.cds.fa\nfile             format  type  num_seqs    sum_len  min_len  avg_len  max_len\nchr1.gtf.cds.fa  FASTA   DNA     65,012  9,842,274        1    151.4   12,045    Get CDS and 3bp up-stream sequences  $ seqkit subseq --gtf t.gtf t.fa -u 3 seq_5:8:._us:3 A\nctgACTG seq_5:8:-_us:3 B\nagtCAGT    Get 3bp up-stream sequences of CDS, not including CDS  $ seqkit subseq --gtf t.gtf t.fa -u 3 -f seq_5:8:._usf:3 A\nctg seq_5:8:-_usf:3 B\nagt    Get subsequences by BED file.  AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz,\nthe uncompressed data are so big and may exhaust your RAM.  $  seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa    chr1.bed.gz.fa  We may need to remove duplicated sequences  $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa | seqkit rmdup   chr1.bed.rmdup.fa\n[INFO] 141060 duplicated records removed  Summary:  $ seqkit stats chr1.gz.*.gz\nfile               seq_format   seq_type   num_seqs   min_len   avg_len     max_len\nchr1.gz.fa         FASTA        DNA         231,974         1   3,089.5   1,551,957\nchr1.gz.rmdup.fa   FASTA        DNA          90,914         1   6,455.8   1,551,957", 
            "title": "subseq"
        }, 
        {
            "location": "/usage/#sliding", 
            "text": "Usage  sliding sequences, circular genome supported\n\nUsage:\n  seqkit sliding [flags]\n\nFlags:\n  -C, --circular-genome   circular genome.\n  -g, --greedy            greedy mode, i.e., exporting last subsequences even shorter than windows size\n  -s, --step int          step size\n  -W, --window int        window size  Examples    General use  $ echo -e \" seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 seq_sliding:1-6\nACGTac seq_sliding:4-9\nTacgtN    Greedy mode  $ echo -e \" seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -g seq_sliding:1-6\nACGTac seq_sliding:4-9\nTacgtN seq_sliding:7-12\ngtNN seq_sliding:10-15\nN    Circular genome  $ echo -e \" seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -C seq_sliding:1-6\nACGTac seq_sliding:4-9\nTacgtN seq_sliding:7-2\ngtNNAC seq_sliding:10-5\nNACGTa    Generate GC content for ploting  $ zcat hairpin.fa.gz | seqkit fx2tab | head -n 1 | seqkit tab2fx | seqkit sliding -s 5 -W 30 | seqkit fx2tab -n -g\ncel-let-7_sliding:1-30          50.00\ncel-let-7_sliding:6-35          46.67\ncel-let-7_sliding:11-40         43.33\ncel-let-7_sliding:16-45         36.67\ncel-let-7_sliding:21-50         33.33\ncel-let-7_sliding:26-55         40.00\n...", 
            "title": "sliding"
        }, 
        {
            "location": "/usage/#stats", 
            "text": "Usage  simple statistics of FASTA files\n\nUsage:\n  seqkit stats [flags]\n\nAliases:\n  stats, stat\n\n\nFlags:\n  -a, --all                  all statistics, including sum_gap, N50, L50\n  -G, --gap-letters string   gap letters (default  -  )  Eexamples    General use  $ seqkit stats *.f{a,q}.gz\nfile           format  type  num_seqs    sum_len  min_len  avg_len  max_len\nhairpin.fa.gz  FASTA   RNA     28,645  2,949,871       39      103    2,354\nmature.fa.gz   FASTA   RNA     35,828    781,222       15     21.8       34\nreads_1.fq.gz  FASTQ   DNA      2,500    567,516      226      227      229\nreads_2.fq.gz  FASTQ   DNA      2,500    560,002      223      224      225    Extra information  $ seqkit stats *.f{a,q}.gz -a\nfile           format  type  num_seqs    sum_len  min_len  avg_len  max_len  sum_gap  N50     L50\nhairpin.fa.gz  FASTA   RNA     28,645  2,949,871       39      103    2,354        0  101  10,075\nmature.fa.gz   FASTA   RNA     35,828    781,222       15     21.8       34        0   22  17,144\nreads_1.fq.gz  FASTQ   DNA      2,500    567,516      226      227      229        0  227   1,250\nreads_2.fq.gz  FASTQ   DNA      2,500    560,002      223      224      225        0  224   1,250", 
            "title": "stats"
        }, 
        {
            "location": "/usage/#fq2fa", 
            "text": "Usage  covert FASTQ to FASTA\n\nUsage:\n  seqkit fq2fa [flags]  Examples  seqkit fq2fa reads_1.fq.gz -o reads1_.fa.gz", 
            "title": "fq2fa"
        }, 
        {
            "location": "/usage/#fx2tab-tab2fx", 
            "text": "Usage (fx2tab)  covert FASTA/Q to tabular format, and provide various information,\nlike sequence length, GC content/GC skew.\n\nUsage:\n  seqkit fx2tab [flags]\n\nFlags:\n  -B, --base-content value   print base content. (case ignored, multiple values supported) e.g. -B AT -B N (default [])\n  -g, --gc                   print GC content\n  -G, --gc-skew              print GC-Skew\n  -H, --header-line          print header line\n  -l, --length               print sequence length\n  -n, --name                 only print names (no sequences and qualities)\n  -i, --only-id              print ID instead of full head  Usage (tab2fx)  covert tabular format (first two/three columns) to FASTA/Q format\n\nUsage:\n  seqkit tab2fx [flags]\n\nFlags:\n  -p, --comment-line-prefix value   comment line prefix (default [#,//])  Examples    Default output  $ seqkit fx2tab hairpin.fa.gz | head -n 2\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop      UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU    Print sequence length, GC content, and only print names (no sequences),\nwe could also print title line by flag  -T .  $ seqkit fx2tab hairpin.fa.gz -l -g -n -i -H | head -n 4 | csvtk -t -C ' ' pretty\n#name       seq   qual   length   GC\ncel-let-7                99       43.43\ncel-lin-4                94       54.26\ncel-mir-1                96       40.62    Use fx2tab and tab2fx in pipe  $ zcat hairpin.fa.gz | seqkit fx2tab | seqkit tab2fx\n\n$ zcat reads_1.fq.gz | seqkit fx2tab | seqkit tab2fx    Sort sequences by length (use  seqkit sort -l )  $ zcat hairpin.fa.gz | seqkit fx2tab -l | sort -t\"`echo -e '\\t'`\" -n -k4,4 | seqkit tab2fx cin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop\nUUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC mmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop\nUGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU cin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop\nACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU\n\n$ seqkit sort -l hairpin.fa.gz  Sorting or filtering by GC (or other base by -flag  -B ) content could also achieved in similar way.    Get first 1000 sequences (use  seqkit head -n 1000 )  $ seqkit fx2tab hairpin.fa.gz | head -n 1000 | seqkit tab2fx\n\n$ seqkit fx2tab reads_1.fq.gz | head -n 1000 | seqkit tab2fx    Extension  After converting FASTA to tabular format with  seqkit fx2tab ,\nit could be handled with CSV/TSV tools,\n e.g.  csvtk , a cross-platform, efficient and practical CSV/TSV toolkit   csvtk grep  could be used to filter sequences (similar with  seqkit grep )  csvtk inter \ncomputates intersection of multiple files. It could achieve similar function\nas  seqkit common -n  along with shell.  csvtk join  joins multiple CSV/TSV files by multiple IDs.  csv_melt \nprovides melt function, could be used in preparation of data for ploting.", 
            "title": "fx2tab &amp; tab2fx"
        }, 
        {
            "location": "/usage/#grep", 
            "text": "Usage  search sequences by pattern(s) of name or sequence motifs\n\nYou can specify the sequence region for searching with flag -R/--region.\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n          1:12    A C G T N a c g t n\n        -12:-1    A C G T N a c g t n\n\nUsage:\n  seqkit grep [flags]\n\nFlags:\n  -n, --by-name               match by full name instead of just id\n  -s, --by-seq                match by seq\n  -d, --degenerate            pattern/motif contains degenerate base\n      --delete-matched        delete matched pattern to speedup\n  -i, --ignore-case           ignore case\n  -v, --invert-match          invert the sense of matching, to select non-matching records\n  -p, --pattern stringSlice   search pattern (multiple values supported)\n  -f, --pattern-file string   pattern file\n  -R, --region string         specify sequence region for searching. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases\n  -r, --use-regexp            patterns are regular expression  Examples    Extract human hairpins (i.e. sequences with name starting with  hsa )  $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop\nUGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU\nACAAUCUACUGUCUUUCCUA hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop\nAGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU\nCCUAGCUUUCCU    Remove human and mice hairpins.  $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v    Extract new entries by information from miRNA.diff.gz    Get IDs of new entries.  $ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2   list\n$ more list\ncfa-mir-486\ncfa-mir-339-1\npmi-let-7    Extract by ID list file  $ zcat hairpin.fa.gz | seqkit grep -f list   new.fa      Extract sequences starting with AGGCG  $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg    Extract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G.  $ zcat hairpin.fa.gz | seqkit grep -s -d -i -p TTSAA  It's equal to but simpler than:  $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p TT[CG]AA    Specify sequence regions for searching. e.g., leading 30 bases.  $ seqkit grep -s -R 1:30 -i -r -p GCTGG", 
            "title": "grep"
        }, 
        {
            "location": "/usage/#locate", 
            "text": "Usage  locate subsequences/motifs\n\nMotifs could be EITHER plain sequence containing  ACTGN  OR regular\nexpression like  A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)  for ORFs.\nDegenerate bases like  RYMM..  are also supported by flag -d.\n\nBy default, motifs are treated as regular expression.\nWhen flag -d given, regular expression may be wrong.\nFor example:  \\w  will be wrongly converted to  \\[AT] .\n\nUsage:\n  seqkit locate [flags]\n\nFlags:\n  -d, --degenerate                pattern/motif contains degenerate base\n  -i, --ignore-case               ignore case\n  -P, --only-positive-strand      only search on positive strand\n  -p, --pattern stringSlice       pattern/motif (multiple values supported. use double quotation marks for patterns containing comma, e.g., -p ' A{2,} ')\n  -f, --pattern-file string       pattern/motif file (FASTA format)\n  -V, --validate-seq-length int   length of sequence to validate (0 for whole seq) (default 10000)  Examples    Locate ORFs.  $ zcat hairpin.fa.gz | seqkit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\"\nseqID   patternName     pattern strand  start   end     matched\ncel-lin-4       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  136      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  54       95      AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        -  43       51      AUGAUAUAG    Locate Motif.  $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN\nseqID         patternName   pattern    strand   start   end   matched\ncel-mir-58a   AUGGACUN      AUGGACUN   +        81      88    AUGGACUG\nath-MIR163    AUGGACUN      AUGGACUN   -        122     129   AUGGACUC  Notice that  seqkit grep  only searches in positive strand, but  seqkit loate  could recognize both strand", 
            "title": "locate"
        }, 
        {
            "location": "/usage/#rmdup", 
            "text": "Usage  remove duplicated sequences by id/name/sequence\n\nUsage:\n  seqkit rmdup [flags]\n\nFlags:\n    -n, --by-name                by full name instead of just id\n    -s, --by-seq                 by seq\n    -D, --dup-num-file string    file to save number and list of duplicated seqs\n    -d, --dup-seqs-file string   file to save duplicated seqs\n    -i, --ignore-case            ignore case\n    -m, --md5                    use MD5 instead of original seqs to reduce memory usage when comparing by seqs  Examples  Similar to  common .    General use  $ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz\n[INFO] 2226 duplicated records removed\n\n$ zcat reads_1.fq.gz | seqkit rmdup -s -o clean.fa.gz\n[INFO] 1086 duplicated records removed    Save duplicated sequences to file  $ zcat hairpin.fa.gz | seqkit rmdup -s -i -m -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ cat duplicated.detail.txt   # here is not the entire list\n3   hsa-mir-424, mml-mir-424, ppy-mir-424\n3   hsa-mir-342, mml-mir-342, ppy-mir-342\n2   ngi-mir-932, nlo-mir-932\n2   ssc-mir-9784-1, ssc-mir-9784-2", 
            "title": "rmdup"
        }, 
        {
            "location": "/usage/#common", 
            "text": "Usage  find common sequences of multiple files by id/name/sequence\n\nUsage:\n  seqkit common [flags]\n\nFlags:\n    -n, --by-name       match by full name instead of just id\n    -s, --by-seq        match by sequence\n    -i, --ignore-case   ignore case\n    -m, --md5           use MD5 instead of original seqs to reduce memory usage when comparing by seqs  Examples    By ID (default)  seqkit common file*.fa -o common.fasta    By full name  seqkit common file*.fa -n -o common.fasta    By sequence  seqkit common file*.fa -s -i -o common.fasta    By sequence ( for large sequences )  seqkit common file*.fa -s -i -o common.fasta --md5", 
            "title": "common"
        }, 
        {
            "location": "/usage/#split", 
            "text": "Usage  split sequences into files by name ID, subsequence of given region,\npart size or number of parts.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n          1:12    A C G T N a c g t n\n        -12:-1    A C G T N a c g t n\n\nUsage:\n  seqkit split [flags]\n\nFlags:\nFlags:\n  -i, --by-id              split squences according to sequence ID\n  -p, --by-part int        split squences into N parts\n  -r, --by-region string   split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type  seqkit split -h  for more examples\n  -s, --by-size int        split squences into multi parts with N sequences\n  -d, --dry-run            dry run, just print message and no files will be created.\n  -f, --force              overwrite output directory\n  -k, --keep-temp          keep tempory FASTA and .fai file when using 2-pass mode\n  -m, --md5                use MD5 instead of region sequence in output file when using flag -r (--by-region)\n  -O, --out-dir string     output directory (default value is infile.split)\n  -2, --two-pass           two-pass mode read files twice to lower memory usage. (only for FASTA format)  Examples    Split sequences into parts with at most 10000 sequences  $ seqkit split hairpin.fa.gz -s 10000\n[INFO] split into 10000 seqs per file\n[INFO] write 10000 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 10000 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 8645 sequences to file: hairpin.fa.part_003.gz    Split sequences into 4 parts  $ seqkit split hairpin.fa.gz -p 4\n[INFO] split into 4 parts\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz\n[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz  To reduce memory usage when spliting big file, we should alwasy use flag  --two-pass  $ seqkit split hairpin.fa.gz -p 4 -2\n[INFO] split into 4 parts\n[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 28645 sequences loaded\n[INFO] write 7162 sequences to file: hairpin.part_001.fa.gz\n[INFO] write 7162 sequences to file: hairpin.part_002.fa.gz\n[INFO] write 7162 sequences to file: hairpin.part_003.fa.gz\n[INFO] write 7159 sequences to file: hairpin.part_004.fa.gz    Split sequences by species. i.e. by custom IDs (first three letters)  $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" -2\n[INFO] split by ID. idRegexp: ^([\\w]+)\\-\n[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...\n[INFO] create and read FASTA index ...\n[INFO] create FASTA index for hairpin.fa.gz.fa\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 28645 sequences loaded\n[INFO] write 48 sequences to file: hairpin.id_cca.fa.gz\n[INFO] write 3 sequences to file: hairpin.id_hci.fa.gz\n[INFO] write 106 sequences to file: hairpin.id_str.fa.gz\n[INFO] write 1 sequences to file: hairpin.id_bkv.fa.gz\n...    Split sequences by sequence region (for example, sequence barcode)  $ seqkit split hairpin.fa.gz -r 1:3 -2\n[INFO] split by region: 1:3\n[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...\n[INFO] read sequence IDs and sequence region from FASTA file ...\n[INFO] create and read FASTA index ...\n[INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz\n[INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz\n[INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz  If region is too long, we could use falg  --md5 ,\ni.e. use MD5 instead of region sequence in output file.  Sequence suffix could be defined as  -r -12:-1", 
            "title": "split"
        }, 
        {
            "location": "/usage/#sample", 
            "text": "Usage  sample sequences by number or proportion.\n\nUsage:\n  seqkit sample [flags]\n\nFlags:\n  -n, --number int         sample by number (result may not exactly match)\n  -p, --proportion float   sample by proportion\n  -s, --rand-seed int      rand seed (default 11)\n  -2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin  Examples    Sample by proportion  $ zcat hairpin.fa.gz | seqkit sample -p 0.1 -o sample.fa.gz\n[INFO] sample by proportion\n[INFO] 2814 sequences outputed    Sample by number  $ zcat hairpin.fa.gz | seqkit sample -n 1000 -o sample.fa.gz\n[INFO] sample by number\n[INFO] 949 sequences outputed  To reduce memory usage when spliting big file, we could use flag  --two-pass  We can also use  seqkit sample -p  followed with  seqkit head -n :  $ zcat hairpin.fa.gz | seqkit sample -p 0.1 | seqkit head -n 1000 -o sample.fa.gz    Set rand seed to reproduce the result  $ zcat hairpin.fa.gz | seqkit sample -p 0.1 -s 11    Most of the time, we could shuffle after sampling  $ zcat hairpin.fa.gz | seqkit sample -p 0.1 | seqkit shuffle -o sample.fa.gz    Note that when sampling on FASTQ files, make sure using same random seed by\nflag  -s  ( --rand-seed )", 
            "title": "sample"
        }, 
        {
            "location": "/usage/#head", 
            "text": "Usage  print first N FASTA/Q records\n\nUsage:\n  seqkit head [flags]\n\nFlags:\n  -n, --number int   print first N FASTA/Q records (default 10)  Examples    FASTA  $ seqkit head -n 1 hairpin.fa.gz cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC\nUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA    FASTQ  $ seqkit head -n 1 reads_1.fq.gz\n@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG\nTGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGGTTGTAA\n+\nHIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIIIIIIIII", 
            "title": "head"
        }, 
        {
            "location": "/usage/#replace", 
            "text": "Usage  replace name/sequence by regular expression.\n\nNote that the replacement supports capture variables.\ne.g. $1 represents the text of the first submatch.\nATTENTION: use SINGLE quote NOT double quotes in *nix OS.\n\nExamples: Adding space to all bases.\n\n    seqkit replace -p  (.)  -r '$1 ' -s\n\nOr use the \\ escape character.\n\n    seqkit replace -p  (.)  -r  \\$1   -s\n\nmore on: http://bioinf.shenwei.me/seqkit/usage/#replace\n\nSpecial replacement symbols (only for replacing name not sequence):\n\n        {nr}    Record number, starting from 1\n        {kv}    Corresponding value of the key (captured variable $n) by key-value file,\n                n can be specified by flag -I (--key-capt-idx) (default: 1)\n\nUsage:\n  seqkit replace [flags]\n\nFlags:\n  -s, --by-seq                 replace seq\n  -i, --ignore-case            ignore case\n  -K, --keep-key               keep the key as value when no value found for the key (only for sequence name)\n  -I, --key-capt-idx int       capture variable index of key (1-based) (default 1)\n      --key-miss-repl string   replacement for key with no corresponding value\n  -k, --kv-file string         tab-delimited key-value file for replacing key with value when using  {kv}  in -r (--replacement) (only for sequence name)\n  -p, --pattern string         search regular expression\n  -r, --replacement string     replacement. supporting capture variables.  e.g. $1 represents the text of the first submatch. ATTENTION: for *nix OS, use SINGLE quote NOT double quotes or use the \\ escape character. Record number is also supported by  {nr} .use ${1} instead of $1 when {kv} given!  Examples    Remove descriptions  $ echo -e \" seq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \" .+\" seq1\nACGT-ACGT    Replace \"-\" with \"=\"  $ echo -e \" seq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \"\\-\" -r '=' seq1 abc=123\nACGT-ACGT    Remove gaps in sequences.  $ echo -e \" seq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \" |-\" -s seq1 abc-123\nACGTACGT    Add space to every base.  ATTENTION: use SINGLE quote NOT double quotes in *nix OS  $ echo -e \" seq1 abc-123\\nACGT-ACGT\" | seqkit replace -p \"(.)\" -r '$1 ' -s seq1 abc-123\nA C G T - A C G T    Transpose sequence with  csvtk  $ echo -e \" seq1\\nACTGACGT\\n seq2\\nactgccgt\" | seqkit replace -p \"(.)\" -r     \"\\$1 \" -s | seqkit seq -s -u | csvtk space2tab | csvtk -t transpose\nA       A\nC       C\nT       T\nG       G\nA       C\nC       C\nG       G\nT       T    Rename with number of record  echo -e \" abc\\nACTG\\n 123\\nATTT\" |  seqkit replace -p .+ -r \"seq_{nr}\" seq_1\nACTG seq_2\nATTT    Replace key with value by key-value file  $ more test.fa seq1 name1\nCCCCAAAACCCCATGATCATGGATC seq2 name2\nCCCCAAAACCCCATGGCATCATTCA seq3 name3\nCCCCAAAACCCCATGTTGCTACTAG\n\n$ more alias.txt\nname0   ABC\nname1   123\nname3   Hello\nname4   World\n\n$ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa\n[INFO] read key-value file: alias.txt\n[INFO] 4 pairs of key-value loaded seq1 123\nCCCCAAAACCCCATGATCATGGATC seq2\nCCCCAAAACCCCATGGCATCATTCA seq3 Hello\nCCCCAAAACCCCATGTTGCTACTAG\n\n$ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa --keep-key\n[INFO] read key-value file: alias.txt\n[INFO] 4 pairs of key-value loaded seq1 123\nCCCCAAAACCCCATGATCATGGATC seq2 name2\nCCCCAAAACCCCATGGCATCATTCA seq3 Hello\nCCCCAAAACCCCATGTTGCTACTAG", 
            "title": "replace"
        }, 
        {
            "location": "/usage/#rename", 
            "text": "Usage  rename duplicated IDs\n\nUsage:\n  seqkit rename [flags]\n\nFlags:\n  -n, --by-name   check duplicated by full name instead of just id  Examples  $ echo -e  a comment\\nacgt\\n b comment of b\\nACTG\\n a comment\\naaaa    a comment\nacgt b comment of b\nACTG a comment\naaaa\n$ echo -e  a comment\\nacgt\\n b comment of b\\nACTG\\n a comment\\naaaa  | seqkit rename a comment\nacgt b comment of b\nACTG a_2 a comment\naaaa", 
            "title": "rename"
        }, 
        {
            "location": "/usage/#restart", 
            "text": "Usage  reset start position for circular genome\n\nExamples\n\n    $ echo -e  seq\\nacgtnACGTN \n     seq\n    acgtnACGTN\n\n    $ echo -e  seq\\nacgtnACGTN  | seqkit restart -i 2\n     seq\n    cgtnACGTNa\n\n    $ echo -e  seq\\nacgtnACGTN  | seqkit restart -i -2\n     seq\n    TNacgtnACG\n\nUsage:\n  seqkit restart [flags]\n\nFlags:\n  -i, --new-start int   new start position (1-base, supporting negative value counting from the end) (default 1)", 
            "title": "restart"
        }, 
        {
            "location": "/usage/#shuffle", 
            "text": "Usage  shuffle sequences.\n\nBy default, all records will be readed into memory.\nFor FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not\nsupported.\n\nFirstly, seqkit reads the sequence IDs. If the file is not plain FASTA file,\nseqkit will write the sequences to tempory files, and create FASTA index.\n\nSecondly, seqkit shuffles sequence IDs and extract sequences by FASTA index.\n\nUsage:\n  seqkit shuffle [flags]\n\nFlags:\n  -k, --keep-temp       keep tempory FASTA and .fai file when using 2-pass mode\n  -s, --rand-seed int   rand seed for shuffle (default 23)\n  -2, --two-pass        two-pass mode read files twice to lower memory usage. (only for FASTA format)  Examples    General use.  $ seqkit shuffle hairpin.fa.gz   shuffled.fa\n[INFO] read sequences ...\n[INFO] 28645 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...    For big genome, you'd better use two-pass mode  so seqkit could use\n   FASTA index to reduce memory usage  $ time seqkit shuffle -2 hsa.fa   shuffle.fa\n[INFO] create and read FASTA index ...\n[INFO] create FASTA index for hsa.fa\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...\n\nreal    0m35.080s\nuser    0m45.521s\nsys     0m3.411s    Note that when sampling on FASTQ files, make sure using same random seed by\nflag  -s  ( --rand-seed ) for read 1 and 2 files.", 
            "title": "shuffle"
        }, 
        {
            "location": "/usage/#sort", 
            "text": "Usage  sort sequences by id/name/sequence/length.\n\nBy default, all records will be readed into memory.\nFor FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not\nsupported.\n\nFirstly, seqkit reads the sequence head and length information.\nIf the file is not plain FASTA file,\nseqkit will write the sequences to tempory files, and create FASTA index.\n\nSecondly, seqkit sort sequence by head and length information\nand extract sequences by FASTA index.\n\nUsage:\n  seqkit sort [flags]\n\nFlags:\n  -l, --by-length               by sequence length\n  -n, --by-name                 by full name instead of just id\n  -s, --by-seq                  by sequence\n  -i, --ignore-case             ignore case\n  -k, --keep-temp               keep tempory FASTA and .fai file when using 2-pass mode\n  -r, --reverse                 reverse the result\n  -L, --seq-prefix-length int   length of sequence prefix on which seqkit sorts by sequences (0 for whole sequence) (default 10000)\n  -2, --two-pass                two-pass mode read files twice to lower memory usage. (only for FASTA format)  Examples  For FASTA format, use flag -2 (--two-pass) to reduce memory usage    sort by ID  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAA\" | seqkit sort --quiet SEQ2\nacgtnAAAA seq1\nACGTNcccc    sort by ID, ignoring case.  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAA\" | seqkit sort --quiet -i seq1\nACGTNcccc SEQ2\nacgtnAAAA    sort by seq, ignoring case.  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAA\" | seqkit sort --quiet -s -i SEQ2\nacgtnAAAA seq1\nACGTNcccc    sort by sequence length  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAAnnn\\n seq3\\nacgt\" | seqkit sort --quiet -l seq3\nacgt seq1\nACGTNcccc SEQ2\nacgtnAAAAnnn     \n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();  Please enable JavaScript to view the  comments powered by Disqus.", 
            "title": "sort"
        }, 
        {
            "location": "/faq/", 
            "text": "FAQ on FASTA/Q manipulations\n\n\nThis page was originally written as the section \nFASTA/Q manipulations\n of \nThe Biostar Handbook: A Beginner's Guide to Bioinformatics\n (\ndiscussion on Biostars.org\n)\n.\n\n\n\n\nThis page illustrates common FASTA/Q manipulations using\n\nSeqKit\n.\nSome other utilities, including \ncsvtk\n (CSV/TSV toolkit) and shell commands were also used.\n\n\nNote: SeqKit seamlessly support FASTA and FASTQ formats both in their original form or\nin stored in gzipped compressed format. We list FASTA or FASTQ depending on the more common\nusage but you can always use it on the other type as well.\n\n\n\n\n\n\n\n\n\n\nExample data\n\n\nHow to produce an overview of FASTQ files?\n\n\nHow to get GC content of every sequence in FASTA/Q file?\n\n\nHow to extract sequences subset from FASTA/Q file with name/ID list file?\n\n\nHow to find FASTA/Q sequences containing degenerate bases and locate them?\n\n\nHow to remove duplicated FASTA/Q records with same sequences?\n\n\nHow to locate motif/subsequence/enzyme digest site in FASTA/Q sequence?\n\n\nHow to sort huge number of FASTA sequences by length?\n\n\nHow to split FASTA sequences according to information in header?\n\n\nHow to search and replace FASTA header with known character strings from a text file?\n\n\nHow to extract paired reads from two paired-end reads file?\n\n\nHow to concatenate two FASTA sequences in to one?\n\n\n\n\n\n\n\nExample data\n\n\nOne FASTQ file (sample reads, 1M) and two FASTA files (Virus DNA and protein\nsequences from NCBI RefSeq database, 60+40M) are used.\n\n\nwget http://data.biostarhandbook.com/reads/duplicated-reads.fq.gz\nwget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.1.genomic.fna.gz\nwget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.protein.faa.gz\n\n\n\nHow to produce an overview of FASTQ files?\n\n\nSequence format and type are automatically detected.\n\n\n$ seqkit stat *.gz\nfile                      format  type     num_seqs      sum_len  min_len   avg_len    max_len\nduplicated-reads.fq.gz    FASTQ   DNA        15,000    1,515,000      101       101        101\nviral.1.1.genomic.fna.gz  FASTA   DNA         7,048  203,325,120      200  28,848.6  2,473,870\nviral.1.protein.faa.gz    FASTA   Protein   252,611   62,024,702        5     245.5      8,960\n\n\n\nHow to get GC content of every sequence in FASTA/Q file?\n\n\nseqkit fx2tab\n coverts FASTA/Q to 3-column tabular format (1th: name/ID,\n2nd: sequence, 3rd: quality), and can also provides\nvarious information in new columns, including sequence length, GC content/GC skew, alphabet.\n\n\nGC content:\n\n\n$ seqkit fx2tab --name --only-id --gc viral*.fna.gz\ngi|526245010|ref|NC_021865.1|                   40.94\ngi|460042095|ref|NC_020479.1|                   41.82\ngi|526244636|ref|NC_021857.1|                   49.17\n\n\n\nCustom bases (A, C and A+C):\n\n\n$ seqkit fx2tab -H -n -i -B a -B c -B ac viral.1.1.genomic.fna.gz\n#name   seq     qual    a       c       ac\ngi|526245010|ref|NC_021865.1|                   33.20   18.24   51.44\ngi|460042095|ref|NC_020479.1|                   32.57   19.63   52.20\ngi|526244636|ref|NC_021857.1|                   25.52   23.06   48.59\n\n\n\nHow to extract sequences subset from FASTA/Q file with name/ID list file?\n\n\nThis is a frequently used manipulation. Let's create a sample ID list file,\nwhich may also come from other way like mapping result.\n\n\n$ seqkit sample --proportion 0.001  duplicated-reads.fq.gz | seqkit seq --name --only-id \n id.txt\n\n\n\nID list file:\n\n\n$ head id.txt\nSRR1972739.2996\nSRR1972739.3044\nSRR1972739.3562\n\n\n\nSearching by ID list file:\n\n\n$ seqkit grep --pattern-file id.txt duplicated-reads.fq.gz \n duplicated-reads.subset.fq.gz\n\n\n\nHow to find FASTA/Q sequences containing degenerate bases and locate them?\n\n\nseqkit fx2tab\n coverts FASTA/Q to tabular format and can output the sequence\nalphabet in a new column. And then text searching tools can be used to filter\nthe table.\n\n\n$ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\"\ngi|446730228|ref|NC_019782.1|                   ACGNT\ngi|557940284|ref|NC_022800.1|                   ACGKT\ngi|564292828|ref|NC_023009.1|                   ACGNT\n\n\n\nLong-option version of the command:\n\n\n$ seqkit fx2tab --name --only-id --alphabet  viral.1.1.genomic.fna.gz | csvtk --no-header-row --tabs grep --fields 4 --use-regexp --ignore-case --pattern \"[^ACGT]\"\n\n\n\nYou can then exclude these sequences with \nseqkit grep\n:\n\n\n# save the sequenece IDs.\n$ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" | csvtk -H -t cut -f 1 \n id2.txt\n\n# search and exclude.\n$ seqkit grep --pattern-file id2.txt --invert-match viral.1.1.genomic.fna.gz \n clean.fa\n\n\n\nOr locate the degenerate bases, e.g, \nN\n and \nK\n\n\n$ seqkit grep --pattern-file id2.txt viral.1.1.genomic.fna.gz | seqkit locate --ignore-case --only-positive-strand --pattern K+ --pattern N+\nseqID   patternName     pattern strand  start   end     matched                                    \ngi|564292828|ref|NC_023009.1|   N+      N+      +       87972   87972   N\ngi|564292828|ref|NC_023009.1|   N+      N+      +       100983  100983  N\ngi|557307918|ref|NC_022755.1|   K+      K+      +       1788    1788    K\ngi|557307918|ref|NC_022755.1|   K+      K+      +       4044    4044    K\ngi|589287065|ref|NC_023585.1|   K+      K+      +       28296   28296   K\ngi|590911929|ref|NC_023639.1|   N+      N+      +       741654  741753  NNNNNNNNNNNNNNNNNNNNNNNNNNN\n\n\n\nHow to remove duplicated FASTA/Q records with same sequences?\n\n\n$ seqkit rmdup --by-seq --ignore-case duplicated-reads.fq.gz \n duplicated-reads.uniq.fq.gz\n\n\n\nIf the FASTA/Q file is very large, please switch on flag \n-m/--md5\n,\nwhich use MD5 instead of original seqs to reduce memory usage\nwhen comparing by sequences.\n\n\nYou can also deduplicate according to sequence ID (default) or\nfull name (\n--by-name\n).\n\n\nHow to locate motif/subsequence/enzyme digest site in FASTA/Q sequence?\n\n\nRelated posts:\n\nQuestion: Count and location of strings in fastq file reads\n,\n\nQuestion: Finding TATAWAA in sequence\n\n.\n\n\nAssuming a list of motifs (enzyme digest sites) in FASTA format to be located:\n\n\n$ cat enzymes.fa\n\nEcoRI\nGAATTC\n\nMmeI\nTCCRAC\n\nSacI\nGAGCTC\n\nXcmI\nCCANNNNNNNNNTGG\n\n\n\nFlag \n--degenerate\n is on because patterns contain degenerate bases. Command:\n\n\n$ seqkit locate --degenerate --ignore-case --pattern-file enzymes.fa viral.1.1.genomic.fna.gz\n\n\n\nSample output (simplified and reformated by \ncsvtk -t uniq -f 3 | csvtk -t pretty\n)\n\n\nseqID                           patternName   pattern           strand   start   end     matched\ngi|526245010|ref|NC_021865.1|   MmeI          TCCRAC            +        1816    1821    TCCGAC\ngi|526245010|ref|NC_021865.1|   SacI          GAGCTC            +        19506   19511   GAGCTC\ngi|526245010|ref|NC_021865.1|   XcmI          CCANNNNNNNNNTGG   +        2221    2235    CCATATTTAGTGTGG\n\n\n\nHow to sort huge number of FASTA sequences by length?\n\n\nSorting FASTA file in order of sequence size (small to large).\n\n\n$ seqkit sort --by-length viral.1.1.genomic.fna.gz \n viral.1.1.genomic.sorted.fa\n\n\n\nIf the files are too big, use flag \n--two-pass\n which consumes lesser memory.\n\n\n$ seqkit sort --by-length --two-pass viral.1.1.genomic.fna.gz \n viral.1.1.genomic.sorted.fa\n\n\n\nYou can also sort by sequence ID (default), full header (\n--by-name\n) or\nsequence content (\n--by-seq\n).\n\n\nHow to split FASTA sequences according to information in header?\n\n\nRelated posts:\n\nQuestion: extract same all similar sequences in FASTA based on the header\n\n.\n\n\nFor example, FASTA header line of \nviral.1.protein.faa.gz\n contain species name\nin square brackets.\n\n\nOverview of FASTA Headers:\n\n\n$ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name\ngi|526245011|ref|YP_008320337.1| terminase small subunit [Paenibacillus phage phiIBB_Pl23]\ngi|526245012|ref|YP_008320338.1| terminase large subunit [Paenibacillus phage phiIBB_Pl23]\ngi|526245013|ref|YP_008320339.1| portal protein [Paenibacillus phage phiIBB_Pl23]\n\n\n\nseqkit split\n can split FASTA/Q files according to ID, number of parts, size\nof every parts, and sequence region. In this case, we'll split according to\nsequence ID (species names) which can be specified by flag \n--id-regexp\n.\n\n\nDefault ID:\n\n\n$ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name --only-id\ngi|526245011|ref|YP_008320337.1|\ngi|526245012|ref|YP_008320338.1|\ngi|526245013|ref|YP_008320339.1|\n\n\n\nNew ID:\n\n\n$ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name --only-id --id-regexp \"\\[(.+)\\]\"\nPaenibacillus phage phiIBB_Pl23\nPaenibacillus phage phiIBB_Pl23\nPaenibacillus phage phiIBB_Pl23\n\n\n\nSplit:\n\n\n$ seqkit split --by-id --id-regexp \"\\[(.+)\\]\" viral.1.protein.faa.gz\n\n\n\nHow to search and replace FASTA header with known character strings from a text file?\n\n\nRelated posts:\n\nQuestion: Replace names in FASTA file with a known character string from a text file\n,\n\nQuestion: Fasta header, search and replace...?\n\n.\n\n\nseqKit replace\n can find substrings in FASTA/Q header with regular expression\nand replace them with strings or corresponding values of found substrings\nprovided by the tab-delimited key-value file.\n\n\nFor example, to unify names of protein with unknown functions, we want to\nrename \"hypothetical\" to \"putative\" in lower case.\nThe replacing rules are listed below in tab-delimited file:\n\n\n$ cat changes.tsv\nHypothetical    putative\nhypothetical    putative\nPutative        putative\n\n\n\nOverview the FASTA headers containing \"hypothetical\":\n\n\n$ seqkit grep --by-name --use-regexp --ignore-case --pattern hypothetical viral.1.protein.faa.gz | seqkit head -n 3 | seqkit seq --name\ngi|526245016|ref|YP_008320342.1| hypothetical protein IBBPl23_06 [Paenibacillus phage phiIBB_Pl23]\ngi|526245019|ref|YP_008320345.1| hypothetical protein IBBPl23_09 [Paenibacillus phage phiIBB_Pl23]\ngi|526245020|ref|YP_008320346.1| hypothetical protein IBBPl23_10 [Paenibacillus phage phiIBB_Pl23]\n\n\n\nA regular expression, \n^([^ ]+ )(\\w+)\n, was used to specify the key to be\nreplaced, which is the first word after sequence ID in this case. Note that we also\ncapture the ID (\n^([^ ]+ )\n) so we can restore it in \"replacement\" with\ncapture variable  \n${1}\n (robuster than \n$1\n).\nAnd flag \n-I/--key-capt-idx\n (default: 1) is set to 2 because the key \n(\\w+)\n\nis the second captured match. Command:\n\n\n$ seqkit replace --kv-file changes.tsv --pattern \"^([^ ]+ )(\\w+) \" --replacement \"\\${1}{kv} \" --key-capt-idx 2 --keep-key viral.1.protein.faa.gz \n renamed.fa\n\n\n\nHow to extract paired reads from two paired-end reads file?\n\n\nLet's create two unbanlanced PE reads file:\n\n\n$ seqkit rmdup duplicated-reads.fq.gz | seqkit replace --pattern \" .+\" --replacement \" 1\" | seqkit sample --proportion 0.9 --rand-seed 1 --out-file read_1.fq.gz    \n$ seqkit rmdup duplicated-reads.fq.gz | seqkit replace --pattern \" .+\" --replacement \" 2\" | seqkit sample --proportion 0.9 --rand-seed 2 --out-file read_2.fq.gz\n\n\n\nOverview:\n\n\n# number of records\n$ seqkit stat read_1.fq.gz read_2.fq.gz \nfile          format  type  num_seqs  sum_len  min_len  avg_len  max_len\nread_1.fq.gz  FASTQ   DNA      9,033  912,333      101      101      101\nread_2.fq.gz  FASTQ   DNA      8,965  905,465      101      101      101\n\n# sequence headers\n$ seqkit head -n 3 read_1.fq.gz | seqkit seq --name \nSRR1972739.1 1\nSRR1972739.3 1\nSRR1972739.4 1\n\n$ seqkit head -n 3 read_2.fq.gz | seqkit seq --name \nSRR1972739.1 2\nSRR1972739.2 2\nSRR1972739.3 2\n\n\n\nFirstly, extract sequence IDs of two file and compute the intersection:\n\n\n$ seqkit seq --name --only-id read_1.fq.gz read_2.fq.gz | sort | uniq -d \n id.txt\n\n# number of IDs\nwc -l id.txt\n8090 id.txt\n\n\n\nThen extract reads using \nid.txt\n:\n\n\n$ seqkit grep --pattern-file id.txt read_1.fq.gz -o read_1.f.fq.gz\n$ seqkit grep --pattern-file id.txt read_2.fq.gz -o read_2.f.fq.gz\n\n\n\nCheck if the IDs in two files are the same by \nmd5sum\n:\n\n\n$ seqkit seq --name --only-id read_1.f.fq.gz \n read_1.f.fq.gz.id.txt\n$ seqkit seq --name --only-id read_2.f.fq.gz \n read_2.f.fq.gz.id.txt\n\n$ md5sum read_*.f.fq.gz.id.txt\n537c57cfdc3923bb94a3dc31a0c3b02a  read_1.f.fq.gz.id.txt\n537c57cfdc3923bb94a3dc31a0c3b02a  read_2.f.fq.gz.id.txt\n\n\n\nNote that this example assumes that the IDs in the two reads file have\nsame order. If not you can sort them after previous steps. Shell \nsort\n\ncan sort large file using disk, so temporary directory is set as \ncurrent directory by option \n-T .\n.\n\n\n$ gzip -d -c read_1.f.fq.gz | seqkit fx2tab | sort -k1,1 -T . | seqkit tab2fx | gzip -c \n read_1.f.sorted.fq.gz\n$ gzip -d -c read_2.f.fq.gz | seqkit fx2tab | sort -k1,1 -T . | seqkit tab2fx | gzip -c \n read_2.f.sorted.fq.gz\n\n\n\nHow to concatenate two FASTA sequences in to one?\n\n\nRelated posts: \nCombining two fasta sequences into one\n\n\nData (not in same order):\n\n\n$ cat 1.fa\n\nseq1\naaaaa\n\nseq2\nccccc\n\nseq3\nggggg\n\n$ cat 2.fa\n\nseq3\nTTTTT\n\nseq2\nGGGGG\n\nseq1\nCCCCC\n\n\n\nStep 1\n. Convert FASTA to tab-delimited (3 columns, the 3rd column is blank (no quality for FASTA)) file:\n\n\n$ seqkit fx2tab 1.fa \n 1.fa.tsv\n$ seqkit fx2tab 2.fa \n 2.fa.tsv\n\n$ cat -A 1.fa.tsv \nseq1^Iaaaaa^I$\nseq2^Iccccc^I$\nseq3^Iggggg^I$\n\n\n\nStep 2\n. Merge  two table files:\n\n\n$ csvtk join -H -t 1.fa.tsv 2.fa.tsv | cat -A\nseq1^Iaaaaa^I^ICCCCC^I$\nseq2^Iccccc^I^IGGGGG^I$\nseq3^Iggggg^I^ITTTTT^I$\n\n\n\nStep 3\n. Note that there are two TAB between the two sequences, so we can remove them to join the sequences\n\n\n$ csvtk join -H -t 1.fa.tsv 2.fa.tsv | sed 's/\\t\\t//'\nseq1    aaaaaCCCCC\nseq2    cccccGGGGG\nseq3    gggggTTTTT\n\n\n\nStep 4\n. Convert tab-delimited file back to FASTA file:\n\n\n$ csvtk join -H -t 1.fa.tsv 2.fa.tsv | sed 's/\\t\\t//' | seqkit tab2fx\n\nseq1\naaaaaCCCCC\n\nseq2\ncccccGGGGG\n\nseq3\ngggggTTTTT\n\n\n\nAll in one command:\n\n\n$ csvtk join -H -t \n(seqkit fx2tab 1.fa) \n(seqkit fx2tab 2.fa) | sed 's/\\t\\t//' | seqkit tab2fx", 
            "title": "FAQ (New!)"
        }, 
        {
            "location": "/faq/#faq-on-fastaq-manipulations", 
            "text": "This page was originally written as the section  FASTA/Q manipulations  of  The Biostar Handbook: A Beginner's Guide to Bioinformatics  ( discussion on Biostars.org ) .   This page illustrates common FASTA/Q manipulations using SeqKit .\nSome other utilities, including  csvtk  (CSV/TSV toolkit) and shell commands were also used.  Note: SeqKit seamlessly support FASTA and FASTQ formats both in their original form or\nin stored in gzipped compressed format. We list FASTA or FASTQ depending on the more common\nusage but you can always use it on the other type as well.     Example data  How to produce an overview of FASTQ files?  How to get GC content of every sequence in FASTA/Q file?  How to extract sequences subset from FASTA/Q file with name/ID list file?  How to find FASTA/Q sequences containing degenerate bases and locate them?  How to remove duplicated FASTA/Q records with same sequences?  How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence?  How to sort huge number of FASTA sequences by length?  How to split FASTA sequences according to information in header?  How to search and replace FASTA header with known character strings from a text file?  How to extract paired reads from two paired-end reads file?  How to concatenate two FASTA sequences in to one?", 
            "title": "FAQ on FASTA/Q manipulations"
        }, 
        {
            "location": "/faq/#example-data", 
            "text": "One FASTQ file (sample reads, 1M) and two FASTA files (Virus DNA and protein\nsequences from NCBI RefSeq database, 60+40M) are used.  wget http://data.biostarhandbook.com/reads/duplicated-reads.fq.gz\nwget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.1.genomic.fna.gz\nwget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.protein.faa.gz", 
            "title": "Example data"
        }, 
        {
            "location": "/faq/#how-to-produce-an-overview-of-fastq-files", 
            "text": "Sequence format and type are automatically detected.  $ seqkit stat *.gz\nfile                      format  type     num_seqs      sum_len  min_len   avg_len    max_len\nduplicated-reads.fq.gz    FASTQ   DNA        15,000    1,515,000      101       101        101\nviral.1.1.genomic.fna.gz  FASTA   DNA         7,048  203,325,120      200  28,848.6  2,473,870\nviral.1.protein.faa.gz    FASTA   Protein   252,611   62,024,702        5     245.5      8,960", 
            "title": "How to produce an overview of FASTQ files?"
        }, 
        {
            "location": "/faq/#how-to-get-gc-content-of-every-sequence-in-fastaq-file", 
            "text": "seqkit fx2tab  coverts FASTA/Q to 3-column tabular format (1th: name/ID,\n2nd: sequence, 3rd: quality), and can also provides\nvarious information in new columns, including sequence length, GC content/GC skew, alphabet.  GC content:  $ seqkit fx2tab --name --only-id --gc viral*.fna.gz\ngi|526245010|ref|NC_021865.1|                   40.94\ngi|460042095|ref|NC_020479.1|                   41.82\ngi|526244636|ref|NC_021857.1|                   49.17  Custom bases (A, C and A+C):  $ seqkit fx2tab -H -n -i -B a -B c -B ac viral.1.1.genomic.fna.gz\n#name   seq     qual    a       c       ac\ngi|526245010|ref|NC_021865.1|                   33.20   18.24   51.44\ngi|460042095|ref|NC_020479.1|                   32.57   19.63   52.20\ngi|526244636|ref|NC_021857.1|                   25.52   23.06   48.59", 
            "title": "How to get GC content of every sequence in FASTA/Q file?"
        }, 
        {
            "location": "/faq/#how-to-extract-sequences-subset-from-fastaq-file-with-nameid-list-file", 
            "text": "This is a frequently used manipulation. Let's create a sample ID list file,\nwhich may also come from other way like mapping result.  $ seqkit sample --proportion 0.001  duplicated-reads.fq.gz | seqkit seq --name --only-id   id.txt  ID list file:  $ head id.txt\nSRR1972739.2996\nSRR1972739.3044\nSRR1972739.3562  Searching by ID list file:  $ seqkit grep --pattern-file id.txt duplicated-reads.fq.gz   duplicated-reads.subset.fq.gz", 
            "title": "How to extract sequences subset from FASTA/Q file with name/ID list file?"
        }, 
        {
            "location": "/faq/#how-to-find-fastaq-sequences-containing-degenerate-bases-and-locate-them", 
            "text": "seqkit fx2tab  coverts FASTA/Q to tabular format and can output the sequence\nalphabet in a new column. And then text searching tools can be used to filter\nthe table.  $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\"\ngi|446730228|ref|NC_019782.1|                   ACGNT\ngi|557940284|ref|NC_022800.1|                   ACGKT\ngi|564292828|ref|NC_023009.1|                   ACGNT  Long-option version of the command:  $ seqkit fx2tab --name --only-id --alphabet  viral.1.1.genomic.fna.gz | csvtk --no-header-row --tabs grep --fields 4 --use-regexp --ignore-case --pattern \"[^ACGT]\"  You can then exclude these sequences with  seqkit grep :  # save the sequenece IDs.\n$ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" | csvtk -H -t cut -f 1   id2.txt\n\n# search and exclude.\n$ seqkit grep --pattern-file id2.txt --invert-match viral.1.1.genomic.fna.gz   clean.fa  Or locate the degenerate bases, e.g,  N  and  K  $ seqkit grep --pattern-file id2.txt viral.1.1.genomic.fna.gz | seqkit locate --ignore-case --only-positive-strand --pattern K+ --pattern N+\nseqID   patternName     pattern strand  start   end     matched                                    \ngi|564292828|ref|NC_023009.1|   N+      N+      +       87972   87972   N\ngi|564292828|ref|NC_023009.1|   N+      N+      +       100983  100983  N\ngi|557307918|ref|NC_022755.1|   K+      K+      +       1788    1788    K\ngi|557307918|ref|NC_022755.1|   K+      K+      +       4044    4044    K\ngi|589287065|ref|NC_023585.1|   K+      K+      +       28296   28296   K\ngi|590911929|ref|NC_023639.1|   N+      N+      +       741654  741753  NNNNNNNNNNNNNNNNNNNNNNNNNNN", 
            "title": "How to find FASTA/Q sequences containing degenerate bases and locate them?"
        }, 
        {
            "location": "/faq/#how-to-remove-duplicated-fastaq-records-with-same-sequences", 
            "text": "$ seqkit rmdup --by-seq --ignore-case duplicated-reads.fq.gz   duplicated-reads.uniq.fq.gz  If the FASTA/Q file is very large, please switch on flag  -m/--md5 ,\nwhich use MD5 instead of original seqs to reduce memory usage\nwhen comparing by sequences.  You can also deduplicate according to sequence ID (default) or\nfull name ( --by-name ).", 
            "title": "How to remove duplicated FASTA/Q records with same sequences?"
        }, 
        {
            "location": "/faq/#how-to-locate-motifsubsequenceenzyme-digest-site-in-fastaq-sequence", 
            "text": "Related posts: Question: Count and location of strings in fastq file reads , Question: Finding TATAWAA in sequence \n.  Assuming a list of motifs (enzyme digest sites) in FASTA format to be located:  $ cat enzymes.fa EcoRI\nGAATTC MmeI\nTCCRAC SacI\nGAGCTC XcmI\nCCANNNNNNNNNTGG  Flag  --degenerate  is on because patterns contain degenerate bases. Command:  $ seqkit locate --degenerate --ignore-case --pattern-file enzymes.fa viral.1.1.genomic.fna.gz  Sample output (simplified and reformated by  csvtk -t uniq -f 3 | csvtk -t pretty )  seqID                           patternName   pattern           strand   start   end     matched\ngi|526245010|ref|NC_021865.1|   MmeI          TCCRAC            +        1816    1821    TCCGAC\ngi|526245010|ref|NC_021865.1|   SacI          GAGCTC            +        19506   19511   GAGCTC\ngi|526245010|ref|NC_021865.1|   XcmI          CCANNNNNNNNNTGG   +        2221    2235    CCATATTTAGTGTGG", 
            "title": "How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence?"
        }, 
        {
            "location": "/faq/#how-to-sort-huge-number-of-fasta-sequences-by-length", 
            "text": "Sorting FASTA file in order of sequence size (small to large).  $ seqkit sort --by-length viral.1.1.genomic.fna.gz   viral.1.1.genomic.sorted.fa  If the files are too big, use flag  --two-pass  which consumes lesser memory.  $ seqkit sort --by-length --two-pass viral.1.1.genomic.fna.gz   viral.1.1.genomic.sorted.fa  You can also sort by sequence ID (default), full header ( --by-name ) or\nsequence content ( --by-seq ).", 
            "title": "How to sort huge number of FASTA sequences by length?"
        }, 
        {
            "location": "/faq/#how-to-split-fasta-sequences-according-to-information-in-header", 
            "text": "Related posts: Question: extract same all similar sequences in FASTA based on the header \n.  For example, FASTA header line of  viral.1.protein.faa.gz  contain species name\nin square brackets.  Overview of FASTA Headers:  $ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name\ngi|526245011|ref|YP_008320337.1| terminase small subunit [Paenibacillus phage phiIBB_Pl23]\ngi|526245012|ref|YP_008320338.1| terminase large subunit [Paenibacillus phage phiIBB_Pl23]\ngi|526245013|ref|YP_008320339.1| portal protein [Paenibacillus phage phiIBB_Pl23]  seqkit split  can split FASTA/Q files according to ID, number of parts, size\nof every parts, and sequence region. In this case, we'll split according to\nsequence ID (species names) which can be specified by flag  --id-regexp .  Default ID:  $ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name --only-id\ngi|526245011|ref|YP_008320337.1|\ngi|526245012|ref|YP_008320338.1|\ngi|526245013|ref|YP_008320339.1|  New ID:  $ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name --only-id --id-regexp \"\\[(.+)\\]\"\nPaenibacillus phage phiIBB_Pl23\nPaenibacillus phage phiIBB_Pl23\nPaenibacillus phage phiIBB_Pl23  Split:  $ seqkit split --by-id --id-regexp \"\\[(.+)\\]\" viral.1.protein.faa.gz", 
            "title": "How to split FASTA sequences according to information in header?"
        }, 
        {
            "location": "/faq/#how-to-search-and-replace-fasta-header-with-known-character-strings-from-a-text-file", 
            "text": "Related posts: Question: Replace names in FASTA file with a known character string from a text file , Question: Fasta header, search and replace...? \n.  seqKit replace  can find substrings in FASTA/Q header with regular expression\nand replace them with strings or corresponding values of found substrings\nprovided by the tab-delimited key-value file.  For example, to unify names of protein with unknown functions, we want to\nrename \"hypothetical\" to \"putative\" in lower case.\nThe replacing rules are listed below in tab-delimited file:  $ cat changes.tsv\nHypothetical    putative\nhypothetical    putative\nPutative        putative  Overview the FASTA headers containing \"hypothetical\":  $ seqkit grep --by-name --use-regexp --ignore-case --pattern hypothetical viral.1.protein.faa.gz | seqkit head -n 3 | seqkit seq --name\ngi|526245016|ref|YP_008320342.1| hypothetical protein IBBPl23_06 [Paenibacillus phage phiIBB_Pl23]\ngi|526245019|ref|YP_008320345.1| hypothetical protein IBBPl23_09 [Paenibacillus phage phiIBB_Pl23]\ngi|526245020|ref|YP_008320346.1| hypothetical protein IBBPl23_10 [Paenibacillus phage phiIBB_Pl23]  A regular expression,  ^([^ ]+ )(\\w+) , was used to specify the key to be\nreplaced, which is the first word after sequence ID in this case. Note that we also\ncapture the ID ( ^([^ ]+ ) ) so we can restore it in \"replacement\" with\ncapture variable   ${1}  (robuster than  $1 ).\nAnd flag  -I/--key-capt-idx  (default: 1) is set to 2 because the key  (\\w+) \nis the second captured match. Command:  $ seqkit replace --kv-file changes.tsv --pattern \"^([^ ]+ )(\\w+) \" --replacement \"\\${1}{kv} \" --key-capt-idx 2 --keep-key viral.1.protein.faa.gz   renamed.fa", 
            "title": "How to search and replace FASTA header with known character strings from a text file?"
        }, 
        {
            "location": "/faq/#how-to-extract-paired-reads-from-two-paired-end-reads-file", 
            "text": "Let's create two unbanlanced PE reads file:  $ seqkit rmdup duplicated-reads.fq.gz | seqkit replace --pattern \" .+\" --replacement \" 1\" | seqkit sample --proportion 0.9 --rand-seed 1 --out-file read_1.fq.gz    \n$ seqkit rmdup duplicated-reads.fq.gz | seqkit replace --pattern \" .+\" --replacement \" 2\" | seqkit sample --proportion 0.9 --rand-seed 2 --out-file read_2.fq.gz  Overview:  # number of records\n$ seqkit stat read_1.fq.gz read_2.fq.gz \nfile          format  type  num_seqs  sum_len  min_len  avg_len  max_len\nread_1.fq.gz  FASTQ   DNA      9,033  912,333      101      101      101\nread_2.fq.gz  FASTQ   DNA      8,965  905,465      101      101      101\n\n# sequence headers\n$ seqkit head -n 3 read_1.fq.gz | seqkit seq --name \nSRR1972739.1 1\nSRR1972739.3 1\nSRR1972739.4 1\n\n$ seqkit head -n 3 read_2.fq.gz | seqkit seq --name \nSRR1972739.1 2\nSRR1972739.2 2\nSRR1972739.3 2  Firstly, extract sequence IDs of two file and compute the intersection:  $ seqkit seq --name --only-id read_1.fq.gz read_2.fq.gz | sort | uniq -d   id.txt\n\n# number of IDs\nwc -l id.txt\n8090 id.txt  Then extract reads using  id.txt :  $ seqkit grep --pattern-file id.txt read_1.fq.gz -o read_1.f.fq.gz\n$ seqkit grep --pattern-file id.txt read_2.fq.gz -o read_2.f.fq.gz  Check if the IDs in two files are the same by  md5sum :  $ seqkit seq --name --only-id read_1.f.fq.gz   read_1.f.fq.gz.id.txt\n$ seqkit seq --name --only-id read_2.f.fq.gz   read_2.f.fq.gz.id.txt\n\n$ md5sum read_*.f.fq.gz.id.txt\n537c57cfdc3923bb94a3dc31a0c3b02a  read_1.f.fq.gz.id.txt\n537c57cfdc3923bb94a3dc31a0c3b02a  read_2.f.fq.gz.id.txt  Note that this example assumes that the IDs in the two reads file have\nsame order. If not you can sort them after previous steps. Shell  sort \ncan sort large file using disk, so temporary directory is set as \ncurrent directory by option  -T . .  $ gzip -d -c read_1.f.fq.gz | seqkit fx2tab | sort -k1,1 -T . | seqkit tab2fx | gzip -c   read_1.f.sorted.fq.gz\n$ gzip -d -c read_2.f.fq.gz | seqkit fx2tab | sort -k1,1 -T . | seqkit tab2fx | gzip -c   read_2.f.sorted.fq.gz", 
            "title": "How to extract paired reads from two paired-end reads file?"
        }, 
        {
            "location": "/faq/#how-to-concatenate-two-fasta-sequences-in-to-one", 
            "text": "Related posts:  Combining two fasta sequences into one  Data (not in same order):  $ cat 1.fa seq1\naaaaa seq2\nccccc seq3\nggggg\n\n$ cat 2.fa seq3\nTTTTT seq2\nGGGGG seq1\nCCCCC  Step 1 . Convert FASTA to tab-delimited (3 columns, the 3rd column is blank (no quality for FASTA)) file:  $ seqkit fx2tab 1.fa   1.fa.tsv\n$ seqkit fx2tab 2.fa   2.fa.tsv\n\n$ cat -A 1.fa.tsv \nseq1^Iaaaaa^I$\nseq2^Iccccc^I$\nseq3^Iggggg^I$  Step 2 . Merge  two table files:  $ csvtk join -H -t 1.fa.tsv 2.fa.tsv | cat -A\nseq1^Iaaaaa^I^ICCCCC^I$\nseq2^Iccccc^I^IGGGGG^I$\nseq3^Iggggg^I^ITTTTT^I$  Step 3 . Note that there are two TAB between the two sequences, so we can remove them to join the sequences  $ csvtk join -H -t 1.fa.tsv 2.fa.tsv | sed 's/\\t\\t//'\nseq1    aaaaaCCCCC\nseq2    cccccGGGGG\nseq3    gggggTTTTT  Step 4 . Convert tab-delimited file back to FASTA file:  $ csvtk join -H -t 1.fa.tsv 2.fa.tsv | sed 's/\\t\\t//' | seqkit tab2fx seq1\naaaaaCCCCC seq2\ncccccGGGGG seq3\ngggggTTTTT  All in one command:  $ csvtk join -H -t  (seqkit fx2tab 1.fa)  (seqkit fx2tab 2.fa) | sed 's/\\t\\t//' | seqkit tab2fx", 
            "title": "How to concatenate two FASTA sequences in to one?"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Tutorial\n\n\nSome manipulations on big genomes\n\n\nA script \nmemusg\n is\nused to check the peek memory usage of seqkit. Usage: \nmemusg [-t] command\n.\n\n\n\n\n\n\nHuman genome\n\n\n$ seqkit stat hsa.fa\nfile    format  type  num_seqs        sum_len  min_len       avg_len      max_len\nhsa.fa  FASTA   DNA        194  3,099,750,718      970  15,978,096.5  248,956,422\n\n\n\n\n\n\n\nBuild FASTA index (\noptional\n, when using flag \n-2\n (\n--two-pass\n),\n   some commands will automaticlly build it).\n   For some commands, including \nsubseq\n, \nsplit\n, \nsort\n and \nshuffle\n,\n   when input files are (plain or gzipped) FASTA files or stdin,\n   FASTA index would be optional used for\n   rapid acccess of sequences and reducing memory occupation.\n   \nATTENTION\n: the \n.seqkit.fai\n file created by SeqKit is a little different from .fai file\n   created by samtools. SeqKit uses full sequence head instead of just ID as key.\n\n\n$ memusg -t seqkit faidx --id-regexp \"^(.+)$\"  hsa.fa -o hsa.fa.seqkit.fai\n\nelapsed time: 10.011s\npeak rss: 177.21 MB\n\n\n\nCreate common .fai file:\n\n\n$ memusg -t seqkit faidx hsa.fa -o hsa.fa.fai2\n\nelapsed time: 10.454s\npeak rss: 172.82 MB\n\n\n\nPerformance of samtools:\n\n\n$ memusg -t samtools faidx hsa.fa\n\nelapsed time: 9.574s\npeak rss: 1.45 MB\n\n\n\nExactly same content:\n\n\n$ md5sum hsa.fa.fai*\n21e0c25b4d817d1c19ee8107191b9b31  hsa.fa.fai\n21e0c25b4d817d1c19ee8107191b9b31  hsa.fa.fai2\n\n\n\n\n\n\n\nSorting by sequence length\n\n\n$ memusg -t seqkit sort --by-length --reverse --two-pass hsa.fa \n hsa.sorted.fa\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs and lengths from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] sorting ...\n[INFO] output ...\n\nelapsed time: 4.892s\npeak rss: 500.15 MB\n\n\n\nDetail:\n\n\n$ seqkit fx2tab --length hsa.sorted.fa --name --only-id | cut -f 1,4 | more\n1       248956422\n2       242193529\n3       198295559\n4       190214555\n5       181538259\n6       170805979\n7       159345973\nX       156040895\n8       145138636\n9       138394717\n11      135086622\n10      133797422\n12      133275309\n13      114364328\n14      107043718\n15      101991189\n16      90338345\n17      83257441\n18      80373285\n20      64444167\n19      58617616\nY       57227415\n22      50818468\n21      46709983\nKI270728.1      1872759\nKI270727.1      448248\n...\n\nreal    0m10.697s\nuser    0m11.153s\nsys     0m0.917s\n\n\n\n\n\n\n\nShuffling sequences\n\n\n$ memusg -t seqkit shuffle hsa.fa --two-pass \n hsa.shuffled.fa\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...\n\nelapsed time: 6.632s\npeak rss: 528.3 MB\n\n\n\n\n\n\n\nSpliting into files with single sequence\n\n\n$ memusg -t seqkit split --by-id hsa.fa --two-pass\n[INFO] split by ID. idRegexp: ^([^\\s]+)\\s?\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] write 1 sequences to file: hsa.id_KI270743.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270706.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270717.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270718.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270468.1.fa\n...\n\nelapsed time: 18.807s\npeak rss: 1.36 GB\n\n\n\n\n\n\n\nGeting subsequence of some chromesomes\n\n\n$ memusg -t seqkit subseq -r 1:10 --chr X --chr Y  hsa.fa\n\nX_1-10 X dna_sm:chromosome chromosome:GRCh38:X:1:156040895:1 REF\nnnnnnnnnnn\n\nY_1-10 Y dna_sm:chromosome chromosome:GRCh38:Y:2781480:56887902:1 REF\nNNNNNNNNNN\n\nelapsed time: 1.276s\npeak rss: 640.92 MB\n\n\n\n\n\n\n\nGeting CDS sequence of chr 1 by GTF files\n\n\n$ memusg -t seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr X --feature cds  hsa.fa \n chrX.gtf.cds.fa\n[INFO] read GTF file ...\n[INFO] 22420 GTF features loaded\n\nelapsed time: 8.643s\npeak rss: 846.14 MB\n\n\n\n\n\n\n\nRemove contaminated reads\n\n\n\n\n\n\nMapping with reads on some potential contaminate genomes, and get the reads IDs list.\n\n\n$ wc -l contaminate.list\n244 contaminate.list\n\n$ head -n 2 contaminate.list\nHWI-D00523:240:HF3WGBCXX:1:1101:2574:2226\nHWI-D00523:240:HF3WGBCXX:1:1101:12616:2205\n\n\n\n\n\n\n\nRemove contaminated reads\n\n\n$ seqkit grep -f contaminate.list -v reads_1.fq.gz -o reads_1.clean.fq.gz\n$ seqkit grep -f contaminate.list -v reads_2.fq.gz -o reads_2.clean.fq.gz\n\n$ seqkit stat *.fq.gz\nfile                  seq_format   seq_type   num_seqs   min_len   avg_len   max_len\nreads_1.clean.fq.gz   FASTQ        DNA           2,256       226       227       229\nreads_1.fq.gz         FASTQ        DNA           2,500       226       227       229\nreads_2.clean.fq.gz   FASTQ        DNA           2,256       223       224       225\nreads_2.fq.gz         FASTQ        DNA           2,500       223       224       225\n\n\n\n\n\n\n\nHandling of aligned sequences\n\n\n\n\n\n\nSome mock sequences (usually they will be much longer)\n\n\n$ cat seqs.fa\n\nseq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG\n\nseq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\n\nseq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG\n\nseq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\n\n\n\n\nRun multiple sequence alignment (clustalo)\n\n\nclustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4\n\n\n\n\n\n\n\nConvert FASTA format to tabular format.\n\n\n$ seqkit fx2tab seqs.msa.fa\nseq1    ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\nseq2    ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nseq3    ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nseq4    ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\nor\n\n\n$ seqkit fx2tab seqs.msa.fa | cut -f 2\nACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\n---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\nFor me, it's useful when 1) manually assembling Sanger sequencing result,\n2) designing site specific PCR primers.\n\n\n\n\n\n\nRemove gaps\n\n\n$ seqkit seq seqs.msa.fa -g\n\nseq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG\n\nseq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\n\nseq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG\n\nseq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\n\n\n\n\nPlay with miRNA hairpins\n\n\nDataset\n\n\nhairpin.fa.gz\n\nfrom \nThe miRBase Sequence Database -- Release 21\n\n\nQuick glance\n\n\n\n\n\n\nSequence number\n\n\n$ seqkit stat hairpin.fa.gz\nfile           format  type  num_seqs    sum_len  min_len  avg_len  max_len\nhairpin.fa.gz  FASTA   RNA     28,645  2,949,871       39      103    2,354\n\n\n\n\n\n\n\nFirst 10 bases\n\n\n$ zcat hairpin.fa.gz | seqkit subseq -r 1:10 | seqkit sort -s | seqkit seq -s | head -n 10\nAAAAAAAAAA\nAAAAAAAAAA\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAU\nAAAAAAAAGG\nAAAAAAACAU\nAAAAAAACGA\nAAAAAAAUUA\n\n\n\nhmm, nothing special, non-coding RNA~\n\n\n\n\n\n\nRepeated hairpin sequences\n\n\nWe may want to check how may identical hairpins among different species there are.\n\nseqkit rmdup\n could remove duplicated sequences by sequence content,\nand save the replicates to another file (here is \nduplicated.fa.gz\n),\nas well as replicating details (\nduplicated.detail.txt\n,\n1th column is the repeated number,\n2nd column contains sequence IDs seperated by comma).\n\n\n$ seqkit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ head -n 5 duplicated.detail.txt\n18      dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18\n16      hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3\n15      dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125\n13      hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b\n13      hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a\n\n\n\nThe result shows the most conserved miRNAs among different species,\n\nmir-29b\n, \nmir-125\n, \nmir-19b-1\n and \nmir-20a\n.\nAnd the \ndre-miR-430c\n has the most multicopies in \nDanio rerio\n.\n\n\nHairpins in different species\n\n\n\n\n\n\nBefore spliting by species, let's take a look at the sequence names.\n\n\n$ seqkit seq hairpin.fa.gz -n | head -n 3\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop\n\n\n\nThe first three letters (e.g. \ncel\n) are the abbreviation of species names.\nSo we could split hairpins by the first letters by defining custom\nsequence ID parsing regular expression \n^([\\w]+)\\-\n.\n\n\nBy default, \nseqkit\n takes the first non-space letters as sequence ID.\nFor example,\n\n\n\n\n\n\n\n\nFASTA head\n\n\nID\n\n\n\n\n\n\n\n\n\n\n123456 gene name\n\n\n123456\n\n\n\n\n\n\nlongname\n\n\nlongname\n\n\n\n\n\n\ngi\n110645304\nref\nNC_002516.2\n Pseudomona\n\n\ngi\n110645304\nref\nNC_002516.2\n\n\n\n\n\n\n\n\nBut for some sequences from NCBI,\ne.g. \ngi|110645304|ref|NC_002516.2| Pseudomona\n, the ID is \nNC_002516.2\n.\nIn this case, we could set sequence ID parsing regular expression by flag\n\n--id-regexp \"\\|([^\\|]+)\\| \"\n or just use flag \n--id-ncbi\n. If you want\nthe \ngi\n number, then use \n--id-regexp \"^gi\\|([^\\|]+)\\|\"\n.\n\n\n\n\n\n\nSplit sequences by species.\nA custom ID parsing regular expression is used, \n^([\\w]+)\\-\n.\n\n\n$ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" --two-pass\n\n\n\nTo reduce memory usage when splitting big file, we should always use flag \n--two-pass\n\n\n\n\n\n\nSpecies with most miRNA hairpins. Third column is the sequences number.\n\n\n$ cd hairpin.fa.gz.split/;\n$ seqkit stat hairpin.id_* | csvtk space2tab | csvtk -t sort -k num_seqs:nr | csvtk -t pretty| more\nfile                     format   type   num_seqs   sum_len   min_len   avg_len   max_len\nhairpin.id_hsa.fasta     FASTA    RNA    1,881      154,242   82        82        82\nhairpin.id_mmu.fasta     FASTA    RNA    1,193      107,370   90        90        90\nhairpin.id_bta.fasta     FASTA    RNA    808        61,408    76        76        76\nhairpin.id_gga.fasta     FASTA    RNA    740        42,180    57        57        57\nhairpin.id_eca.fasta     FASTA    RNA    715        89,375    125       125       125\nhairpin.id_mtr.fasta     FASTA    RNA    672        231,840   345       345       345\n\n\n\nHere, a CSV/TSV tool \ncsvtk\n\nis used to sort and view the result.\n\n\n\n\n\n\nFor human miRNA hairpins\n\n\n\n\n\n\nLength distribution.\n \nseqkit fx2tab\n could show extra information like sequence length, GC content.\n \ncsvtk\n is used to plot.\n\n\n$ seqkit grep -r -p '^hsa' hairpin.fa.gz  | seqkit fx2tab -l | cut -f 4 | csvtk -H plot hist --xlab Length --title \"Human pre-miRNA length distribution\"\n\n\n\n\n\n$ seqkit grep -r -p '^hsa' hairpin.fa.gz  | seqkit fx2tab -l | cut -f 4 | csvtk -H plot box --xlab Length --horiz --height 1.5\n\n\n\n\n\n\n\n\n\nBacteria genome\n\n\nDataset\n\n\nPseudomonas aeruginosa PAO1\n,\nfiles:\n\n\n\n\nGenbank file \nPAO1.gb\n\n\nGenome FASTA file \nPAO1.fasta\n\n\nGTF file \nPAO1.gtf\n was created with \nextract_features_from_genbank_file.py\n, by\nextract_features_from_genbank_file.py  PAO1.gb -t . -f gtf \n PAO1.gtf\n\n\n\n\n\n\n\nMotif distribution\n\n\nMotifs\n\n\n$ cat motifs.fa\n\nGTAGCGS\nGTAGCGS\n\nGGWGKTCG\nGGWGKTCG\n\n\n\n\n\n\n\nSliding. Remember flag \n--id-ncbi\n, do you?\n  By the way, do not be scared by the long flag \n--circle-genome\n, \n--step\n\n  and so on. They have short ones, \n-c\n, \n-s\n\n\n$ seqkit sliding --id-ncbi --circular-genome --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa\n\n$ seqkit stat PAO1.fasta.sliding.fa\nfile                   format  type  num_seqs     sum_len  min_len  avg_len  max_len\nPAO1.fasta.sliding.fa  FASTA   DNA        314  62,800,000  200,000  200,000  200,000\n\n\n\n\n\n\n\nLocating motifs\n\n\n$ seqkit locate --id-ncbi --ignore-case --degenerate --pattern-file motifs.fa  PAO1.fasta.sliding.fa -o  PAO1.fasta.sliding.fa.motifs.tsv\n\n\n\n\n\n\n\nPloting distribution (\nplot_motif_distribution.R\n)\n\n\n# preproccess\n$ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv  \n PAO1.fasta.sliding.fa.motifs.tsv2\n\n# plot\n$ ./plot_motif_distribution.R\n\n\n\nResult\n\n\n\n\n\n\n\n\nFind multicopy genes\n\n\n\n\n\n\nGet all CDS sequences\n\n\n$ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta\n\n$ seqkit stat *.fasta\nfile            format  type  num_seqs    sum_len    min_len    avg_len    max_len\nPAO1.cds.fasta  FASTA   DNA      5,572  5,593,306         72    1,003.8     16,884\nPAO1.fasta      FASTA   DNA          1  6,264,404  6,264,404  6,264,404  6,264,404\n\n\n\n\n\n\n\nGet duplicated sequences\n\n\n$ seqkit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text\n\n$ cat PAO1.cds.dup.text\n6       NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:-\n2       NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+\n2       NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+\n2       NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+\n\n\n\n\n\n\n\nFlanking sequences\n\n\n\n\n\n\nGet CDS and 1000 bp upstream sequence\n\n\n$ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000\n\n\n\n\n\n\n\nGet 1000 bp upstream sequence of CDS, \nNOT\n including CDS.\n\n\n$ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000 --only-flank\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n\n\n\n\nPlease enable JavaScript to view the \ncomments powered by Disqus.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tutorial", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#some-manipulations-on-big-genomes", 
            "text": "A script  memusg  is\nused to check the peek memory usage of seqkit. Usage:  memusg [-t] command .    Human genome  $ seqkit stat hsa.fa\nfile    format  type  num_seqs        sum_len  min_len       avg_len      max_len\nhsa.fa  FASTA   DNA        194  3,099,750,718      970  15,978,096.5  248,956,422    Build FASTA index ( optional , when using flag  -2  ( --two-pass ),\n   some commands will automaticlly build it).\n   For some commands, including  subseq ,  split ,  sort  and  shuffle ,\n   when input files are (plain or gzipped) FASTA files or stdin,\n   FASTA index would be optional used for\n   rapid acccess of sequences and reducing memory occupation.\n    ATTENTION : the  .seqkit.fai  file created by SeqKit is a little different from .fai file\n   created by samtools. SeqKit uses full sequence head instead of just ID as key.  $ memusg -t seqkit faidx --id-regexp \"^(.+)$\"  hsa.fa -o hsa.fa.seqkit.fai\n\nelapsed time: 10.011s\npeak rss: 177.21 MB  Create common .fai file:  $ memusg -t seqkit faidx hsa.fa -o hsa.fa.fai2\n\nelapsed time: 10.454s\npeak rss: 172.82 MB  Performance of samtools:  $ memusg -t samtools faidx hsa.fa\n\nelapsed time: 9.574s\npeak rss: 1.45 MB  Exactly same content:  $ md5sum hsa.fa.fai*\n21e0c25b4d817d1c19ee8107191b9b31  hsa.fa.fai\n21e0c25b4d817d1c19ee8107191b9b31  hsa.fa.fai2    Sorting by sequence length  $ memusg -t seqkit sort --by-length --reverse --two-pass hsa.fa   hsa.sorted.fa\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs and lengths from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] sorting ...\n[INFO] output ...\n\nelapsed time: 4.892s\npeak rss: 500.15 MB  Detail:  $ seqkit fx2tab --length hsa.sorted.fa --name --only-id | cut -f 1,4 | more\n1       248956422\n2       242193529\n3       198295559\n4       190214555\n5       181538259\n6       170805979\n7       159345973\nX       156040895\n8       145138636\n9       138394717\n11      135086622\n10      133797422\n12      133275309\n13      114364328\n14      107043718\n15      101991189\n16      90338345\n17      83257441\n18      80373285\n20      64444167\n19      58617616\nY       57227415\n22      50818468\n21      46709983\nKI270728.1      1872759\nKI270727.1      448248\n...\n\nreal    0m10.697s\nuser    0m11.153s\nsys     0m0.917s    Shuffling sequences  $ memusg -t seqkit shuffle hsa.fa --two-pass   hsa.shuffled.fa\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...\n\nelapsed time: 6.632s\npeak rss: 528.3 MB    Spliting into files with single sequence  $ memusg -t seqkit split --by-id hsa.fa --two-pass\n[INFO] split by ID. idRegexp: ^([^\\s]+)\\s?\n[INFO] create and read FASTA index ...\n[INFO] read sequence IDs from FASTA index ...\n[INFO] 194 sequences loaded\n[INFO] write 1 sequences to file: hsa.id_KI270743.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270706.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270717.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270718.1.fa\n[INFO] write 1 sequences to file: hsa.id_KI270468.1.fa\n...\n\nelapsed time: 18.807s\npeak rss: 1.36 GB    Geting subsequence of some chromesomes  $ memusg -t seqkit subseq -r 1:10 --chr X --chr Y  hsa.fa X_1-10 X dna_sm:chromosome chromosome:GRCh38:X:1:156040895:1 REF\nnnnnnnnnnn Y_1-10 Y dna_sm:chromosome chromosome:GRCh38:Y:2781480:56887902:1 REF\nNNNNNNNNNN\n\nelapsed time: 1.276s\npeak rss: 640.92 MB    Geting CDS sequence of chr 1 by GTF files  $ memusg -t seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr X --feature cds  hsa.fa   chrX.gtf.cds.fa\n[INFO] read GTF file ...\n[INFO] 22420 GTF features loaded\n\nelapsed time: 8.643s\npeak rss: 846.14 MB", 
            "title": "Some manipulations on big genomes"
        }, 
        {
            "location": "/tutorial/#remove-contaminated-reads", 
            "text": "Mapping with reads on some potential contaminate genomes, and get the reads IDs list.  $ wc -l contaminate.list\n244 contaminate.list\n\n$ head -n 2 contaminate.list\nHWI-D00523:240:HF3WGBCXX:1:1101:2574:2226\nHWI-D00523:240:HF3WGBCXX:1:1101:12616:2205    Remove contaminated reads  $ seqkit grep -f contaminate.list -v reads_1.fq.gz -o reads_1.clean.fq.gz\n$ seqkit grep -f contaminate.list -v reads_2.fq.gz -o reads_2.clean.fq.gz\n\n$ seqkit stat *.fq.gz\nfile                  seq_format   seq_type   num_seqs   min_len   avg_len   max_len\nreads_1.clean.fq.gz   FASTQ        DNA           2,256       226       227       229\nreads_1.fq.gz         FASTQ        DNA           2,500       226       227       229\nreads_2.clean.fq.gz   FASTQ        DNA           2,256       223       224       225\nreads_2.fq.gz         FASTQ        DNA           2,500       223       224       225", 
            "title": "Remove contaminated reads"
        }, 
        {
            "location": "/tutorial/#handling-of-aligned-sequences", 
            "text": "Some mock sequences (usually they will be much longer)  $ cat seqs.fa seq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG seq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG seq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG    Run multiple sequence alignment (clustalo)  clustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4    Convert FASTA format to tabular format.  $ seqkit fx2tab seqs.msa.fa\nseq1    ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\nseq2    ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nseq3    ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nseq4    ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG  or  $ seqkit fx2tab seqs.msa.fa | cut -f 2\nACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\n---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG  For me, it's useful when 1) manually assembling Sanger sequencing result,\n2) designing site specific PCR primers.    Remove gaps  $ seqkit seq seqs.msa.fa -g seq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG seq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG seq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG", 
            "title": "Handling of aligned sequences"
        }, 
        {
            "location": "/tutorial/#play-with-mirna-hairpins", 
            "text": "", 
            "title": "Play with miRNA hairpins"
        }, 
        {
            "location": "/tutorial/#dataset", 
            "text": "hairpin.fa.gz \nfrom  The miRBase Sequence Database -- Release 21", 
            "title": "Dataset"
        }, 
        {
            "location": "/tutorial/#quick-glance", 
            "text": "Sequence number  $ seqkit stat hairpin.fa.gz\nfile           format  type  num_seqs    sum_len  min_len  avg_len  max_len\nhairpin.fa.gz  FASTA   RNA     28,645  2,949,871       39      103    2,354    First 10 bases  $ zcat hairpin.fa.gz | seqkit subseq -r 1:10 | seqkit sort -s | seqkit seq -s | head -n 10\nAAAAAAAAAA\nAAAAAAAAAA\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAU\nAAAAAAAAGG\nAAAAAAACAU\nAAAAAAACGA\nAAAAAAAUUA  hmm, nothing special, non-coding RNA~", 
            "title": "Quick glance"
        }, 
        {
            "location": "/tutorial/#repeated-hairpin-sequences", 
            "text": "We may want to check how may identical hairpins among different species there are. seqkit rmdup  could remove duplicated sequences by sequence content,\nand save the replicates to another file (here is  duplicated.fa.gz ),\nas well as replicating details ( duplicated.detail.txt ,\n1th column is the repeated number,\n2nd column contains sequence IDs seperated by comma).  $ seqkit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ head -n 5 duplicated.detail.txt\n18      dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18\n16      hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3\n15      dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125\n13      hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b\n13      hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a  The result shows the most conserved miRNAs among different species, mir-29b ,  mir-125 ,  mir-19b-1  and  mir-20a .\nAnd the  dre-miR-430c  has the most multicopies in  Danio rerio .", 
            "title": "Repeated hairpin sequences"
        }, 
        {
            "location": "/tutorial/#hairpins-in-different-species", 
            "text": "Before spliting by species, let's take a look at the sequence names.  $ seqkit seq hairpin.fa.gz -n | head -n 3\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop  The first three letters (e.g.  cel ) are the abbreviation of species names.\nSo we could split hairpins by the first letters by defining custom\nsequence ID parsing regular expression  ^([\\w]+)\\- .  By default,  seqkit  takes the first non-space letters as sequence ID.\nFor example,     FASTA head  ID      123456 gene name  123456    longname  longname    gi 110645304 ref NC_002516.2  Pseudomona  gi 110645304 ref NC_002516.2     But for some sequences from NCBI,\ne.g.  gi|110645304|ref|NC_002516.2| Pseudomona , the ID is  NC_002516.2 .\nIn this case, we could set sequence ID parsing regular expression by flag --id-regexp \"\\|([^\\|]+)\\| \"  or just use flag  --id-ncbi . If you want\nthe  gi  number, then use  --id-regexp \"^gi\\|([^\\|]+)\\|\" .    Split sequences by species.\nA custom ID parsing regular expression is used,  ^([\\w]+)\\- .  $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" --two-pass  To reduce memory usage when splitting big file, we should always use flag  --two-pass    Species with most miRNA hairpins. Third column is the sequences number.  $ cd hairpin.fa.gz.split/;\n$ seqkit stat hairpin.id_* | csvtk space2tab | csvtk -t sort -k num_seqs:nr | csvtk -t pretty| more\nfile                     format   type   num_seqs   sum_len   min_len   avg_len   max_len\nhairpin.id_hsa.fasta     FASTA    RNA    1,881      154,242   82        82        82\nhairpin.id_mmu.fasta     FASTA    RNA    1,193      107,370   90        90        90\nhairpin.id_bta.fasta     FASTA    RNA    808        61,408    76        76        76\nhairpin.id_gga.fasta     FASTA    RNA    740        42,180    57        57        57\nhairpin.id_eca.fasta     FASTA    RNA    715        89,375    125       125       125\nhairpin.id_mtr.fasta     FASTA    RNA    672        231,840   345       345       345  Here, a CSV/TSV tool  csvtk \nis used to sort and view the result.    For human miRNA hairpins    Length distribution.\n  seqkit fx2tab  could show extra information like sequence length, GC content.\n  csvtk  is used to plot.  $ seqkit grep -r -p '^hsa' hairpin.fa.gz  | seqkit fx2tab -l | cut -f 4 | csvtk -H plot hist --xlab Length --title \"Human pre-miRNA length distribution\"   $ seqkit grep -r -p '^hsa' hairpin.fa.gz  | seqkit fx2tab -l | cut -f 4 | csvtk -H plot box --xlab Length --horiz --height 1.5", 
            "title": "Hairpins in different species"
        }, 
        {
            "location": "/tutorial/#bacteria-genome", 
            "text": "", 
            "title": "Bacteria genome"
        }, 
        {
            "location": "/tutorial/#dataset_1", 
            "text": "Pseudomonas aeruginosa PAO1 ,\nfiles:   Genbank file  PAO1.gb  Genome FASTA file  PAO1.fasta  GTF file  PAO1.gtf  was created with  extract_features_from_genbank_file.py , by extract_features_from_genbank_file.py  PAO1.gb -t . -f gtf   PAO1.gtf", 
            "title": "Dataset"
        }, 
        {
            "location": "/tutorial/#motif-distribution", 
            "text": "Motifs  $ cat motifs.fa GTAGCGS\nGTAGCGS GGWGKTCG\nGGWGKTCG    Sliding. Remember flag  --id-ncbi , do you?\n  By the way, do not be scared by the long flag  --circle-genome ,  --step \n  and so on. They have short ones,  -c ,  -s  $ seqkit sliding --id-ncbi --circular-genome --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa\n\n$ seqkit stat PAO1.fasta.sliding.fa\nfile                   format  type  num_seqs     sum_len  min_len  avg_len  max_len\nPAO1.fasta.sliding.fa  FASTA   DNA        314  62,800,000  200,000  200,000  200,000    Locating motifs  $ seqkit locate --id-ncbi --ignore-case --degenerate --pattern-file motifs.fa  PAO1.fasta.sliding.fa -o  PAO1.fasta.sliding.fa.motifs.tsv    Ploting distribution ( plot_motif_distribution.R )  # preproccess\n$ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv    PAO1.fasta.sliding.fa.motifs.tsv2\n\n# plot\n$ ./plot_motif_distribution.R  Result", 
            "title": "Motif distribution"
        }, 
        {
            "location": "/tutorial/#find-multicopy-genes", 
            "text": "Get all CDS sequences  $ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta\n\n$ seqkit stat *.fasta\nfile            format  type  num_seqs    sum_len    min_len    avg_len    max_len\nPAO1.cds.fasta  FASTA   DNA      5,572  5,593,306         72    1,003.8     16,884\nPAO1.fasta      FASTA   DNA          1  6,264,404  6,264,404  6,264,404  6,264,404    Get duplicated sequences  $ seqkit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text\n\n$ cat PAO1.cds.dup.text\n6       NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:-\n2       NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+\n2       NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+\n2       NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+", 
            "title": "Find multicopy genes"
        }, 
        {
            "location": "/tutorial/#flanking-sequences", 
            "text": "Get CDS and 1000 bp upstream sequence  $ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000    Get 1000 bp upstream sequence of CDS,  NOT  including CDS.  $ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000 --only-flank     \n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();  Please enable JavaScript to view the  comments powered by Disqus.", 
            "title": "Flanking sequences"
        }, 
        {
            "location": "/benchmark/", 
            "text": "Benchmark\n\n\nSoftwares\n\n\n\n\nseqkit\n. (Go).\n   Version \nv0.3.1.1\n.\n   Compiled with Go 1.7rc5.\n\n\nfasta_utilities\n. (Perl).\n   Version \n3dcc0bc\n.\n   Lots of dependencies to install.\n\n\nfastx_toolkit\n. (Perl).\n   Version \n0.0.13\n.\n   Can't handle multi-line FASTA files.\n\n\nseqmagick\n. (Python).\n   Version 0.6.1\n\n\nseqtk\n. (C).\n   Version \n1.1-r92-dirty\n.\n\n\n\n\nNot used:\n\n\n\n\npyfaidx\n. (Python).\n   Version \n0.4.7.1\n. \nNot used, because it exhausted my memory (10G) when computing reverse-complement on a 5GB fasta file of 250 bp.\n\n\n\n\nA Python script \nmemusg\n was used\nto compute running time and peak memory usage of a process.\n\n\nFeatures\n\n\n\n\n\n\n\n\nCategories\n\n\nFeatures\n\n\nseqkit\n\n\nfasta_utilities\n\n\nfastx_toolkit\n\n\npyfaidx\n\n\nseqmagick\n\n\nseqtk\n\n\n\n\n\n\n\n\n\n\nFormats support\n\n\nMulti-line FASTA\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nFASTQ\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nMulti-line  FASTQ\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nValidating sequences\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nSupporting RNA\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFunctions\n\n\nSearching by motifs\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nSampling\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nExtracting sub-sequence\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nRemoving duplicates\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nPartly\n\n\n--\n\n\n\n\n\n\n\n\nSplitting\n\n\nYes\n\n\nYes\n\n\n--\n\n\nPartly\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nSplitting by seq\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nShuffling\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nSorting\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nLocating motifs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nCommon sequences\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nCleaning bases\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\n\n\nTranscription\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nTranslation\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nFiltering by size\n\n\nIndirect\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nRenaming header\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nOther features\n\n\nCross-platform\n\n\nYes\n\n\nPartly\n\n\nPartly\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nReading STDIN\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nReading gzipped file\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nWriting gzip file\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\n\n\nNote 2\n: See \nusage\n for detailed options of seqkit.\n\n\nDatasets\n\n\nAll test data is available here: \nseqkit-benchmark-data.tar.gz\n  (2.2G)\n\n\ndataset_A.fa - large number of short sequences\n\n\nDataset A is reference genomes DNA sequences of gastrointestinal tract from\n\nNIH Human Microbiome Project\n:\n\nGastrointestinal_tract.nuc.fsa\n (FASTA format, ~2.7G).\n\n\ndataset_B.fa - small number of large sequences\n\n\nDataset B is Human genome from \nensembl\n.\n\n\n\n\nGenome DNA:  \nHomo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz\n (Gzipped FASTA file, ~900M)\n. Decompress it and rename to dataset_B.fa (~2.9G).\n\n\nGTF file:  \nHomo_sapiens.GRCh38.84.gtf.gz\n (~44M)\n\n\nBED file: \nHomo_sapiens.GRCh38.84.bed.gz\n was converted from \nHomo_sapiens.GRCh38.84.gtf.gz\n by  \ngtf2bed\n  with command\n$ zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c \n Homo_sapiens.GRCh38.84.bed.gz\n\n\n\n\n\n\n\ndataset_C.fq \u2013 Illumina single end reads (SE100)\n\n\nDataset C is Illumina single end (SE 100bp) reads file (~2.2G).\n\n\nSummary\n\n\n$ seqkit stat *.fa\nfile          format  type   num_seqs        sum_len  min_len       avg_len      max_len\ndataset_A.fa  FASTA   DNA      67,748  2,807,643,808       56      41,442.5    5,976,145\ndataset_B.fa  FASTA   DNA         194  3,099,750,718      970  15,978,096.5  248,956,422\ndataset_C.fq  FASTQ   DNA   9,186,045    918,604,500      100           100          100\n\n\n\nSequence ID list\n\n\nParts of sequences IDs was sampled and shuffled from original data.\nThey were used in test of extracting sequences by ID list.\n\n\nCommands:\n\n\n$ seqkit sample -p 0.3  dataset_A.fa | seqkit seq --name --only-id | shuf \n ids_A.txt\n$ seqkit sample -p 0.3  dataset_B.fa | seqkit seq --name --only-id | shuf \n ids_B.txt    \n$ seqkit sample -p 0.03 dataset_C.fq | seqkit seq --name --only-id | shuf \n ids_C.txt\n\n\n\nNumbers:\n\n\n$ wc -l ids*.txt\n    20138 ids_A.txt\n    58 ids_B.txt\n2754516 ids_C.txt\n\n\n\nBED file\n\n\nOnly BED data of chromosome 19 was used in test of subsequence with BED file:\n\n\n$ zcat Homo_sapiens.GRCh38.84.bed.gz | grep -E \"^19\" | gzip -c \n chr19.bed.gz\n\n\n\nPlatform\n\n\nPC:\n\n\n\n\nCPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads\n\n\nRAM: DDR3 1600MHz, 12GB\n\n\nSSD: SAMSUNG 850 EVO 250G, SATA-3\n\n\nOS: Fedora 24 (Scientific KDE spin),  Kernal: 4.6.4-301.fc24.x86_64\n\n\n\n\nSoftwares:\n\n\n\n\nPerl: perl 5, version 22, subversion 2 (v5.22.2) built for x86_64-linux-thread-multi\n\n\nPython: Python 2.7.11 (default, Jul 10 2016, 20:58:20) [GCC 6.1.1 20160621 (Red Hat 6.1.1-3)] on linux2\n\n\n\n\nTests\n\n\nAutomatic benchmark and plotting scripts are available at:  \nhttps://github.com/shenwei356/seqkit/tree/master/benchmark\n.\n\n\nAll tests were repeated 3 times,\nand average time and peak memory ware used for plotting.\n\n\nAll data were readed once before tests began to minimize the influence of page cache.\n\n\nOutput sequences of all softwares were not wrapped to fixed length.\n\n\nTest 1. Reverse Complement\n\n\nrevcom_biogo\n (\nsource\n,\n \nbinary\n ),\n a tool written in Golang (compiled with Go 1.6.3) using \nbiogo\n\n (Version \n7ebd71b\n)\n package,\n was also used for comparison of FASTA file parsing performance.\n\n\nNote that some softwares (fasta_utilities and biogo) have different converting rules of computing complement sequence on ambiguous bases, there fore the results are different from others.\n\n\nCommands\n\n\nTest 2. Extracting sequences by ID list\n\n\nCommands\n\n\nTest 3. Sampling by number\n\n\nNote that different softwares have different sampling strategies, the peak memory  depends on size of sampled sequences and the results may not be the same.\n\n\nCommands\n\n\nTest 4. Removing duplicates by sequence content\n\n\nCommands\n\n\nTest 5. Subsequence with BED file\n\n\nCommands\n\n\nResults\n\n\nseqkit version: v0.3.1.1\n\n\nFASTA:\n\n\n\n\nFASTQ:\n\n\n\n\nTest of multiple threads:\n\n\nFrom the results, 2 threads/CPU is enough, so the default threads of seqkit is 2.\n\n\n\n\nTests on different file sizes\n\n\nFiles are generated by replicating Human genome chr1 for N times.\n\n\n\n\n\n\n\n\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n\n\n\n\nPlease enable JavaScript to view the \ncomments powered by Disqus.", 
            "title": "Benchmark"
        }, 
        {
            "location": "/benchmark/#benchmark", 
            "text": "", 
            "title": "Benchmark"
        }, 
        {
            "location": "/benchmark/#softwares", 
            "text": "seqkit . (Go).\n   Version  v0.3.1.1 .\n   Compiled with Go 1.7rc5.  fasta_utilities . (Perl).\n   Version  3dcc0bc .\n   Lots of dependencies to install.  fastx_toolkit . (Perl).\n   Version  0.0.13 .\n   Can't handle multi-line FASTA files.  seqmagick . (Python).\n   Version 0.6.1  seqtk . (C).\n   Version  1.1-r92-dirty .   Not used:   pyfaidx . (Python).\n   Version  0.4.7.1 .  Not used, because it exhausted my memory (10G) when computing reverse-complement on a 5GB fasta file of 250 bp.   A Python script  memusg  was used\nto compute running time and peak memory usage of a process.", 
            "title": "Softwares"
        }, 
        {
            "location": "/benchmark/#features", 
            "text": "Categories  Features  seqkit  fasta_utilities  fastx_toolkit  pyfaidx  seqmagick  seqtk      Formats support  Multi-line FASTA  Yes  Yes  --  Yes  Yes  Yes     FASTQ  Yes  Yes  Yes  --  Yes  Yes     Multi-line  FASTQ  Yes  Yes  --  --  Yes  Yes     Validating sequences  Yes  --  Yes  Yes  --  --     Supporting RNA  Yes  Yes  --  --  Yes  Yes    Functions  Searching by motifs  Yes  Yes  --  --  Yes  --     Sampling  Yes  --  --  --  Yes  Yes     Extracting sub-sequence  Yes  Yes  --  Yes  Yes  Yes     Removing duplicates  Yes  --  --  --  Partly  --     Splitting  Yes  Yes  --  Partly  --  --     Splitting by seq  Yes  --  Yes  Yes  --  --     Shuffling  Yes  --  --  --  --  --     Sorting  Yes  Yes  --  --  Yes  --     Locating motifs  Yes  --  --  --  --  --     Common sequences  Yes  --  --  --  --  --     Cleaning bases  Yes  Yes  Yes  Yes  --  --     Transcription  Yes  Yes  Yes  Yes  Yes  Yes     Translation  --  Yes  Yes  Yes  Yes  --     Filtering by size  Indirect  Yes  --  Yes  Yes  --     Renaming header  Yes  Yes  --  --  Yes  Yes    Other features  Cross-platform  Yes  Partly  Partly  Yes  Yes  Yes     Reading STDIN  Yes  Yes  Yes  --  Yes  Yes     Reading gzipped file  Yes  Yes  --  --  Yes  Yes     Writing gzip file  Yes  --  --  --  Yes  --     Note 2 : See  usage  for detailed options of seqkit.", 
            "title": "Features"
        }, 
        {
            "location": "/benchmark/#datasets", 
            "text": "All test data is available here:  seqkit-benchmark-data.tar.gz   (2.2G)", 
            "title": "Datasets"
        }, 
        {
            "location": "/benchmark/#dataset_afa-large-number-of-short-sequences", 
            "text": "Dataset A is reference genomes DNA sequences of gastrointestinal tract from NIH Human Microbiome Project : Gastrointestinal_tract.nuc.fsa  (FASTA format, ~2.7G).", 
            "title": "dataset_A.fa - large number of short sequences"
        }, 
        {
            "location": "/benchmark/#dataset_bfa-small-number-of-large-sequences", 
            "text": "Dataset B is Human genome from  ensembl .   Genome DNA:   Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz  (Gzipped FASTA file, ~900M)\n. Decompress it and rename to dataset_B.fa (~2.9G).  GTF file:   Homo_sapiens.GRCh38.84.gtf.gz  (~44M)  BED file:  Homo_sapiens.GRCh38.84.bed.gz  was converted from  Homo_sapiens.GRCh38.84.gtf.gz  by   gtf2bed   with command $ zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c   Homo_sapiens.GRCh38.84.bed.gz", 
            "title": "dataset_B.fa - small number of large sequences"
        }, 
        {
            "location": "/benchmark/#dataset_cfq-illumina-single-end-reads-se100", 
            "text": "Dataset C is Illumina single end (SE 100bp) reads file (~2.2G).  Summary  $ seqkit stat *.fa\nfile          format  type   num_seqs        sum_len  min_len       avg_len      max_len\ndataset_A.fa  FASTA   DNA      67,748  2,807,643,808       56      41,442.5    5,976,145\ndataset_B.fa  FASTA   DNA         194  3,099,750,718      970  15,978,096.5  248,956,422\ndataset_C.fq  FASTQ   DNA   9,186,045    918,604,500      100           100          100", 
            "title": "dataset_C.fq \u2013 Illumina single end reads (SE100)"
        }, 
        {
            "location": "/benchmark/#sequence-id-list", 
            "text": "Parts of sequences IDs was sampled and shuffled from original data.\nThey were used in test of extracting sequences by ID list.  Commands:  $ seqkit sample -p 0.3  dataset_A.fa | seqkit seq --name --only-id | shuf   ids_A.txt\n$ seqkit sample -p 0.3  dataset_B.fa | seqkit seq --name --only-id | shuf   ids_B.txt    \n$ seqkit sample -p 0.03 dataset_C.fq | seqkit seq --name --only-id | shuf   ids_C.txt  Numbers:  $ wc -l ids*.txt\n    20138 ids_A.txt\n    58 ids_B.txt\n2754516 ids_C.txt", 
            "title": "Sequence ID list"
        }, 
        {
            "location": "/benchmark/#bed-file", 
            "text": "Only BED data of chromosome 19 was used in test of subsequence with BED file:  $ zcat Homo_sapiens.GRCh38.84.bed.gz | grep -E \"^19\" | gzip -c   chr19.bed.gz", 
            "title": "BED file"
        }, 
        {
            "location": "/benchmark/#platform", 
            "text": "PC:   CPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads  RAM: DDR3 1600MHz, 12GB  SSD: SAMSUNG 850 EVO 250G, SATA-3  OS: Fedora 24 (Scientific KDE spin),  Kernal: 4.6.4-301.fc24.x86_64   Softwares:   Perl: perl 5, version 22, subversion 2 (v5.22.2) built for x86_64-linux-thread-multi  Python: Python 2.7.11 (default, Jul 10 2016, 20:58:20) [GCC 6.1.1 20160621 (Red Hat 6.1.1-3)] on linux2", 
            "title": "Platform"
        }, 
        {
            "location": "/benchmark/#tests", 
            "text": "Automatic benchmark and plotting scripts are available at:   https://github.com/shenwei356/seqkit/tree/master/benchmark .  All tests were repeated 3 times,\nand average time and peak memory ware used for plotting.  All data were readed once before tests began to minimize the influence of page cache.  Output sequences of all softwares were not wrapped to fixed length.", 
            "title": "Tests"
        }, 
        {
            "location": "/benchmark/#test-1-reverse-complement", 
            "text": "revcom_biogo  ( source ,\n  binary  ),\n a tool written in Golang (compiled with Go 1.6.3) using  biogo \n (Version  7ebd71b )\n package,\n was also used for comparison of FASTA file parsing performance.  Note that some softwares (fasta_utilities and biogo) have different converting rules of computing complement sequence on ambiguous bases, there fore the results are different from others.  Commands", 
            "title": "Test 1. Reverse Complement"
        }, 
        {
            "location": "/benchmark/#test-2-extracting-sequences-by-id-list", 
            "text": "Commands", 
            "title": "Test 2. Extracting sequences by ID list"
        }, 
        {
            "location": "/benchmark/#test-3-sampling-by-number", 
            "text": "Note that different softwares have different sampling strategies, the peak memory  depends on size of sampled sequences and the results may not be the same.  Commands", 
            "title": "Test 3. Sampling by number"
        }, 
        {
            "location": "/benchmark/#test-4-removing-duplicates-by-sequence-content", 
            "text": "Commands", 
            "title": "Test 4. Removing duplicates by sequence content"
        }, 
        {
            "location": "/benchmark/#test-5-subsequence-with-bed-file", 
            "text": "Commands", 
            "title": "Test 5. Subsequence with BED file"
        }, 
        {
            "location": "/benchmark/#results", 
            "text": "seqkit version: v0.3.1.1  FASTA:   FASTQ:", 
            "title": "Results"
        }, 
        {
            "location": "/benchmark/#test-of-multiple-threads", 
            "text": "From the results, 2 threads/CPU is enough, so the default threads of seqkit is 2.", 
            "title": "Test of multiple threads:"
        }, 
        {
            "location": "/benchmark/#tests-on-different-file-sizes", 
            "text": "Files are generated by replicating Human genome chr1 for N times.    \n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();  Please enable JavaScript to view the  comments powered by Disqus.", 
            "title": "Tests on different file sizes"
        }, 
        {
            "location": "/note/", 
            "text": "Development Notes\n\n\nSequence Parsing Strategies\n\n\nIn general, most FASTA/Q file processing softwares read one sequence record and process it immediately, and then read the next one (Fig 1A). The early version of SeqKit adopted this strategy too; however, our sequence parsing algorithm was not efficient. Therefore, we tried another strategy by using a separated thread to non-blocking read and parse sequences (Fig 1B): The sequence parsing thread parsed fixed number of sequences and packaged them into Chunks, then one or more chunks were buffered in memory so they could be paralleled processed by one or more processing threads. This strategy saved time by reducing the waiting time between parsing sequences and by paralleled processing of sequences in some cases. However, this strategy consumes more memories especially for long sequences like human genome and it is hard to find an optimum combination of buffer and chunk size for different scales of sequences. \n\n\nDuring the major revision, we kept on optimizing the sequence parsing algorithm and several optimizations had been made (\nSeqkit v0.2.7\n). The most important one is using custom buffered file reading algorithm instead of using standard library \u201cbufio\u201d which is not efficient in memory for large sequences. This increased the speed and lowered memory usage significantly. Note that the \u201cbuffer\u201d here is different from the previously mentioned one in Fig 1B, this \u201cbuffer\u201d evolved in the low level processing of file reading. At last, the FASTA/Q format parsing algorithm was significant improved by factor of about 3\u00d7 in speed and the memory usage was only 1/2 compared to SeqKit version 0.2.4 in the first manuscript (this was not descripted in the manuscript). Therefore, we discarded the strategy of \u201cbuffer and chunk\u201d and adopt the serially reading strategy again (Fig 1C). The only difference between Fig C and Fig A is that the time of parsing one sequence is much shorter.\n\n\n\n\nFigure 1 Illustration of FASTA/Q file parsing strategies\n. (A) and (C) Main thread parses one sequence, waits (blocked) it to be processed and then parses next one. (B) Sequence parsing thread continuously (non-blocked) parses sequences and passes them to main thread. The width of rectangles representing sequence parsing and sequence processing is proportional with running time. Sequence parsing speeds in (A) and (B) are the same, which are both much slower than that in (C). The speeds of sequence processing are identical in (A), (B) and (C). In (B), chunks of sequences in buffer can be processed in parallel, but most of the time the main thread needs to serially manipulate the sequences.\n\n\n\n\n\n\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n\n\n\n\nPlease enable JavaScript to view the \ncomments powered by Disqus.", 
            "title": "Development Notes"
        }, 
        {
            "location": "/note/#development-notes", 
            "text": "", 
            "title": "Development Notes"
        }, 
        {
            "location": "/note/#sequence-parsing-strategies", 
            "text": "In general, most FASTA/Q file processing softwares read one sequence record and process it immediately, and then read the next one (Fig 1A). The early version of SeqKit adopted this strategy too; however, our sequence parsing algorithm was not efficient. Therefore, we tried another strategy by using a separated thread to non-blocking read and parse sequences (Fig 1B): The sequence parsing thread parsed fixed number of sequences and packaged them into Chunks, then one or more chunks were buffered in memory so they could be paralleled processed by one or more processing threads. This strategy saved time by reducing the waiting time between parsing sequences and by paralleled processing of sequences in some cases. However, this strategy consumes more memories especially for long sequences like human genome and it is hard to find an optimum combination of buffer and chunk size for different scales of sequences.   During the major revision, we kept on optimizing the sequence parsing algorithm and several optimizations had been made ( Seqkit v0.2.7 ). The most important one is using custom buffered file reading algorithm instead of using standard library \u201cbufio\u201d which is not efficient in memory for large sequences. This increased the speed and lowered memory usage significantly. Note that the \u201cbuffer\u201d here is different from the previously mentioned one in Fig 1B, this \u201cbuffer\u201d evolved in the low level processing of file reading. At last, the FASTA/Q format parsing algorithm was significant improved by factor of about 3\u00d7 in speed and the memory usage was only 1/2 compared to SeqKit version 0.2.4 in the first manuscript (this was not descripted in the manuscript). Therefore, we discarded the strategy of \u201cbuffer and chunk\u201d and adopt the serially reading strategy again (Fig 1C). The only difference between Fig C and Fig A is that the time of parsing one sequence is much shorter.   Figure 1 Illustration of FASTA/Q file parsing strategies . (A) and (C) Main thread parses one sequence, waits (blocked) it to be processed and then parses next one. (B) Sequence parsing thread continuously (non-blocked) parses sequences and passes them to main thread. The width of rectangles representing sequence parsing and sequence processing is proportional with running time. Sequence parsing speeds in (A) and (B) are the same, which are both much slower than that in (C). The speeds of sequence processing are identical in (A), (B) and (C). In (B), chunks of sequences in buffer can be processed in parallel, but most of the time the main thread needs to serially manipulate the sequences.   \n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = '//seqkit.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();  Please enable JavaScript to view the  comments powered by Disqus.", 
            "title": "Sequence Parsing Strategies"
        }, 
        {
            "location": "/bioinf/", 
            "text": "", 
            "title": "More tools"
        }, 
        {
            "location": "/yanlilab/", 
            "text": "", 
            "title": "YanLi Lab"
        }
    ]
}