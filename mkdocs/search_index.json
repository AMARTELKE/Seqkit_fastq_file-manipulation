{
    "docs": [
        {
            "location": "/", 
            "text": "fakit - a cross-platform and efficient suit for FASTA file manipulation\n\n\nDocuments  : \nhttp://shenwei356.github.io/fakit\n\n\nSource code: \nhttps://github.com/shenwei356/fakit\n\n\nIntroduction\n\n\nFASTA is a basic format for storing nucleotide and protein sequences.\nThe manipulation of FASTA file includes converting, clipping, searching, filtering,\ndeduplication, splitting, shuffling, sampling and so on.\nExisted tools only implemented parts of the functions,\nand some of them are only available for specific operating systems.\nFurthermore, the complicated installation process of dependencies packages and\nrunning environment also make them less friendly to common users.\n\n\nFakit is a cross-platform, efficient, and practical FASTA manipulations tool\nthat is friendly for researchers to complete wide ranges of FASTA file processing.\nThe suite supports plain or gzip-compressed input and output\nfrom either standard stream or files, therefore, it could be easily used in pipelines.\n\n\nFeatures\n\n\n\n\nCross-platform\n (Linux/Windows/Mac OS X/OpenBSD/FreeBSD,\n  see \ndownload\n)\n\n\nLight weight and out-of-the-box, no dependencies, no compilation, no configuration\n\n  (see \ndownload\n)\n\n\nFast\n (see \nbenchmark\n),\n  \nmultiple-CPUs supported\n (see \nbenchmark\n).\n\n\nPractical functions supported by 14 subcommands\n (see subcommands and\n  \nusage\n )\n\n\nWell documented\n (detailed \nusage\n\n  and \nbenchmark\n )\n\n\nSupport STDIN and gziped input/output file, easy being used in pipe\n\n\nSupport custom sequence ID regular expression\n (especially useful for quering with ID list)\n\n\nReproducible results (configurable rand seed in \nsample\n and \nshuffle\n)\n\n\nWell organized source code, friendly to use and easy to extend.\n\n\n\n\nFeatures comparison\n\n\n\n\n\n\n\n\nFeatures\n\n\nfakit\n\n\nfasta_utilities\n\n\nfastx_toolkit\n\n\npyfaidx\n\n\nseqmagick\n\n\nseqtk\n\n\n\n\n\n\n\n\n\n\nCross-platform\n\n\nYes\n\n\nPartly\n\n\nPartly\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nMutli-line FASTA\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nValidate bases\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\nRecognize RNA\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nRead STDIN\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nRead gzip\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nWrite gzip\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\nSearch by motifs\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nSample seqs\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nSubseq\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nDeduplicate seqs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nPartly\n\n\n--\n\n\n\n\n\n\nSplit seqs\n\n\nYes\n\n\nYes\n\n\n--\n\n\nPartly\n\n\n--\n\n\n--\n\n\n\n\n\n\nSplit by seq\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\nShuffle seqs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\nSort seqs\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\nLocate motifs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\nCommon seqs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\nClean bases\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\nTranscribe\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nTranslate\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\nSize select\n\n\nIndirect\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\nRename head\n\n\n--\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nDownload\n\n\nfakit\n is implemented in \nGolang\n programming language,\n executable binary files \nfor most popular operating system\n are freely available\n  in \nrelease\n page.\n\n\nJust \ndownload\n executable file\n of your operating system and rename it to \nfakit.exe\n (Windows) or\n \nfakit\n (other operating systems) for convenience,\n and then run it in command-line interface, no dependencies,\n no complicated compilation process.\n\n\nSubcommands\n\n\nSequence and subsequence\n\n\n\n\nseq\n        transform sequences (revserse, complement, extract ID...)\n\n\nsubseq\n     get subsequences by region/gtf/bed, including flanking sequences\n\n\nsliding\n    sliding sequences, circle genome supported\n\n\nstat\n       simple statistics of FASTA files\n\n\n\n\nFormat conversion\n\n\n\n\nfa2tab\n     covert FASTA to tabular format (and length/GC content/GC skew) to filter and sort\n\n\ntab2fa\n     covert tabular format to FASTA format\n\n\n\n\nSearching\n\n\n\n\ngrep\n       search sequences by pattern(s) of name or sequence motifs\n\n\nlocate\n     locate subsequences/motifs\n\n\n\n\nSet operations\n\n\n\n\nrmdup\n      remove duplicated sequences by id/name/sequence\n\n\ncommon\n     find common sequences of multiple files by id/name/sequence\n\n\nsplit\n      split sequences into files by id/seq region/size/parts\n\n\nsample\n     sample sequences by number or proportion\n\n\n\n\nOrdering\n\n\n\n\nshuffle\n    shuffle sequences\n\n\nsort\n       sort sequences by id/name/sequence\n\n\n\n\nGlobal Flags\n\n\n      --alphabet-guess-seq-length int   length of sequence prefix of the first FASTA record based on which fakit guesses the sequence type (default 10000)\n  -c, --chunk-size int                  chunk size (attention: unit is FASTA records not lines) (default 1000)\n      --id-ncbi                         FASTA head is NCBI-style, e.g. \ngi|110645304|ref|NC_002516.2| Pseud...\n      --id-regexp string                regular expression for parsing ID (default \n^([^\\\\s]+)\\\\s?\n)\n  -w, --line-width int                  line width (0 for no wrap) (default 60)\n  -o, --out-file string                 out file (\n-\n for stdout, suffix .gz for gzipped out) (default \n-\n)\n      --quiet                           be quiet and do not show extra information\n  -t, --seq-type string                 sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \nauto\n)\n  -j, --threads int                     number of CPUs. (default value depends on your device) (default 4)\n\n\n\n\n\nUsage \n Examples\n\n\nUsage and examples\n\n\nTutorial\n\n\nBenchmark\n\n\nDetails: \nhttp://shenwei356.github.io/fakit/benchmark/\n\n\nPerformance comparison with other tools\n\n\nAll tests were repeated 4 times.\n\n\nResult shows that the self-implemented FASTA parsing module has better performance than the \nBiogo\n, a bioinformatics library for Go.\n\n\n\n\nAcceleration with multi-CPUs\n\n\n\n\nContact\n\n\nEmail me for any problem when using fakit. shenwei356(at)gmail.com\n\n\nCreate an issue\n to report bugs,\npropose new functions or ask for help.\n\n\nLicense\n\n\nMIT License", 
            "title": "Home"
        }, 
        {
            "location": "/#fakit-a-cross-platform-and-efficient-suit-for-fasta-file-manipulation", 
            "text": "Documents  :  http://shenwei356.github.io/fakit  Source code:  https://github.com/shenwei356/fakit", 
            "title": "fakit - a cross-platform and efficient suit for FASTA file manipulation"
        }, 
        {
            "location": "/#introduction", 
            "text": "FASTA is a basic format for storing nucleotide and protein sequences.\nThe manipulation of FASTA file includes converting, clipping, searching, filtering,\ndeduplication, splitting, shuffling, sampling and so on.\nExisted tools only implemented parts of the functions,\nand some of them are only available for specific operating systems.\nFurthermore, the complicated installation process of dependencies packages and\nrunning environment also make them less friendly to common users.  Fakit is a cross-platform, efficient, and practical FASTA manipulations tool\nthat is friendly for researchers to complete wide ranges of FASTA file processing.\nThe suite supports plain or gzip-compressed input and output\nfrom either standard stream or files, therefore, it could be easily used in pipelines.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#features", 
            "text": "Cross-platform  (Linux/Windows/Mac OS X/OpenBSD/FreeBSD,\n  see  download )  Light weight and out-of-the-box, no dependencies, no compilation, no configuration \n  (see  download )  Fast  (see  benchmark ),\n   multiple-CPUs supported  (see  benchmark ).  Practical functions supported by 14 subcommands  (see subcommands and\n   usage  )  Well documented  (detailed  usage \n  and  benchmark  )  Support STDIN and gziped input/output file, easy being used in pipe  Support custom sequence ID regular expression  (especially useful for quering with ID list)  Reproducible results (configurable rand seed in  sample  and  shuffle )  Well organized source code, friendly to use and easy to extend.   Features comparison     Features  fakit  fasta_utilities  fastx_toolkit  pyfaidx  seqmagick  seqtk      Cross-platform  Yes  Partly  Partly  Yes  Yes  Yes    Mutli-line FASTA  Yes  Yes  --  Yes  Yes  Yes    Validate bases  Yes  --  Yes  Yes  --  --    Recognize RNA  Yes  Yes  --  --  Yes  Yes    Read STDIN  Yes  Yes  Yes  --  Yes  Yes    Read gzip  Yes  Yes  --  --  Yes  Yes    Write gzip  Yes  --  --  --  Yes  --    Search by motifs  Yes  Yes  --  --  Yes  Yes    Sample seqs  Yes  Yes  --  --  Yes  Yes    Subseq  Yes  Yes  --  Yes  Yes  Yes    Deduplicate seqs  Yes  --  --  --  Partly  --    Split seqs  Yes  Yes  --  Partly  --  --    Split by seq  Yes  --  Yes  Yes  --  --    Shuffle seqs  Yes  --  --  --  --  --    Sort seqs  Yes  Yes  --  --  Yes  --    Locate motifs  Yes  --  --  --  --  --    Common seqs  Yes  --  --  --  --  --    Clean bases  Yes  Yes  Yes  Yes  --  --    Transcribe  Yes  Yes  Yes  Yes  Yes  Yes    Translate  --  Yes  Yes  Yes  Yes  --    Size select  Indirect  Yes  --  Yes  Yes  --    Rename head  --  Yes  --  --  Yes  Yes", 
            "title": "Features"
        }, 
        {
            "location": "/#download", 
            "text": "fakit  is implemented in  Golang  programming language,\n executable binary files  for most popular operating system  are freely available\n  in  release  page.  Just  download  executable file\n of your operating system and rename it to  fakit.exe  (Windows) or\n  fakit  (other operating systems) for convenience,\n and then run it in command-line interface, no dependencies,\n no complicated compilation process.", 
            "title": "Download"
        }, 
        {
            "location": "/#subcommands", 
            "text": "Sequence and subsequence   seq         transform sequences (revserse, complement, extract ID...)  subseq      get subsequences by region/gtf/bed, including flanking sequences  sliding     sliding sequences, circle genome supported  stat        simple statistics of FASTA files   Format conversion   fa2tab      covert FASTA to tabular format (and length/GC content/GC skew) to filter and sort  tab2fa      covert tabular format to FASTA format   Searching   grep        search sequences by pattern(s) of name or sequence motifs  locate      locate subsequences/motifs   Set operations   rmdup       remove duplicated sequences by id/name/sequence  common      find common sequences of multiple files by id/name/sequence  split       split sequences into files by id/seq region/size/parts  sample      sample sequences by number or proportion   Ordering   shuffle     shuffle sequences  sort        sort sequences by id/name/sequence   Global Flags        --alphabet-guess-seq-length int   length of sequence prefix of the first FASTA record based on which fakit guesses the sequence type (default 10000)\n  -c, --chunk-size int                  chunk size (attention: unit is FASTA records not lines) (default 1000)\n      --id-ncbi                         FASTA head is NCBI-style, e.g.  gi|110645304|ref|NC_002516.2| Pseud...\n      --id-regexp string                regular expression for parsing ID (default  ^([^\\\\s]+)\\\\s? )\n  -w, --line-width int                  line width (0 for no wrap) (default 60)\n  -o, --out-file string                 out file ( -  for stdout, suffix .gz for gzipped out) (default  - )\n      --quiet                           be quiet and do not show extra information\n  -t, --seq-type string                 sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default  auto )\n  -j, --threads int                     number of CPUs. (default value depends on your device) (default 4)", 
            "title": "Subcommands"
        }, 
        {
            "location": "/#usage-examples", 
            "text": "Usage and examples  Tutorial", 
            "title": "Usage &amp;&amp; Examples"
        }, 
        {
            "location": "/#benchmark", 
            "text": "Details:  http://shenwei356.github.io/fakit/benchmark/", 
            "title": "Benchmark"
        }, 
        {
            "location": "/#performance-comparison-with-other-tools", 
            "text": "All tests were repeated 4 times.  Result shows that the self-implemented FASTA parsing module has better performance than the  Biogo , a bioinformatics library for Go.", 
            "title": "Performance comparison with other tools"
        }, 
        {
            "location": "/#acceleration-with-multi-cpus", 
            "text": "", 
            "title": "Acceleration with multi-CPUs"
        }, 
        {
            "location": "/#contact", 
            "text": "Email me for any problem when using fakit. shenwei356(at)gmail.com  Create an issue  to report bugs,\npropose new functions or ask for help.", 
            "title": "Contact"
        }, 
        {
            "location": "/#license", 
            "text": "MIT License", 
            "title": "License"
        }, 
        {
            "location": "/download/", 
            "text": "Download\n\n\nfakit\n is implemented in \nGolang\n programming language,\n executable binary files \nfor most popular operating system\n are freely available\n  in \nrelease\n page.\n\n\nCurrent Version\n\n\n\n\nfakit v0.1.5\n\n\nadd global flag \n--id-ncbi\n\n\nadd flag \n-d\n (\n--dup-seqs-file\n) and \n-D\n (\n--dup-num-file\n) for subcommand \nrmdup\n\n\nmake using MD5 as an optional flag \n-m\n (\n--md5\n) in subcommand \nrmdup\n and \ncommon\n\n\nfix file name suffix of \nfakit split\n result\n\n\nminor modification of \nsliding\n output\n\n\n\n\n\n\n\n\nInstallation\n\n\nJust \ndownload\n executable file\n of your operating system and rename it to \nfakit.exe\n (Windows) or\n \nfakit\n (other operating systems) for convenience,\n and then run it in command-line interface, no dependencies,\n no complicated compilation process.\n\n\nYou can also add the directory of the executable file to environment variable\n\nPATH\n, so you can run \nfakit\n anywhere.\n\n\n\n\n\n\nFor windows, the simplest way is copy it to \nC:\\WINDOWS\\system32\n.\n\n\n\n\n\n\nFor Linux, type:\n\n\nchmod a+x /PATH/OF/FASTCOV/fakit\necho export PATH=\\$PATH:/PATH/OF/FASTCOV \n ~/.bashrc\n\n\n\nor simply copy it to \n/usr/local/bin\n\n\n\n\n\n\nPrevious Versions\n\n\n\n\nfakit v0.1.4.1\n\n\nchange alignment of \nstat\n output\n\n\npreciser CPUs number control\n\n\n\n\n\n\nfakit v0.1.4\n\n\nadd subcommand \nsort\n\n\nimprove subcommand \nsubseq\n: supporting of getting subsequences by GTF and BED files\n\n\nchange name format of \nsliding\n result\n\n\nprettier output of \nstat\n\n\n\n\n\n\nfakit v0.1.3.1\n\n\nPerformance improvement by reducing time of cleaning spaces\n\n\nDocument update\n\n\n\n\n\n\nfakit v0.1.3\n\n\nFurther performance improvement\n\n\nRename sub command \nextract\n to \ngrep\n\n\nChange default value of flag \n--threads\n back CPU number of current device,\n  change default value of flag \n--chunk-size\n back 10000 sequences.\n\n\nUpdate benchmark\n\n\n\n\n\n\nfakit v0.1.2\n\n\nAdd flag \n--dna2rna\n and \n--rna2dna\n to subcommand \nseq\n.\n\n\n\n\n\n\nfakit v0.1.1\n\n\n5.5X speedup of FASTA file parsing\n by avoid using regular expression to remove spaces (\ndetail\n ) and using slice indexing instead of map to validate letters (\ndetail\n)\n\n\nChange default value of global flag \n-- thread\n to 1. Since most of the subcommands are I/O intensive,  For computation intensive jobs, like extract and locate, you may set a bigger value.\n\n\nChange default value of global flag \n--chunk-size\n to 100.\n\n\nAdd subcommand \nstat\n\n\nFix bug of failing to automatically detect alphabet when only one record in file.\n\n\n\n\n\n\nfakit v0.1\n\n\nfirst release of fakit", 
            "title": "Download"
        }, 
        {
            "location": "/download/#download", 
            "text": "fakit  is implemented in  Golang  programming language,\n executable binary files  for most popular operating system  are freely available\n  in  release  page.", 
            "title": "Download"
        }, 
        {
            "location": "/download/#current-version", 
            "text": "fakit v0.1.5  add global flag  --id-ncbi  add flag  -d  ( --dup-seqs-file ) and  -D  ( --dup-num-file ) for subcommand  rmdup  make using MD5 as an optional flag  -m  ( --md5 ) in subcommand  rmdup  and  common  fix file name suffix of  fakit split  result  minor modification of  sliding  output", 
            "title": "Current Version"
        }, 
        {
            "location": "/download/#installation", 
            "text": "Just  download  executable file\n of your operating system and rename it to  fakit.exe  (Windows) or\n  fakit  (other operating systems) for convenience,\n and then run it in command-line interface, no dependencies,\n no complicated compilation process.  You can also add the directory of the executable file to environment variable PATH , so you can run  fakit  anywhere.    For windows, the simplest way is copy it to  C:\\WINDOWS\\system32 .    For Linux, type:  chmod a+x /PATH/OF/FASTCOV/fakit\necho export PATH=\\$PATH:/PATH/OF/FASTCOV   ~/.bashrc  or simply copy it to  /usr/local/bin", 
            "title": "Installation"
        }, 
        {
            "location": "/download/#previous-versions", 
            "text": "fakit v0.1.4.1  change alignment of  stat  output  preciser CPUs number control    fakit v0.1.4  add subcommand  sort  improve subcommand  subseq : supporting of getting subsequences by GTF and BED files  change name format of  sliding  result  prettier output of  stat    fakit v0.1.3.1  Performance improvement by reducing time of cleaning spaces  Document update    fakit v0.1.3  Further performance improvement  Rename sub command  extract  to  grep  Change default value of flag  --threads  back CPU number of current device,\n  change default value of flag  --chunk-size  back 10000 sequences.  Update benchmark    fakit v0.1.2  Add flag  --dna2rna  and  --rna2dna  to subcommand  seq .    fakit v0.1.1  5.5X speedup of FASTA file parsing  by avoid using regular expression to remove spaces ( detail  ) and using slice indexing instead of map to validate letters ( detail )  Change default value of global flag  -- thread  to 1. Since most of the subcommands are I/O intensive,  For computation intensive jobs, like extract and locate, you may set a bigger value.  Change default value of global flag  --chunk-size  to 100.  Add subcommand  stat  Fix bug of failing to automatically detect alphabet when only one record in file.    fakit v0.1  first release of fakit", 
            "title": "Previous Versions"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage and Examples\n\n\nfakit\n\n\nUsage\n\n\nfakit -- Swiss army knife of FASTA format\n\nVersion: 0.1.5\n\nAuthor: Wei Shen \nshenwei356@gmail.com\n\n\nDocuments  : http://shenwei356.github.io/fakit\nSource code: https://github.com/shenwei356/fakit\n\nUsage:\n  fakit [command]\n\nAvailable Commands:\n  common      find common sequences of multiple files by id/name/sequence\n  fa2tab      covert FASTA to tabular format (with length/GC content/GC skew) to filter and sort\n  grep        search sequences by pattern(s) of name or sequence motifs\n  locate      locate subsequences/motifs\n  rmdup       remove duplicated sequences by id/name/sequence\n  sample      sample sequences by number or proportion\n  seq         transform sequences (revserse, complement, extract ID...)\n  shuffle     shuffle sequences\n  sliding     sliding sequences, circle genome supported\n  sort        sort sequences by id/name/sequence/length\n  split       split sequences into files by id/seq region/size/parts\n  stat        simple statistics of FASTA files\n  subseq      get subsequences by region/gtf/bed, including flanking sequences\n  tab2fa      covert tabular format to FASTA format\n\nFlags:\n      --alphabet-guess-seq-length int   length of sequence prefix of the first FASTA record based on which fakit guesses the sequence type (default 10000)\n  -c, --chunk-size int                  chunk size (attention: unit is FASTA records not lines) (default 1000)\n      --id-ncbi                         FASTA head is NCBI-style, e.g. \ngi|110645304|ref|NC_002516.2| Pseud...\n      --id-regexp string                regular expression for parsing ID (default \n^([^\\\\s]+)\\\\s?\n)\n  -w, --line-width int                  line width (0 for no wrap) (default 60)\n  -o, --out-file string                 out file (\n-\n for stdout, suffix .gz for gzipped out) (default \n-\n)\n      --quiet                           be quiet and do not show extra information\n  -t, --seq-type string                 sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \nauto\n)\n  -j, --threads int                     number of CPUs. (default value depends on your device) (default 4)\n\n\n\n\n\nPerformance Tips\n\n\n\n\n--chunk-size\n, for large sequences like human genome,\nyou could set a small value, like 1, to reduce memory usage.\n\n\n\n\nDatasets\n\n\nDatasets from \nThe miRBase Sequence Database -- Release 21\n\n\n\n\nhairpin.fa.gz\n\n\nmature.fa.gz\n\n\nmiRNA.diff.gz\n\n\n\n\nHuman genome from \nensembl\n\n(For \nfakit subseq\n)\n\n\n\n\nHomo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz\n\n\nHomo_sapiens.GRCh38.84.gtf.gz\n\n\nHomo_sapiens.GRCh38.84.bed.gz\n is converted from \nHomo_sapiens.GRCh38.84.gtf.gz\n\nby \ngtf2bed\n\nwith command\nzcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c \n Homo_sapiens.GRCh38.84.bed.gz\n\n\n\n\n\n\n\nOnly DNA and gtf/bed data of Chr1 were used:\n\n\n\n\n\n\nchr1.fa.gz\n\n\n    fakit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz\n\n\n\n\n\n\n\nchr1.gtf.gz\n\n\n    zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c \n chr1.gtf.gz\n\n\n\n\n\n\n\nchr1.bed.gz\n\n\n    zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c \n chr1.bed.gz\n\n\n\n\n\n\n\nseq\n\n\nUsage\n\n\ntransform sequence (revserse, complement, extract ID...)\n\nUsage:\n  fakit seq [flags]\n\nFlags:\n  -p, --complement          complement sequence (blank for Protein sequence)\n      --dna2rna             DNA to RNA\n  -G, --gap-letter string   gap letters (default \n- \n)\n  -l, --lower-case          print sequences in lower case\n  -n, --name                only print names\n  -i, --only-id             print ID instead of full head\n  -g, --remove-gaps         remove gaps\n  -r, --reverse             reverse sequence)\n      --rna2dna             RNA to DNA\n  -s, --seq                 only print sequences\n  -u, --upper-case          print sequences in upper case\n\n\n\n\n\nExamples\n\n\n\n\n\n\nRead and print\n\n\n\n\n\n\nFrom file:\n\n\n$ fakit seq hairpin.fa.gz\n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC\nUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\n\n\n\n\n\n\n\nFrom stdin:\n\n\nzcat hairpin.fa.gz | fakit seq\n\n\n\n\n\n\n\n\n\n\n\nSequence types\n\n\n\n\n\n\nIn default, \nfakit seq\n automatically detect the sequence type\n\n\n$ echo -e \"\nseq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | fakit stat\nfile    seq_type    num_seqs    min_len    avg_len    max_len\n-            DNA           1         28         28         28\n\n$ echo -e \"\nseq\\nACGUN ACGUN\" | fakit stat\nfile    seq_type    num_seqs    min_len    avg_len    max_len\n-            RNA           1         11         11         11\n\n$ echo -e \"\nseq\\nabcdefghijklmnpqrstvwyz\" | fakit stat\nfile    seq_type    num_seqs    min_len    avg_len    max_len\n-        Protein           1         23         23         23\n\n\n\n\n\n\n\nYou can also set sequence type by flag \n-t\n (\n--seq-type\n).\n  But this only take effect on subcommands \nseq\n and \nlocate\n.\n\n\n$ echo -e \"\nseq\\nabcdefghijklmnpqrstvwyz\" | fakit seq -t dna\n[ERRO] error when parsing seq: seq (invalid DNAredundant letter: e)\n\n\n\n\n\n\n\n\n\n\n\nOnly print names\n\n\n\n\n\n\nFull name:\n\n\n$ fakit seq hairpin.fa.gz -n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop\n\n\n\n\n\n\n\nOnly ID:\n\n\n$ fakit seq hairpin.fa.gz -n -i\ncel-let-7\ncel-lin-4\ncel-mir-1\n\n\n\n\n\n\n\nCustom ID region by regular expression (this could be applied to all subcommands):\n\n\n$ fakit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\"\nMI0000001\nMI0000002\nMI0000003\n\n\n\n\n\n\n\n\n\n\n\nOnly print seq (global flag \n-w\n defines the output line width, 0 for no wrap)\n\n\n$ fakit seq hairpin.fa.gz -s -w 0\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\nAUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU\nAAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU\n\n\n\n\n\n\n\nReverse comlement sequence\n\n\n$ fakit seq hairpin.fa.gz -r -p\n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC\nAAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA\n\n\n\n\n\n\n\nRemove gaps and to lower/upper case\n\n\n$ echo -e \"\nseq\\nACGT-ACTGC-ACC\" | fakit seq -i -g\n\nseq\nACGTACTGCACC\n\n\n\n\n\n\n\nRNA to DNA\n\n\n$ echo -e \"\nseq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | fakit seq --rna2dna\n\nseq\nTCATATGCTTGTCTCAAAGATTA\n\n\n\n\n\n\n\nsubseq\n\n\nUsage\n\n\nget subsequences by region/gtf/bed, including flanking sequences.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n\nUsage:\n  fakit subseq [flags]\n\nFlags:\n  -b, --bed string        by BED file\n  -d, --down-stream int   down stream length\n  -T, --feature string    feature type (\n.\n for all, case ignored) (default \n.\n)\n  -g, --gtf string        by GTF (version 2.2) file\n  -f, --only-flank        only return up/down stream sequence\n  -r, --region string     by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type \nfakit subseq -h\n for more examples\n  -u, --up-stream int     up stream length\n\n\n\n\n\nExamples\n\n\n\n\n\n\nFirst 12 bases\n\n\n$ zcat hairpin.fa.gz | fakit subseq -r 1:12\n\n\n\n\n\n\n\nLast 12 bases\n\n\n$ zcat hairpin.fa.gz | fakit subseq -r -12:-1\n\n\n\n\n\n\n\nSubsequences without first and last 12 bases\n\n\n$ zcat hairpin.fa.gz | fakit subseq -r 13:-13\n\n\n\n\n\n\n\nGet subsequence by GTF file\n\n\n$ cat t.fa\n\nseq\nactgACTGactgn\n$ cat t.gtf\nseq     test    CDS     5       8       .       .       .       gene_id \"A\"; transcript_id \"\";\nseq     test    CDS     5       8       .       -       .       gene_id \"B\"; transcript_id \"\";\n$ fakit\n\nfakit subseq --gtf t.gtf t.fa\n\nseq_5:8:. A\nACTG\n\nseq_5:8:- B\nCAGT\n\n\n\n\n\n\n\nGet CDS and 3bp up-stream sequences\n\n\n$ fakit subseq --gtf t.gtf t.fa -u 3\n\nseq_5:8:._us:3 A\nctgACTG\n\nseq_5:8:-_us:3 B\nagtCAGT\n\n\n\n\n\n\n\nGet 3bp up-stream sequences of CDS, not including CDS\n\n\n$ fakit subseq --gtf t.gtf t.fa -u 3 -f\n\nseq_5:8:._usf:3 A\nctg\n\nseq_5:8:-_usf:3 B\nagt\n\n\n\n\n\n\n\nGet subsequences by BED file. \nNote that flag \n-c 1\n is used for large genome\n.\n\n\n$ fakit subseq -c 1 --bed chr1.bed.gz chr1.fa.gz -o chr1.bed.gz.fa.gz\n\n\n\nWe may need to remove duplicated sequences\n\n\n$ fakit subseq -c 1 --bed chr1.bed.gz chr1.fa.gz | fakit rmdup -o chr1.bed.gz.rmdup.fa.gz\n[INFO] 141060 duplicated records removed\n\n\n\nSummary:\n\n\n$ fakit stat chr1.bed.gz.*.gz\nfile                       seq_type    num_seqs    min_len    avg_len      max_len\nchr1.bed.gz.fa.gz               DNA     231,974          1    3,089.5    1,551,957\nchr1.bed.gz.rmdup.fa.gz         DNA      90,914          1    6,455.8    1,551,957\n\n\n\n\n\n\n\nsliding\n\n\nUsage\n\n\nsliding sequences, circle genome supported\n\nUsage:\n  fakit sliding [flags]\n\nFlags:\n  -C, --circle-genome   circle genome\n  -s, --step int        step size\n  -W, --window int      window size\n\n\n\n\n\nExamples\n\n\n\n\n\n\nGeneral use\n\n\n$ echo -e \"\nseq\\nACGTacgtNN\" | fakit sliding -s 3 -W 6\n\nseq_sliding:1-6\nACGTac\n\nseq_sliding:4-9\nTacgtN\n\n\n\n\n\n\n\nCircle genome\n\n\n$ echo -e \"\nseq\\nACGTacgtNN\" | fakit sliding -s 3 -W 6 -C\n\nseq_sliding:1-6\nACGTac\n\nseq_sliding:4-9\nTacgtN\n\nseq_sliding:7-2\ngtNNAC\n\nseq_sliding:10-5\nNACGTa\n\n\n\n\n\n\n\nGenerate GC content for ploting\n\n\n$ zcat hairpin.fa.gz | fakit fa2tab | head -n 1 | fakit tab2fa | fakit sliding -s 5 -W 30 | fakit fa2tab -n -g\ncel-let-7_sliding:1-30          50.00\ncel-let-7_sliding:6-35          46.67\ncel-let-7_sliding:11-40         43.33\ncel-let-7_sliding:16-45         36.67\ncel-let-7_sliding:21-50         33.33\ncel-let-7_sliding:26-55         40.00\n...\n\n\n\n\n\n\n\nstat\n\n\nUsage\n\n\nsimple statistics of FASTA files\n\nUsage:\n  fakit stat [flags]\n\n\n\n\n\nEexamples\n\n\n\n\nGeneral use\n$ fakit stat *.fa.gz\nfile             seq_type    num_seqs    min_len    avg_len    max_len\nhairpin.fa.gz         RNA      28,645         39        103      2,354\nmature.fa.gz          RNA      35,828         15       21.8         34\n\n\n\n\n\n\n\nfa2tab \n fa2tab\n\n\nUsage (fa2tab)\n\n\ncovert FASTA to tabular format, and provide various information,\nlike sequence length, GC content/GC skew.\n\nUsage:\n  fakit fa2tab [flags]\n\nFlags:\n  -b, --base-content value   print base content. (case ignored, multiple values supported) e.g. -b AT -b N (default [])\n  -g, --gc                   print GC content\n  -G, --gc-skew              print GC-Skew\n  -l, --length               print sequence length\n  -n, --name                 only print names (no sequences)\n  -i, --only-id              print ID instead of full head\n  -T, --title                print title line\n\n\n\n\n\nUsage (tab2fa)\n\n\ncovert tabular format (first two columns) to FASTA format\n\nUsage:\n  fakit tab2fa [flags]\n\nFlags:\n  -p, --comment-line-prefix value   comment line prefix (default [#,//])\n\n\n\n\n\nExamples\n\n\n\n\n\n\nDefault output\n\n\n$ fakit fa2tab hairpin.fa.gz\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop      UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop      AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU\n\n\n\n\n\n\n\nPrint sequence length, GC content, and only print names (no sequences),\nwe could also print title line by flag \n-T\n.\n\n\n$ fakit fa2tab hairpin.fa.gz -i -l -g -n -T\n# name  seq     length  GC\ncel-let-7               99      43.43\ncel-lin-4               94      54.26\ncel-mir-1               96      40.62\n\n\n\n\n\n\n\nUse fa2tab and tab2fa in pipe\n\n\n$ zcat hairpin.fa.gz | fakit fa2tab | fakit tab2fa\n\n\n\n\n\n\n\nSort sequences by length (use \nfakit sort -l\n)\n\n\n$ zcat hairpin.fa.gz | fakit fa2tab -l | sort -t\"`echo -e '\\t'`\" -n -k3,3 | fakit tab2fa\n\ncin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop\nUUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC\n\nmmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop\nUGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU\n\ncin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop\nACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU\n\n$ fakit sort -l hairpin.fa.gz\n\n\n\nSorting or filtering by GC (or other base by -flag \n-b\n) content could also achieved in similar way.\n\n\n\n\n\n\nGet first 1000 sequences\n\n\n$ zcat hairpin.fa.gz | fakit fa2tab | head -n 1000 | fakit tab2fa\n\n\n\n\n\n\n\nExtension\n\n\nAfter converting FASTA to tabular format with \nfakit fa2tab\n,\nit could be handled with CSV/TSV tools,\n e.g. \ndatakit\n (CSV/TSV file manipulation and more)\n\n\n\n\ncsv_grep\n\n(go version) or \ncsv_grep.py\n\n(python version), could be used to filter sequences (similar with \nfakit extract\n)\n\n\nintersection\n\ncomputates intersection of multiple files. It could achieve similar function\nas \nfakit common -n\n along with shell.\n\n\ncsv_join\n joins multiple CSV/TSV files by multiple IDs.\n\n\ncsv_melt\n\nprovides melt function, could be used in preparation of data for ploting.\n\n\n\n\ngrep\n\n\nUsage\n\n\nsearch sequences by pattern(s) of name or sequence motifs\n\nUsage:\n  fakit grep [flags]\n\nFlags:\n  -n, --by-name               match by full name instead of just id\n  -s, --by-seq                match by seq\n  -d, --degenerate            pattern/motif contains degenerate base\n      --delete-matched        delete matched pattern to speedup\n  -i, --ignore-case           ignore case\n  -v, --invert-match          invert the sense of matching, to select non-matching records\n  -p, --pattern value         search pattern (multiple values supported) (default [])\n  -f, --pattern-file string   pattern file\n  -r, --use-regexp            patterns are regular expression\n\n\n\n\n\nExamples\n\n\n\n\n\n\nExtract human hairpins (i.e. sequences with name starting with \nhsa\n)\n\n\n$ zcat hairpin.fa.gz | fakit grep -r -p ^hsa\n\nhsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop\nUGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU\nACAAUCUACUGUCUUUCCUA\n\nhsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop\nAGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU\nCCUAGCUUUCCU\n\n\n\n\n\n\n\nRemove human and mice hairpins.\n\n\n$ zcat hairpin.fa.gz | fakit grep -r -p ^hsa -p ^mmu -v\n\n\n\n\n\n\n\nExtract new entries by information from miRNA.diff.gz\n\n\n\n\n\n\nGet IDs of new entries.\n\n\n$ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2 \n list\n$ more list\ncfa-mir-486\ncfa-mir-339-1\npmi-let-7\n\n\n\n\n\n\n\nExtract by ID list file\n\n\n$ zcat hairpin.fa.gz | fakit grep -f list \n new.fa\n\n\n\n\n\n\n\n\n\n\n\nExtract sequences starting with AGGCG\n\n\n$ zcat hairpin.fa.gz | fakit grep -s -r -i -p ^aggcg\n\n\n\n\n\n\n\nExtract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G.\n\n\n$ zcat hairpin.fa.gz | fakit grep -s -d -i -p TTSAA\n\n\n\nIt's equal to but simpler than:\n\n\n$ zcat hairpin.fa.gz | fakit grep -s -r -i -p TT[CG]AA\n\n\n\n\n\n\n\nlocate\n\n\nUsage\n\n\nlocate subsequences/motifs\n\nMotifs could be EITHER plain sequence containing \nACTGN\n OR regular\nexpression like \nA[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\n for ORFs.\nDegenerate bases like \nRYMM..\n are also supported by flag -d.\n\nIn default, motifs are treated as regular expression.\nWhen flag -d given, regular expression may be wrong.\nFor example: \n\\w\n will be wrongly converted to \n\\[AT]\n.\n\nUsage:\n  fakit locate [flags]\n\nFlags:\n  -d, --degenerate             pattern/motif contains degenerate base\n  -i, --ignore-case            ignore case\n  -P, --only-positive-strand   only search at positive strand\n  -p, --pattern value          search pattern/motif (multiple values supported) (default [])\n  -f, --pattern-file string    pattern/motif file (FASTA format)\n\n\n\n\n\nExamples\n\n\n\n\n\n\nLocate ORFs.\n\n\n$ zcat hairpin.fa.gz | fakit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\"\nseqID   patternName     pattern strand  start   end     matched\ncel-lin-4       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  136      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  54       95      AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        -  43       51      AUGAUAUAG\n\n\n\n\n\n\n\nLocate Motif.\n\n\n$ zcat hairpin.fa.gz | fakit locate -i -p UUS\nseqID   patternName     pattern strand  start   end     matched\nbna-MIR396a     UUS     UUS     -       105     107     UUS\nbna-MIR396a     UUS     UUS     -       89      91      UUS\n\n\n\nNotice that \nfakit grep\n only searches in positive strand, but \nfakit loate\n could recogize both strand\n\n\n\n\n\n\nrmdup\n\n\nUsage\n\n\nremove duplicated sequences by id/name/sequence\n\nUsage:\n  fakit rmdup [flags]\n\nFlags:\n    -n, --by-name                by full name instead of just id\n    -s, --by-seq                 by seq\n    -D, --dup-num-file string    file to save number and list of duplicated seqs\n    -d, --dup-seqs-file string   file to save duplicated seqs\n    -i, --ignore-case            ignore case\n    -m, --md5                    use MD5 instead of original seqs to reduce memory usage when comparing by seqs\n\n\n\n\n\nExamples\n\n\nSimilar to \ncommon\n.\n\n\n\n\n\n\nGeneral use\n\n\n$ zcat hairpin.fa.gz | fakit rmdup -s -o clean.fa.gz\n[INFO] 2226 duplicated records removed\n\n\n\n\n\n\n\nSave duplicated sequences to file\n\n\n$ zcat hairpin.fa.gz | fakit rmdup -s -i -m -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ cat duplicated.detail.txt   # here is not the entire list\n3   hsa-mir-424, mml-mir-424, ppy-mir-424\n3   hsa-mir-342, mml-mir-342, ppy-mir-342\n2   ngi-mir-932, nlo-mir-932\n2   ssc-mir-9784-1, ssc-mir-9784-2\n\n\n\n\n\n\n\ncommon\n\n\nUsage\n\n\nfind common sequences of multiple files by id/name/sequence\n\nUsage:\n  fakit common [flags]\n\nFlags:\n    -n, --by-name       match by full name instead of just id\n    -s, --by-seq        match by sequence\n    -i, --ignore-case   ignore case\n    -m, --md5           use MD5 instead of original seqs to reduce memory usage when comparing by seqs\n\n\n\n\n\nExamples\n\n\n\n\n\n\nBy ID (default)\n\n\nfakit common file*.fa -o common.fasta\n\n\n\n\n\n\n\nBy full name\n\n\nfakit common file*.fa -n -o common.fasta\n\n\n\n\n\n\n\nBy sequence\n\n\nfakit common file*.fa -s -i -o common.fasta\n\n\n\n\n\n\n\nBy sequence (large sequences)\n\n\nfakit common file*.fa -s -i -o common.fasta -m\n\n\n\n\n\n\n\nsplit\n\n\nUsage\n\n\nsplit sequences into files by name ID, subsequence of given region,\npart size or number of parts.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 0-based index    0 1 2 3 4 5 6 7 8 9\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4        G T N\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n\nUsage:\n  fakit split [flags]\n\nFlags:\n  -i, --by-id              split squences according to sequence ID\n  -p, --by-part int        split squences into N parts\n  -r, --by-region string   split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type \nfakit split -h\n for more example\n  -s, --by-size int        split squences into multi parts with N sequences\n  -d, --dry-run            dry run, just print message and no files will be created.\n  -m, --md5                use MD5 instead of region sequence in output file when using flag -r (--by-region)\n  -2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin\n\n\n\n\n\nExamples\n\n\n\n\n\n\nSplit sequences into parts with at most 10000 sequences\n\n\n$ fakit split hairpin.fa.gz -s 10000\n[INFO] split into 10000 seqs per file\n[INFO] write 10000 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 10000 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 8645 sequences to file: hairpin.fa.part_003.gz\n\n\n\n\n\n\n\nSplit sequences into 4 parts\n\n\n$ fakit split hairpin.fa.gz -p 4\n[INFO] split into 4 parts\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz\n[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz\n\n\n\nTo reduce memory usage when spliting big file, we could use flag \n--two-pass\n\n\n$ fakit split hairpin.fa.gz -p 4 -2\n[INFO] split into 4 parts\n[INFO] first pass: get seq number\n[INFO] seq number: 28645\n[INFO] second pass: read and split\n[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz\n[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz\n\n\n\n\n\n\n\nSplit sequences by species. i.e. by custom IDs (first three letters)\n\n\n$ fakit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\"\n[INFO] split by ID. idRegexp: ^([\\w]+)\\-\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 97 sequences to file: hairpin.fa.id_asu.gz\n[INFO] write 267 sequences to file: hairpin.fa.id_chi.gz\n[INFO] write 296 sequences to file: hairpin.fa.id_gra.gz\n...\n\n\n\n\n\n\n\nSplit sequences by sequence region (for example, sequence barcode)\n\n\n$ fakit split hairpin.fa.gz -r 1:12\n[INFO] split by region: ^([^\\s]+)\\s?\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 1 sequences to file: hairpin.fa.region_1:12_UGUUUGCUCAGC.gz\n[INFO] write 1 sequences to file: hairpin.fa.region_1:12_GAAGAAGAAGAC.gz\n[INFO] write 4 sequences to file: hairpin.fa.region_1:12_UGAGUGUAGUGC.gz\n\n\n\nIf region is too long, we could use falg \n-m\n, i.e. use MD5 instead of region sequence in output file.\n\n\nSequence suffix could be defined as \n-r -12:-1\n\n\n\n\n\n\nsample\n\n\nUsage\n\n\nsample sequences by number or proportion.\n\nUsage:\n  fakit sample [flags]\n\nFlags:\n  -n, --number int         sample by number (result may not exactly match)\n  -p, --proportion float   sample by proportion\n  -s, --rand-seed int      rand seed for shuffle (default 11)\n  -2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin\n\n\n\n\n\nExamples\n\n\n\n\n\n\nSample by number\n\n\n$ zcat hairpin.fa.gz | fakit sample -n 1000 -o sample.fa.gz\n[INFO] sample by number\n[INFO] 949 sequences outputed\n\n\n\nTo reduce memory usage when spliting big file, we could use flag \n--two-pass\n\n\n\n\n\n\nSample by proportion\n\n\n$ zcat hairpin.fa.gz | fakit sample -p 0.1 -o sample.fa.gz\n[INFO] sample by proportion\n[INFO] 2814 sequences outputed\n\n\n\n\n\n\n\nSet rand seed to reproduce the result\n\n\n$ zcat hairpin.fa.gz | fakit sample -p 0.1 -s 11\n\n\n\n\n\n\n\nMost of the time, we could shuffle after sampling\n\n\n$ zcat hairpin.fa.gz | fakit sample -p 0.1 | fakit shuffle -o sample.fa.gz\n\n\n\n\n\n\n\nshuffle\n\n\nUsage\n\n\nshuffle sequences\n\nUsage:\n  fakit shuffle [flags]\n\nFlags:\n  -s, --rand-seed int   rand seed for shuffle (default 23)\n\n\n\n\n\nExamples\n\n\n\n\nGeneral use.\n$ zcat hairpin.fa.gz | fakit shuffle -o shuffled.fa.gz\n[INFO] read sequences ...\n[INFO] 28645 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...\n\n\n\n\n\n\n\nsort\n\n\nUsage\n\n\nsort sequences by id/name/sequence/length\n\nUsage:\n  fakit sort [flags]\n\nFlags:\n  -l, --by-length     by sequence length\n  -n, --by-name       by full name instead of just id\n  -s, --by-seq        by sequence\n  -i, --ignore-case   ignore case\n  -r, --reverse       reverse the result\n\n\n\n\n\nExamples\n\n\n\n\n\n\nsort by ID\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAA\" | fakit sort --quiet\n\nSEQ2\nacgtnAAAA\n\nseq1\nACGTNcccc\n\n\n\n\n\n\n\nsort by ID, ignoring case.\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAA\" | fakit sort --quiet -i\n\nseq1\nACGTNcccc\n\nSEQ2\nacgtnAAAA\n\n\n\n\n\n\n\nsort by seq, ignoring case.\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAA\" | fakit sort --quiet -s -i\n\nSEQ2\nacgtnAAAA\n\nseq1\nACGTNcccc\n\n\n\n\n\n\n\nsort by sequence length\n\n\n$ echo -e \"\nseq1\\nACGTNcccc\\n\nSEQ2\\nacgtnAAAAnnn\\n\nseq3\\nacgt\" | fakit sort --quiet -l\n\nseq3\nacgt\n\nseq1\nACGTNcccc\n\nSEQ2\nacgtnAAAAnnn", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage-and-examples", 
            "text": "", 
            "title": "Usage and Examples"
        }, 
        {
            "location": "/usage/#fakit", 
            "text": "Usage  fakit -- Swiss army knife of FASTA format\n\nVersion: 0.1.5\n\nAuthor: Wei Shen  shenwei356@gmail.com \n\nDocuments  : http://shenwei356.github.io/fakit\nSource code: https://github.com/shenwei356/fakit\n\nUsage:\n  fakit [command]\n\nAvailable Commands:\n  common      find common sequences of multiple files by id/name/sequence\n  fa2tab      covert FASTA to tabular format (with length/GC content/GC skew) to filter and sort\n  grep        search sequences by pattern(s) of name or sequence motifs\n  locate      locate subsequences/motifs\n  rmdup       remove duplicated sequences by id/name/sequence\n  sample      sample sequences by number or proportion\n  seq         transform sequences (revserse, complement, extract ID...)\n  shuffle     shuffle sequences\n  sliding     sliding sequences, circle genome supported\n  sort        sort sequences by id/name/sequence/length\n  split       split sequences into files by id/seq region/size/parts\n  stat        simple statistics of FASTA files\n  subseq      get subsequences by region/gtf/bed, including flanking sequences\n  tab2fa      covert tabular format to FASTA format\n\nFlags:\n      --alphabet-guess-seq-length int   length of sequence prefix of the first FASTA record based on which fakit guesses the sequence type (default 10000)\n  -c, --chunk-size int                  chunk size (attention: unit is FASTA records not lines) (default 1000)\n      --id-ncbi                         FASTA head is NCBI-style, e.g.  gi|110645304|ref|NC_002516.2| Pseud...\n      --id-regexp string                regular expression for parsing ID (default  ^([^\\\\s]+)\\\\s? )\n  -w, --line-width int                  line width (0 for no wrap) (default 60)\n  -o, --out-file string                 out file ( -  for stdout, suffix .gz for gzipped out) (default  - )\n      --quiet                           be quiet and do not show extra information\n  -t, --seq-type string                 sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default  auto )\n  -j, --threads int                     number of CPUs. (default value depends on your device) (default 4)", 
            "title": "fakit"
        }, 
        {
            "location": "/usage/#performance-tips", 
            "text": "--chunk-size , for large sequences like human genome,\nyou could set a small value, like 1, to reduce memory usage.", 
            "title": "Performance Tips"
        }, 
        {
            "location": "/usage/#datasets", 
            "text": "Datasets from  The miRBase Sequence Database -- Release 21   hairpin.fa.gz  mature.fa.gz  miRNA.diff.gz   Human genome from  ensembl \n(For  fakit subseq )   Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz  Homo_sapiens.GRCh38.84.gtf.gz  Homo_sapiens.GRCh38.84.bed.gz  is converted from  Homo_sapiens.GRCh38.84.gtf.gz \nby  gtf2bed \nwith command zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c   Homo_sapiens.GRCh38.84.bed.gz    Only DNA and gtf/bed data of Chr1 were used:    chr1.fa.gz      fakit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz    chr1.gtf.gz      zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c   chr1.gtf.gz    chr1.bed.gz      zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c   chr1.bed.gz", 
            "title": "Datasets"
        }, 
        {
            "location": "/usage/#seq", 
            "text": "Usage  transform sequence (revserse, complement, extract ID...)\n\nUsage:\n  fakit seq [flags]\n\nFlags:\n  -p, --complement          complement sequence (blank for Protein sequence)\n      --dna2rna             DNA to RNA\n  -G, --gap-letter string   gap letters (default  -  )\n  -l, --lower-case          print sequences in lower case\n  -n, --name                only print names\n  -i, --only-id             print ID instead of full head\n  -g, --remove-gaps         remove gaps\n  -r, --reverse             reverse sequence)\n      --rna2dna             RNA to DNA\n  -s, --seq                 only print sequences\n  -u, --upper-case          print sequences in upper case  Examples    Read and print    From file:  $ fakit seq hairpin.fa.gz cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC\nUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA    From stdin:  zcat hairpin.fa.gz | fakit seq      Sequence types    In default,  fakit seq  automatically detect the sequence type  $ echo -e \" seq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | fakit stat\nfile    seq_type    num_seqs    min_len    avg_len    max_len\n-            DNA           1         28         28         28\n\n$ echo -e \" seq\\nACGUN ACGUN\" | fakit stat\nfile    seq_type    num_seqs    min_len    avg_len    max_len\n-            RNA           1         11         11         11\n\n$ echo -e \" seq\\nabcdefghijklmnpqrstvwyz\" | fakit stat\nfile    seq_type    num_seqs    min_len    avg_len    max_len\n-        Protein           1         23         23         23    You can also set sequence type by flag  -t  ( --seq-type ).\n  But this only take effect on subcommands  seq  and  locate .  $ echo -e \" seq\\nabcdefghijklmnpqrstvwyz\" | fakit seq -t dna\n[ERRO] error when parsing seq: seq (invalid DNAredundant letter: e)      Only print names    Full name:  $ fakit seq hairpin.fa.gz -n\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop    Only ID:  $ fakit seq hairpin.fa.gz -n -i\ncel-let-7\ncel-lin-4\ncel-mir-1    Custom ID region by regular expression (this could be applied to all subcommands):  $ fakit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\"\nMI0000001\nMI0000002\nMI0000003      Only print seq (global flag  -w  defines the output line width, 0 for no wrap)  $ fakit seq hairpin.fa.gz -s -w 0\nUACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\nAUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU\nAAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU    Reverse comlement sequence  $ fakit seq hairpin.fa.gz -r -p cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\nUCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC\nAAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA    Remove gaps and to lower/upper case  $ echo -e \" seq\\nACGT-ACTGC-ACC\" | fakit seq -i -g seq\nACGTACTGCACC    RNA to DNA  $ echo -e \" seq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | fakit seq --rna2dna seq\nTCATATGCTTGTCTCAAAGATTA", 
            "title": "seq"
        }, 
        {
            "location": "/usage/#subseq", 
            "text": "Usage  get subsequences by region/gtf/bed, including flanking sequences.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4      C G T\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n\nUsage:\n  fakit subseq [flags]\n\nFlags:\n  -b, --bed string        by BED file\n  -d, --down-stream int   down stream length\n  -T, --feature string    feature type ( .  for all, case ignored) (default  . )\n  -g, --gtf string        by GTF (version 2.2) file\n  -f, --only-flank        only return up/down stream sequence\n  -r, --region string     by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type  fakit subseq -h  for more examples\n  -u, --up-stream int     up stream length  Examples    First 12 bases  $ zcat hairpin.fa.gz | fakit subseq -r 1:12    Last 12 bases  $ zcat hairpin.fa.gz | fakit subseq -r -12:-1    Subsequences without first and last 12 bases  $ zcat hairpin.fa.gz | fakit subseq -r 13:-13    Get subsequence by GTF file  $ cat t.fa seq\nactgACTGactgn\n$ cat t.gtf\nseq     test    CDS     5       8       .       .       .       gene_id \"A\"; transcript_id \"\";\nseq     test    CDS     5       8       .       -       .       gene_id \"B\"; transcript_id \"\";\n$ fakit\n\nfakit subseq --gtf t.gtf t.fa seq_5:8:. A\nACTG seq_5:8:- B\nCAGT    Get CDS and 3bp up-stream sequences  $ fakit subseq --gtf t.gtf t.fa -u 3 seq_5:8:._us:3 A\nctgACTG seq_5:8:-_us:3 B\nagtCAGT    Get 3bp up-stream sequences of CDS, not including CDS  $ fakit subseq --gtf t.gtf t.fa -u 3 -f seq_5:8:._usf:3 A\nctg seq_5:8:-_usf:3 B\nagt    Get subsequences by BED file.  Note that flag  -c 1  is used for large genome .  $ fakit subseq -c 1 --bed chr1.bed.gz chr1.fa.gz -o chr1.bed.gz.fa.gz  We may need to remove duplicated sequences  $ fakit subseq -c 1 --bed chr1.bed.gz chr1.fa.gz | fakit rmdup -o chr1.bed.gz.rmdup.fa.gz\n[INFO] 141060 duplicated records removed  Summary:  $ fakit stat chr1.bed.gz.*.gz\nfile                       seq_type    num_seqs    min_len    avg_len      max_len\nchr1.bed.gz.fa.gz               DNA     231,974          1    3,089.5    1,551,957\nchr1.bed.gz.rmdup.fa.gz         DNA      90,914          1    6,455.8    1,551,957", 
            "title": "subseq"
        }, 
        {
            "location": "/usage/#sliding", 
            "text": "Usage  sliding sequences, circle genome supported\n\nUsage:\n  fakit sliding [flags]\n\nFlags:\n  -C, --circle-genome   circle genome\n  -s, --step int        step size\n  -W, --window int      window size  Examples    General use  $ echo -e \" seq\\nACGTacgtNN\" | fakit sliding -s 3 -W 6 seq_sliding:1-6\nACGTac seq_sliding:4-9\nTacgtN    Circle genome  $ echo -e \" seq\\nACGTacgtNN\" | fakit sliding -s 3 -W 6 -C seq_sliding:1-6\nACGTac seq_sliding:4-9\nTacgtN seq_sliding:7-2\ngtNNAC seq_sliding:10-5\nNACGTa    Generate GC content for ploting  $ zcat hairpin.fa.gz | fakit fa2tab | head -n 1 | fakit tab2fa | fakit sliding -s 5 -W 30 | fakit fa2tab -n -g\ncel-let-7_sliding:1-30          50.00\ncel-let-7_sliding:6-35          46.67\ncel-let-7_sliding:11-40         43.33\ncel-let-7_sliding:16-45         36.67\ncel-let-7_sliding:21-50         33.33\ncel-let-7_sliding:26-55         40.00\n...", 
            "title": "sliding"
        }, 
        {
            "location": "/usage/#stat", 
            "text": "Usage  simple statistics of FASTA files\n\nUsage:\n  fakit stat [flags]  Eexamples   General use $ fakit stat *.fa.gz\nfile             seq_type    num_seqs    min_len    avg_len    max_len\nhairpin.fa.gz         RNA      28,645         39        103      2,354\nmature.fa.gz          RNA      35,828         15       21.8         34", 
            "title": "stat"
        }, 
        {
            "location": "/usage/#fa2tab-fa2tab", 
            "text": "Usage (fa2tab)  covert FASTA to tabular format, and provide various information,\nlike sequence length, GC content/GC skew.\n\nUsage:\n  fakit fa2tab [flags]\n\nFlags:\n  -b, --base-content value   print base content. (case ignored, multiple values supported) e.g. -b AT -b N (default [])\n  -g, --gc                   print GC content\n  -G, --gc-skew              print GC-Skew\n  -l, --length               print sequence length\n  -n, --name                 only print names (no sequences)\n  -i, --only-id              print ID instead of full head\n  -T, --title                print title line  Usage (tab2fa)  covert tabular format (first two columns) to FASTA format\n\nUsage:\n  fakit tab2fa [flags]\n\nFlags:\n  -p, --comment-line-prefix value   comment line prefix (default [#,//])  Examples    Default output  $ fakit fa2tab hairpin.fa.gz\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop      UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop      AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU    Print sequence length, GC content, and only print names (no sequences),\nwe could also print title line by flag  -T .  $ fakit fa2tab hairpin.fa.gz -i -l -g -n -T\n# name  seq     length  GC\ncel-let-7               99      43.43\ncel-lin-4               94      54.26\ncel-mir-1               96      40.62    Use fa2tab and tab2fa in pipe  $ zcat hairpin.fa.gz | fakit fa2tab | fakit tab2fa    Sort sequences by length (use  fakit sort -l )  $ zcat hairpin.fa.gz | fakit fa2tab -l | sort -t\"`echo -e '\\t'`\" -n -k3,3 | fakit tab2fa cin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop\nUUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC mmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop\nUGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU cin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop\nACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU\n\n$ fakit sort -l hairpin.fa.gz  Sorting or filtering by GC (or other base by -flag  -b ) content could also achieved in similar way.    Get first 1000 sequences  $ zcat hairpin.fa.gz | fakit fa2tab | head -n 1000 | fakit tab2fa    Extension  After converting FASTA to tabular format with  fakit fa2tab ,\nit could be handled with CSV/TSV tools,\n e.g.  datakit  (CSV/TSV file manipulation and more)   csv_grep \n(go version) or  csv_grep.py \n(python version), could be used to filter sequences (similar with  fakit extract )  intersection \ncomputates intersection of multiple files. It could achieve similar function\nas  fakit common -n  along with shell.  csv_join  joins multiple CSV/TSV files by multiple IDs.  csv_melt \nprovides melt function, could be used in preparation of data for ploting.", 
            "title": "fa2tab &amp; fa2tab"
        }, 
        {
            "location": "/usage/#grep", 
            "text": "Usage  search sequences by pattern(s) of name or sequence motifs\n\nUsage:\n  fakit grep [flags]\n\nFlags:\n  -n, --by-name               match by full name instead of just id\n  -s, --by-seq                match by seq\n  -d, --degenerate            pattern/motif contains degenerate base\n      --delete-matched        delete matched pattern to speedup\n  -i, --ignore-case           ignore case\n  -v, --invert-match          invert the sense of matching, to select non-matching records\n  -p, --pattern value         search pattern (multiple values supported) (default [])\n  -f, --pattern-file string   pattern file\n  -r, --use-regexp            patterns are regular expression  Examples    Extract human hairpins (i.e. sequences with name starting with  hsa )  $ zcat hairpin.fa.gz | fakit grep -r -p ^hsa hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop\nUGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU\nACAAUCUACUGUCUUUCCUA hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop\nAGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU\nCCUAGCUUUCCU    Remove human and mice hairpins.  $ zcat hairpin.fa.gz | fakit grep -r -p ^hsa -p ^mmu -v    Extract new entries by information from miRNA.diff.gz    Get IDs of new entries.  $ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2   list\n$ more list\ncfa-mir-486\ncfa-mir-339-1\npmi-let-7    Extract by ID list file  $ zcat hairpin.fa.gz | fakit grep -f list   new.fa      Extract sequences starting with AGGCG  $ zcat hairpin.fa.gz | fakit grep -s -r -i -p ^aggcg    Extract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G.  $ zcat hairpin.fa.gz | fakit grep -s -d -i -p TTSAA  It's equal to but simpler than:  $ zcat hairpin.fa.gz | fakit grep -s -r -i -p TT[CG]AA", 
            "title": "grep"
        }, 
        {
            "location": "/usage/#locate", 
            "text": "Usage  locate subsequences/motifs\n\nMotifs could be EITHER plain sequence containing  ACTGN  OR regular\nexpression like  A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)  for ORFs.\nDegenerate bases like  RYMM..  are also supported by flag -d.\n\nIn default, motifs are treated as regular expression.\nWhen flag -d given, regular expression may be wrong.\nFor example:  \\w  will be wrongly converted to  \\[AT] .\n\nUsage:\n  fakit locate [flags]\n\nFlags:\n  -d, --degenerate             pattern/motif contains degenerate base\n  -i, --ignore-case            ignore case\n  -P, --only-positive-strand   only search at positive strand\n  -p, --pattern value          search pattern/motif (multiple values supported) (default [])\n  -f, --pattern-file string    pattern/motif file (FASTA format)  Examples    Locate ORFs.  $ zcat hairpin.fa.gz | fakit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\"\nseqID   patternName     pattern strand  start   end     matched\ncel-lin-4       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  136      AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        +  54       95      AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG\ncel-mir-1       A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)        -  43       51      AUGAUAUAG    Locate Motif.  $ zcat hairpin.fa.gz | fakit locate -i -p UUS\nseqID   patternName     pattern strand  start   end     matched\nbna-MIR396a     UUS     UUS     -       105     107     UUS\nbna-MIR396a     UUS     UUS     -       89      91      UUS  Notice that  fakit grep  only searches in positive strand, but  fakit loate  could recogize both strand", 
            "title": "locate"
        }, 
        {
            "location": "/usage/#rmdup", 
            "text": "Usage  remove duplicated sequences by id/name/sequence\n\nUsage:\n  fakit rmdup [flags]\n\nFlags:\n    -n, --by-name                by full name instead of just id\n    -s, --by-seq                 by seq\n    -D, --dup-num-file string    file to save number and list of duplicated seqs\n    -d, --dup-seqs-file string   file to save duplicated seqs\n    -i, --ignore-case            ignore case\n    -m, --md5                    use MD5 instead of original seqs to reduce memory usage when comparing by seqs  Examples  Similar to  common .    General use  $ zcat hairpin.fa.gz | fakit rmdup -s -o clean.fa.gz\n[INFO] 2226 duplicated records removed    Save duplicated sequences to file  $ zcat hairpin.fa.gz | fakit rmdup -s -i -m -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ cat duplicated.detail.txt   # here is not the entire list\n3   hsa-mir-424, mml-mir-424, ppy-mir-424\n3   hsa-mir-342, mml-mir-342, ppy-mir-342\n2   ngi-mir-932, nlo-mir-932\n2   ssc-mir-9784-1, ssc-mir-9784-2", 
            "title": "rmdup"
        }, 
        {
            "location": "/usage/#common", 
            "text": "Usage  find common sequences of multiple files by id/name/sequence\n\nUsage:\n  fakit common [flags]\n\nFlags:\n    -n, --by-name       match by full name instead of just id\n    -s, --by-seq        match by sequence\n    -i, --ignore-case   ignore case\n    -m, --md5           use MD5 instead of original seqs to reduce memory usage when comparing by seqs  Examples    By ID (default)  fakit common file*.fa -o common.fasta    By full name  fakit common file*.fa -n -o common.fasta    By sequence  fakit common file*.fa -s -i -o common.fasta    By sequence (large sequences)  fakit common file*.fa -s -i -o common.fasta -m", 
            "title": "common"
        }, 
        {
            "location": "/usage/#split", 
            "text": "Usage  split sequences into files by name ID, subsequence of given region,\npart size or number of parts.\n\nThe definition of region is 1-based and with some custom design.\n\nExamples:\n\n 0-based index    0 1 2 3 4 5 6 7 8 9\n 1-based index    1 2 3 4 5 6 7 8 9 10\nnegative index    0-9-8-7-6-5-4-3-2-1\n           seq    A C G T N a c g t n\n           1:1    A\n           2:4        G T N\n         -4:-2                c g t\n         -4:-1                c g t n\n         -1:-1                      n\n          2:-2      C G T N a c g t\n          1:-1    A C G T N a c g t n\n\nUsage:\n  fakit split [flags]\n\nFlags:\n  -i, --by-id              split squences according to sequence ID\n  -p, --by-part int        split squences into N parts\n  -r, --by-region string   split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type  fakit split -h  for more example\n  -s, --by-size int        split squences into multi parts with N sequences\n  -d, --dry-run            dry run, just print message and no files will be created.\n  -m, --md5                use MD5 instead of region sequence in output file when using flag -r (--by-region)\n  -2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin  Examples    Split sequences into parts with at most 10000 sequences  $ fakit split hairpin.fa.gz -s 10000\n[INFO] split into 10000 seqs per file\n[INFO] write 10000 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 10000 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 8645 sequences to file: hairpin.fa.part_003.gz    Split sequences into 4 parts  $ fakit split hairpin.fa.gz -p 4\n[INFO] split into 4 parts\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz\n[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz  To reduce memory usage when spliting big file, we could use flag  --two-pass  $ fakit split hairpin.fa.gz -p 4 -2\n[INFO] split into 4 parts\n[INFO] first pass: get seq number\n[INFO] seq number: 28645\n[INFO] second pass: read and split\n[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz\n[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz\n[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz    Split sequences by species. i.e. by custom IDs (first three letters)  $ fakit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\"\n[INFO] split by ID. idRegexp: ^([\\w]+)\\-\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 97 sequences to file: hairpin.fa.id_asu.gz\n[INFO] write 267 sequences to file: hairpin.fa.id_chi.gz\n[INFO] write 296 sequences to file: hairpin.fa.id_gra.gz\n...    Split sequences by sequence region (for example, sequence barcode)  $ fakit split hairpin.fa.gz -r 1:12\n[INFO] split by region: ^([^\\s]+)\\s?\n[INFO] read sequences ...\n[INFO] read 28645 sequences\n[INFO] write 1 sequences to file: hairpin.fa.region_1:12_UGUUUGCUCAGC.gz\n[INFO] write 1 sequences to file: hairpin.fa.region_1:12_GAAGAAGAAGAC.gz\n[INFO] write 4 sequences to file: hairpin.fa.region_1:12_UGAGUGUAGUGC.gz  If region is too long, we could use falg  -m , i.e. use MD5 instead of region sequence in output file.  Sequence suffix could be defined as  -r -12:-1", 
            "title": "split"
        }, 
        {
            "location": "/usage/#sample", 
            "text": "Usage  sample sequences by number or proportion.\n\nUsage:\n  fakit sample [flags]\n\nFlags:\n  -n, --number int         sample by number (result may not exactly match)\n  -p, --proportion float   sample by proportion\n  -s, --rand-seed int      rand seed for shuffle (default 11)\n  -2, --two-pass           2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin  Examples    Sample by number  $ zcat hairpin.fa.gz | fakit sample -n 1000 -o sample.fa.gz\n[INFO] sample by number\n[INFO] 949 sequences outputed  To reduce memory usage when spliting big file, we could use flag  --two-pass    Sample by proportion  $ zcat hairpin.fa.gz | fakit sample -p 0.1 -o sample.fa.gz\n[INFO] sample by proportion\n[INFO] 2814 sequences outputed    Set rand seed to reproduce the result  $ zcat hairpin.fa.gz | fakit sample -p 0.1 -s 11    Most of the time, we could shuffle after sampling  $ zcat hairpin.fa.gz | fakit sample -p 0.1 | fakit shuffle -o sample.fa.gz", 
            "title": "sample"
        }, 
        {
            "location": "/usage/#shuffle", 
            "text": "Usage  shuffle sequences\n\nUsage:\n  fakit shuffle [flags]\n\nFlags:\n  -s, --rand-seed int   rand seed for shuffle (default 23)  Examples   General use. $ zcat hairpin.fa.gz | fakit shuffle -o shuffled.fa.gz\n[INFO] read sequences ...\n[INFO] 28645 sequences loaded\n[INFO] shuffle ...\n[INFO] output ...", 
            "title": "shuffle"
        }, 
        {
            "location": "/usage/#sort", 
            "text": "Usage  sort sequences by id/name/sequence/length\n\nUsage:\n  fakit sort [flags]\n\nFlags:\n  -l, --by-length     by sequence length\n  -n, --by-name       by full name instead of just id\n  -s, --by-seq        by sequence\n  -i, --ignore-case   ignore case\n  -r, --reverse       reverse the result  Examples    sort by ID  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAA\" | fakit sort --quiet SEQ2\nacgtnAAAA seq1\nACGTNcccc    sort by ID, ignoring case.  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAA\" | fakit sort --quiet -i seq1\nACGTNcccc SEQ2\nacgtnAAAA    sort by seq, ignoring case.  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAA\" | fakit sort --quiet -s -i SEQ2\nacgtnAAAA seq1\nACGTNcccc    sort by sequence length  $ echo -e \" seq1\\nACGTNcccc\\n SEQ2\\nacgtnAAAAnnn\\n seq3\\nacgt\" | fakit sort --quiet -l seq3\nacgt seq1\nACGTNcccc SEQ2\nacgtnAAAAnnn", 
            "title": "sort"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Tutorial\n\n\nHandling of aligned sequences\n\n\n\n\n\n\nSome mock sequences (usually they will be much longer)\n\n\n$ cat seqs.fa\n\nseq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG\n\nseq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\n\nseq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG\n\nseq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\n\n\n\n\nRun multiple sequence alignment (clustalo)\n\n\nclustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4\n\n\n\n\n\n\n\nConvert FASTA format to tabular format.    \n\n\n$ fakit fa2tab seqs.msa.fa\nseq1    ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\nseq2    ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nseq3    ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nseq4    ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\nor\n\n\n$ fakit fa2tab seqs.msa.fa | cut -f 2\nACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\n---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\nFor me, it's useful when 1) manually assembling Sanger sequencing result,\n2) designing site specific PCR primers.\n\n\n\n\n\n\nRemove gaps\n\n\n$ fakit seq seqs.msa.fa -g\n\nseq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG\n\nseq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\n\nseq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG\n\nseq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG\n\n\n\n\n\n\n\nPlay with miRNA hairpins\n\n\nDataset\n\n\nhairpin.fa.gz\n\nfrom \nThe miRBase Sequence Database -- Release 21\n\n\nQuick glance\n\n\n\n\n\n\nSequence number\n\n\n$ fakit stat hairpin.fa.gz\nfile             seq_type    num_seqs    min_len    avg_len    max_len\nhairpin.fa.gz         RNA      28,645         39        103      2,354\n\n\n\n\n\n\n\nFirst 10 bases\n\n\n$ zcat hairpin.fa.gz | fakit subseq -r 1:10 | fakit sort -s  | fakit seq -t rna  -s | head -n 10\nAAAAAAAAAA\nAAAAAAAAAA\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAU\nAAAAAAAAGG\nAAAAAAACAU\nAAAAAAACGA\nAAAAAAAUUA\n\n\n\nhmm, nothing special, non-coding RNA~\n\n\n\n\n\n\nRepeated hairpin sequences\n\n\nWe may want to check how may identical hairpins among different species there are.\n\nfakit rmdup\n could remove duplicated sequences by sequence content,\nand save the replicates to another file (here is \nduplicated.fa.gz\n),\nas well as replicating details (\nduplicated.detail.txt\n,\n1th column is the repeated number,\n2nd column contains sequence IDs seperated by comma).\n\n\n$ fakit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ head -n 5 duplicated.detail.txt\n18      dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18\n16      hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3\n15      dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125\n13      hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b\n13      hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a\n\n\n\nThe result shows the most conserved miRNAs among different species,\n\nmir-29b\n, \nmir-125\n, \nmir-19b-1\n and \nmir-20a\n.\nAnd the \ndre-miR-430c\n has the most multicopies in \nDanio rerio\n.\n\n\nHairpins in different species\n\n\n\n\n\n\nBefore spliting by species, let's take a look at the sequence names.\n\n\n$ fakit seq hairpin.fa.gz -n | head -n 3\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop\n\n\n\nThe first three letters (e.g. \ncel\n) are the abbreviation of species names.\nSo we could split hairpins by the first letters by defining custom\nsequence ID parsing regular expression \n^([\\w]+)\\-\n.\n\n\nIn default, \nfakit\n takes the first non-space letters as sequence ID.\nFor example,\n\n\n\n\n\n\n\n\nFASTA head\n\n\nID\n\n\n\n\n\n\n\n\n\n\n123456 gene name\n\n\n123456\n\n\n\n\n\n\nlongname\n\n\nlongname\n\n\n\n\n\n\ngi\n110645304\nref\nNC_002516.2\n Pseudomona\n\n\ngi\n110645304\nref\nNC_002516.2\n\n\n\n\n\n\n\n\nBut for some sequences from NCBI,\ne.g. \ngi|110645304|ref|NC_002516.2| Pseudomona\n, the ID is \nNC_002516.2\n.\nIn this case, we could set sequence ID parsing regular expression by flag\n\n--id-regexp \"\\|([^\\|]+)\\| \"\n or just use flag \n--id-ncbi\n. If you want\nthe \ngi\n number, then use \n--id-regexp \"^gi\\|([^\\|]+)\\|\"\n.\n\n\n\n\n\n\nSplit sequences by species.\nA custom ID parsing regular expression is used, \n^([\\w]+)\\-\n.\n\n\n$ fakit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\"\n\n\n\n\n\n\n\nSpecies with most miRNA hairpins. Third column is the sequences number.\n\n\n$ fakit stat hairpin.id_*.gz | sort -k3,3nr\nhairpin.id_hsa.fa.gz           RNA       1,881         41       81.9        180\nhairpin.id_mmu.fa.gz           RNA       1,193         39       83.4        147\nhairpin.id_bta.fa.gz           RNA         808         53       80.1        149\nhairpin.id_gga.fa.gz           RNA         740         48       91.5        169\nhairpin.id_eca.fa.gz           RNA         715         52      104.6        145\n\n\n\n\n\n\n\nFor human miRNA hairpins\n\n\n\n\n\n\nLength distribution.\n \nfakit fa2tab\n could show extra information like sequence length, GC content.\n A distribution ploting script is used, (\n \nplot_distribution.py\n )\n\n\n$ fakit fa2tab hairpin.id_hsa.fa.gz -l | cut -f 3  | plot_distribution.py -o hairpin.id_hsa.fa.gz.lendist.png\n\n\n\n\n\n\n\n\n\nBacteria genome\n\n\nDataset\n\n\nPseudomonas aeruginosa PAO1\n,\nfiles:\n\n\n\n\nGenbank file \nPAO1.gb\n\n\nGenome FASTA file \nPAO1.fasta\n\n\nGTF file \nPAO1.gtf\n was created with \nextract_features_from_genbank_file.py\n, by\nextract_features_from_genbank_file.py  PAO1.gb -t . -f gtf \n PAO1.gtf\n\n\n\n\n\n\n\nMotif distribution\n\n\nMotifs\n\n\n$ cat motifs.fa\n\nGTAGCGS\nGTAGCGS\n\nGGWGKTCG\nGGWGKTCG\n\n\n\n\n\n\n\nSliding. Remember flag \n--id-ncbi\n, do you?\n  By the way, do not be scared by the long flag \n--circle-genome\n, \n--step\n\n  and so on. They have short ones, \n-c\n, \n-s\n\n\n$ fakit sliding --id-ncbi --circle-genome --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa\n\n$ fakit stat PAO1.fasta.sliding.fa\nfile                     seq_type    num_seqs    min_len    avg_len    max_len\nPAO1.fasta.sliding.fa         DNA         314    200,000    200,000    200,000\n\n\n\n\n\n\n\nLocating motifs\n\n\n$ fakit locate --id-ncbi --ignore-case --degenerate --pattern-file motifs.fa  PAO1.fasta.sliding.fa -o  PAO1.fasta.sliding.fa.motifs.tsv\n\n\n\n\n\n\n\nPloting distribution (\nplot_motif_distribution.R\n)\n\n\n# preproccess\n$ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv  \n PAO1.fasta.sliding.fa.motifs.tsv2\n\n# plot\n$ ./plot_motif_distribution.R\n\n\n\nResult\n\n\n\n\n\n\n\n\nFind multicopy genes\n\n\n\n\n\n\nGet all CDS sequences\n\n\n$ fakit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta\n\n$ fakit stat *.fasta\nfile              seq_type    num_seqs      min_len      avg_len      max_len\nPAO1.cds.fasta         DNA       5,572           72      1,003.8       16,884\nPAO1.fasta             DNA           1    6,264,404    6,264,404    6,264,404\n\n\n\n\n\n\n\nGet duplicated sequences\n\n\n$ fakit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text\n\n$ cat PAO1.cds.dup.text\n6       NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:-\n2       NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+\n2       NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+\n2       NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+\n\n\n\n\n\n\n\nFlanking sequences\n\n\n\n\n\n\nGet CDS and 1000 bp upstream sequence\n\n\n$ fakit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000\n\n\n\n\n\n\n\nGet 1000 bp upstream sequence of CDS, \nNOT\n including CDS.\n\n\n$ fakit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000 --only-flank", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#tutorial", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#handling-of-aligned-sequences", 
            "text": "Some mock sequences (usually they will be much longer)  $ cat seqs.fa seq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG seq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG seq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG    Run multiple sequence alignment (clustalo)  clustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4    Convert FASTA format to tabular format.      $ fakit fa2tab seqs.msa.fa\nseq1    ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\nseq2    ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nseq3    ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nseq4    ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG  or  $ fakit fa2tab seqs.msa.fa | cut -f 2\nACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG\n---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG-------------\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG  For me, it's useful when 1) manually assembling Sanger sequencing result,\n2) designing site specific PCR primers.    Remove gaps  $ fakit seq seqs.msa.fa -g seq1\nACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG seq2\nACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3\nACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG seq4\nACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG", 
            "title": "Handling of aligned sequences"
        }, 
        {
            "location": "/tutorial/#play-with-mirna-hairpins", 
            "text": "", 
            "title": "Play with miRNA hairpins"
        }, 
        {
            "location": "/tutorial/#dataset", 
            "text": "hairpin.fa.gz \nfrom  The miRBase Sequence Database -- Release 21", 
            "title": "Dataset"
        }, 
        {
            "location": "/tutorial/#quick-glance", 
            "text": "Sequence number  $ fakit stat hairpin.fa.gz\nfile             seq_type    num_seqs    min_len    avg_len    max_len\nhairpin.fa.gz         RNA      28,645         39        103      2,354    First 10 bases  $ zcat hairpin.fa.gz | fakit subseq -r 1:10 | fakit sort -s  | fakit seq -t rna  -s | head -n 10\nAAAAAAAAAA\nAAAAAAAAAA\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAG\nAAAAAAAAAU\nAAAAAAAAGG\nAAAAAAACAU\nAAAAAAACGA\nAAAAAAAUUA  hmm, nothing special, non-coding RNA~", 
            "title": "Quick glance"
        }, 
        {
            "location": "/tutorial/#repeated-hairpin-sequences", 
            "text": "We may want to check how may identical hairpins among different species there are. fakit rmdup  could remove duplicated sequences by sequence content,\nand save the replicates to another file (here is  duplicated.fa.gz ),\nas well as replicating details ( duplicated.detail.txt ,\n1th column is the repeated number,\n2nd column contains sequence IDs seperated by comma).  $ fakit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt\n\n$ head -n 5 duplicated.detail.txt\n18      dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18\n16      hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3\n15      dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125\n13      hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b\n13      hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a  The result shows the most conserved miRNAs among different species, mir-29b ,  mir-125 ,  mir-19b-1  and  mir-20a .\nAnd the  dre-miR-430c  has the most multicopies in  Danio rerio .", 
            "title": "Repeated hairpin sequences"
        }, 
        {
            "location": "/tutorial/#hairpins-in-different-species", 
            "text": "Before spliting by species, let's take a look at the sequence names.  $ fakit seq hairpin.fa.gz -n | head -n 3\ncel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop\ncel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop\ncel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop  The first three letters (e.g.  cel ) are the abbreviation of species names.\nSo we could split hairpins by the first letters by defining custom\nsequence ID parsing regular expression  ^([\\w]+)\\- .  In default,  fakit  takes the first non-space letters as sequence ID.\nFor example,     FASTA head  ID      123456 gene name  123456    longname  longname    gi 110645304 ref NC_002516.2  Pseudomona  gi 110645304 ref NC_002516.2     But for some sequences from NCBI,\ne.g.  gi|110645304|ref|NC_002516.2| Pseudomona , the ID is  NC_002516.2 .\nIn this case, we could set sequence ID parsing regular expression by flag --id-regexp \"\\|([^\\|]+)\\| \"  or just use flag  --id-ncbi . If you want\nthe  gi  number, then use  --id-regexp \"^gi\\|([^\\|]+)\\|\" .    Split sequences by species.\nA custom ID parsing regular expression is used,  ^([\\w]+)\\- .  $ fakit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\"    Species with most miRNA hairpins. Third column is the sequences number.  $ fakit stat hairpin.id_*.gz | sort -k3,3nr\nhairpin.id_hsa.fa.gz           RNA       1,881         41       81.9        180\nhairpin.id_mmu.fa.gz           RNA       1,193         39       83.4        147\nhairpin.id_bta.fa.gz           RNA         808         53       80.1        149\nhairpin.id_gga.fa.gz           RNA         740         48       91.5        169\nhairpin.id_eca.fa.gz           RNA         715         52      104.6        145    For human miRNA hairpins    Length distribution.\n  fakit fa2tab  could show extra information like sequence length, GC content.\n A distribution ploting script is used, (\n  plot_distribution.py  )  $ fakit fa2tab hairpin.id_hsa.fa.gz -l | cut -f 3  | plot_distribution.py -o hairpin.id_hsa.fa.gz.lendist.png", 
            "title": "Hairpins in different species"
        }, 
        {
            "location": "/tutorial/#bacteria-genome", 
            "text": "", 
            "title": "Bacteria genome"
        }, 
        {
            "location": "/tutorial/#dataset_1", 
            "text": "Pseudomonas aeruginosa PAO1 ,\nfiles:   Genbank file  PAO1.gb  Genome FASTA file  PAO1.fasta  GTF file  PAO1.gtf  was created with  extract_features_from_genbank_file.py , by extract_features_from_genbank_file.py  PAO1.gb -t . -f gtf   PAO1.gtf", 
            "title": "Dataset"
        }, 
        {
            "location": "/tutorial/#motif-distribution", 
            "text": "Motifs  $ cat motifs.fa GTAGCGS\nGTAGCGS GGWGKTCG\nGGWGKTCG    Sliding. Remember flag  --id-ncbi , do you?\n  By the way, do not be scared by the long flag  --circle-genome ,  --step \n  and so on. They have short ones,  -c ,  -s  $ fakit sliding --id-ncbi --circle-genome --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa\n\n$ fakit stat PAO1.fasta.sliding.fa\nfile                     seq_type    num_seqs    min_len    avg_len    max_len\nPAO1.fasta.sliding.fa         DNA         314    200,000    200,000    200,000    Locating motifs  $ fakit locate --id-ncbi --ignore-case --degenerate --pattern-file motifs.fa  PAO1.fasta.sliding.fa -o  PAO1.fasta.sliding.fa.motifs.tsv    Ploting distribution ( plot_motif_distribution.R )  # preproccess\n$ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv    PAO1.fasta.sliding.fa.motifs.tsv2\n\n# plot\n$ ./plot_motif_distribution.R  Result", 
            "title": "Motif distribution"
        }, 
        {
            "location": "/tutorial/#find-multicopy-genes", 
            "text": "Get all CDS sequences  $ fakit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta\n\n$ fakit stat *.fasta\nfile              seq_type    num_seqs      min_len      avg_len      max_len\nPAO1.cds.fasta         DNA       5,572           72      1,003.8       16,884\nPAO1.fasta             DNA           1    6,264,404    6,264,404    6,264,404    Get duplicated sequences  $ fakit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text\n\n$ cat PAO1.cds.dup.text\n6       NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:-\n2       NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+\n2       NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+\n2       NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+", 
            "title": "Find multicopy genes"
        }, 
        {
            "location": "/tutorial/#flanking-sequences", 
            "text": "Get CDS and 1000 bp upstream sequence  $ fakit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000    Get 1000 bp upstream sequence of CDS,  NOT  including CDS.  $ fakit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta --up-stream 1000 --only-flank", 
            "title": "Flanking sequences"
        }, 
        {
            "location": "/benchmark/", 
            "text": "Benchmark\n\n\nSoftwares\n\n\n\n\nfakit\n. (Go).\n   Version \nv0.1.5\n.\n\n\nfasta_utilities\n. (Perl).\n   Version \n3dcc0bc\n.\n   Lots of dependencies to install_.\n\n\nfastx_toolkit\n. (Perl).\n   Version \n0.0.13\n.\n   Can't handle multi-line FASTA files_.\n\n\npyfaidx\n. (Python).\n   Version \n0.4.7.1\n.\n\n\nseqmagick\n. (Python).\n   Version 0.6.1\n\n\nseqtk\n. (C).\n   Version \n1.0-r82-dirty\n.\n\n\n\n\nFeatures\n\n\n\n\n\n\n\n\nFeatures\n\n\nfakit\n\n\nfasta_utilities\n\n\nfastx_toolkit\n\n\npyfaidx\n\n\nseqmagick\n\n\nseqtk\n\n\n\n\n\n\n\n\n\n\nCross-platform\n\n\nYes\n\n\nPartly\n\n\nPartly\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nMutli-line FASTA\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nValidate bases\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\nRecognize RNA\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nRead STDIN\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nRead gzip\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nWrite gzip\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\nSearch by pattern\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nSample seqs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nSubseq\n\n\nYes\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nDeduplicate seqs\n\n\nYes\n\n\nPartly\n\n\n--\n\n\n--\n\n\nPartly\n\n\n--\n\n\n\n\n\n\nSplit seqs\n\n\nYes\n\n\nYes\n\n\n--\n\n\nPartly\n\n\n--\n\n\n--\n\n\n\n\n\n\nSplit by seq\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\nShuffle seqs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\nSort seqs\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\n--\n\n\n\n\n\n\nLocate motifs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\nCommon seqs\n\n\nYes\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n--\n\n\n\n\n\n\nClean bases\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n--\n\n\n\n\n\n\nTranscribe\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nTranslate\n\n\n--\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\nSize select\n\n\nIndirect\n\n\nYes\n\n\n--\n\n\nYes\n\n\nYes\n\n\n--\n\n\n\n\n\n\nRename head\n\n\n--\n\n\nYes\n\n\n--\n\n\n--\n\n\nYes\n\n\nYes\n\n\n\n\n\n\n\n\nDatasets\n\n\ndataset_A - large number of short sequences\n\n\ndataset_A came from \nSILVA rRNA database\n.\n\n\n\n\nSILVA_123_SSURef_tax_silva.fasta.gz\n\n\n\n\nOnly sampled subsets (~ 10%) are used:\n\n\nfakit sample SILVA_123_SSURef_tax_silva.fasta.gz -p 0.1 -o dataset_A.fa.gz\n\n\n\n\nSome tools do not support RNA sequences,  and are not able to directly read .gz file,  so the file are uncompressed, and converted to DNA by\n\n\nfakit seq --rna2dna dataset_A.fa.gz \n dataset_A.fa\n\n\n\n\ndataset_B - small number of large sequences\n\n\nHuman genome from \nensembl\n\n\n\n\nGenome DNA:  \nHomo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz\n\n\nGTF:  \nHomo_sapiens.GRCh38.84.gtf.gz\n\n\nBED: \nHomo_sapiens.GRCh38.84.bed.gz\n was converted from \nHomo_sapiens.GRCh38.84.gtf.gz\n by  \ngtf2bed\n  with command\nzcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c \n Homo_sapiens.GRCh38.84.bed.gz\n\n\n\n\n\n\n\nOnly subsets of serveral chromosomes (chr18,19,20,21,22,Y) were used:\n\n\nfakit grep Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -c 1 -p 18 -p 19 -p 20 -p 21 -p 22 -p Y  -o dataset_B.fa\n\n\n\n\nDatasets summary:\n\n\n$ fakit stat *.fa\nfile            seq_type    num_seqs       min_len       avg_len       max_len\ndataset_A.fa         DNA     175,364           900       1,419.6         3,725\ndataset_B.fa         DNA           6    46,709,983    59,698,489    80,373,285\n\n\n\n\nChr1\n\n\nDNA and gtf/bed data of Chr1 were used for testing of extracting subsequence:\n\n\n\n\n\n\nchr1.fa.gz\n\n\nfakit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz\n\n\n\n\n\n\n\nchr1.gtf.gz\n\n\nzcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c \n chr1.gtf.gz\n\n\n\n\n\n\n\nchr1.bed.gz\n\n\nzcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c \n chr1.bed.gz\n\n\n\n\n\n\n\nPlatform\n\n\nPC:\n\n\n\n\nCPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads\n\n\nRAM: DDR3 1600MHz, 12GB\n\n\nSSD: SAMSUNG 850 EVO 250G, SATA-3\n\n\nOS: Fedora 23 (Scientific KDE spin),  Kernal: 4.4.3-300.fc23.x86_64\n\n\n\n\nSoftwares:\n\n\n\n\nPerl: perl 5, version 22, subversion 1 (v5.22.1) built for x86_64-linux-thread-multi\n\n\nPython: Python 2.7.10 (default, Sep  8 2015, 17:20:17) [GCC 5.1.1 20150618 (Red Hat 5.1.1-4)] on linux2\n\n\n\n\nAutomatic benchmark and plotting scripts\n\n\nScripts are available at:  \nhttps://github.com/shenwei356/fakit/tree/master/benchmark\n\n\nAll tests were repeated 4 times.\n\n\nTest 1. Reverse Complement\n\n\nCommands\n\n\nrevcom_biogo\n (\nsource\n,\n \nbinary\n ),\n a tool written in Golang using \nbiogo\n package,\n is also used for comparison of FASTA file parsing performance.\n\n\necho == fakit\nfor f in dataset_{A,B}.fa; do echo data: $f; time fakit seq -r -p $f \n $f.fakit.rc; done\n\necho == fasta_utilities\nfor f in dataset_{A,B}.fa; do echo data: $f; time reverse_complement.pl $f \n .$f.fautil.rc; done\n\necho == pyfaidx\nfor f in dataset_{A,B}.fa; do echo data: $f; time faidx -c -r $f \n $f.pyfaidx.rc; done\n\necho == seqmagick\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqmagick convert --reverse-complement $f - \n $f.seqmagick.rc; done\n\necho == seqtk\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqtk seq -r $f \n $f.seqtk.rc; done\n\necho == biogo\nfor f in dataset_{A,B}.fa; do echo data: $f; time ./revcom_biogo $f \n $f.biogo.rc; done\n\n\n\n\nTest 2. Extract sequencs by ID list\n\n\nID lists\n\n\nID lists come from sampling 80% of the corresponding dataset and shuffling.\n\n\n$ fakit sample -p 0.8 dataset_A.fa | fakit shuffle | fakit seq -n -i \n ids_A.txt\n$ wc -l ids_A.txt\n140261 ids_A.txt\n$ head -n 2 ids_A.txt\nGQ103704.1.1352\nFR853054.1.1478\n\n$ fakit sample -p 0.8 dataset_B.fa | fakit shuffle | fakit seq -n -i  \n ids_B.txt\n$ wc -l ids_B.txt\n4 ids_B.txt\n$ cat ids_B.txt\nY\n18\n22\n21\n\n\n\n\nCommands\n\n\necho == fakit\nfor g in A B; do echo data: dataset_$g.fa; time fakit grep -f ids_$g.txt dataset_$g.fa \n ids_$g.txt.fakit.fa; done\n\necho == fasta_utilities\nfor g in A B; do echo data: dataset_$g.fa; time in_list.pl -files ids_$g.txt dataset_$g.fa \n ids_$g.txt.fautil.fa; done\n\necho == seqmagick\nfor g in A B; do echo data: dataset_$g.fa; time seqmagick convert --include-from-file ids_$g.txt dataset_$g.fa - \n ids_$g.txt.seqmagic.fa; done\n\necho == seqtk\nfor g in A B; do echo data: dataset_$g.fa; time seqtk subseq  dataset_$g.fa ids_$g.txt \n ids_$g.txt.seqtk.fa; done\n\n\n\n\nTest 3. Sampling\n\n\nCommands\n\n\nSample by number\n\n\nn=1000\n\necho == fakit\nfor f in dataset_{A,B}.fa; do echo data: $f; time fakit sample -n $n $f \n $f.sample.fakit.fa; done\n\necho == fasta_utilities\nfor f in dataset_{A,B}.fa; do echo data: $f; time subset_fasta.pl -size $n $f \n $f.sample.fautil.fa; done\n\necho == seqmagick\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqmagick convert --sample $n $f - \n $f.sample.seqmagick.fa; done\n\necho == seqtk\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqtk sample $f $n \n $f.sample.seqtk.fa; done\n\n\n\n\nTest 4. Remove duplicated sequences\n\n\nDataset\n\n\n10% or 20% sequences were randomly extract sequences from dataset_A.fa \nor dataset_B.fa and merge dback and then shuffled.\n\n\n$ cat \n(fakit sample -p 0.1 dataset_A.fa) dataset_A.fa | fakit shuffle \n dataset_A_dup.fasta\n$ cat \n(fakit sample -p 0.2 dataset_B.fa) dataset_B.fa | fakit shuffle \n dataset_B_dup.fasta\n\n\n\n\nNumbers:\n\n\ndataset_A_dup.fasta: 175364 + 17411 = 192775\ndataset_B_dup.fasta: 6 + 2 = 8\n\n\n\n\nUnique seqs:\n\n\n$ fakit fa2tab dataset_A_dup.fasta  | cut -f 2 | sort | uniq | wc -l\n161864\n$ fakit fa2tab dataset_B_dup.fasta  | cut -f 2 | sort | uniq | wc -l\n6\n\n\n\n\nCommands\n\n\nBy sequence\n\n\necho == fakit\nfor f in dataset_{A,B}_dup.fasta; do echo data: $f; time fakit rmdup -s $f \n $f.rmdup.fakit.fa; done\n\necho == seqmagick\nfor f in dataset_{A,B}_dup.fasta; do echo data: $f; time seqmagick convert --deduplicate-sequences $f - \n $f.rmdup.seqmagick.fa; done\n\n\n\n\nTest 5. Extract subsequencs by BED file\n\n\nCommands\n\n\necho ==  fakit\necho data: chr1.fa.gz; time fakit subseq -c 1 chr1.fa.gz --bed chr1.bed.gz \n chr1.bed.gz.fakit.fa\n\necho ==  seqtk\necho data: chr1.fa.gz; time seqtk subseq chr1.fa.gz chr1.bed.gz \n chr1.bed.gz.seqtk.fa\n\n\n\n\nTODO: bedtools\n\n\nResult\n\n\nAll tests were repeated 4 times.\n\n\nResult shows that the self-implemented FASTA parsing module has better performance than the \nBiogo\n, a bioinformatics library for Go.\n\n\nPerformance comparison with other tools\n\n\nFakit used all CPUs (4 for my computer) by default.\n\n\n\n\nSpeedup with multi-threads", 
            "title": "Benchmark"
        }, 
        {
            "location": "/benchmark/#benchmark", 
            "text": "", 
            "title": "Benchmark"
        }, 
        {
            "location": "/benchmark/#softwares", 
            "text": "fakit . (Go).\n   Version  v0.1.5 .  fasta_utilities . (Perl).\n   Version  3dcc0bc .\n   Lots of dependencies to install_.  fastx_toolkit . (Perl).\n   Version  0.0.13 .\n   Can't handle multi-line FASTA files_.  pyfaidx . (Python).\n   Version  0.4.7.1 .  seqmagick . (Python).\n   Version 0.6.1  seqtk . (C).\n   Version  1.0-r82-dirty .", 
            "title": "Softwares"
        }, 
        {
            "location": "/benchmark/#features", 
            "text": "Features  fakit  fasta_utilities  fastx_toolkit  pyfaidx  seqmagick  seqtk      Cross-platform  Yes  Partly  Partly  Yes  Yes  Yes    Mutli-line FASTA  Yes  Yes  --  Yes  Yes  Yes    Validate bases  Yes  --  Yes  Yes  --  --    Recognize RNA  Yes  Yes  --  --  Yes  Yes    Read STDIN  Yes  Yes  Yes  --  Yes  Yes    Read gzip  Yes  Yes  --  --  Yes  Yes    Write gzip  Yes  --  --  --  Yes  --    Search by pattern  Yes  Yes  --  --  Yes  Yes    Sample seqs  Yes  --  --  --  Yes  Yes    Subseq  Yes  Yes  --  Yes  Yes  Yes    Deduplicate seqs  Yes  Partly  --  --  Partly  --    Split seqs  Yes  Yes  --  Partly  --  --    Split by seq  Yes  --  Yes  Yes  --  --    Shuffle seqs  Yes  --  --  --  --  --    Sort seqs  Yes  Yes  --  --  Yes  --    Locate motifs  Yes  --  --  --  --  --    Common seqs  Yes  --  --  --  --  --    Clean bases  Yes  Yes  Yes  Yes  --  --    Transcribe  Yes  Yes  Yes  Yes  Yes  Yes    Translate  --  Yes  Yes  Yes  Yes  --    Size select  Indirect  Yes  --  Yes  Yes  --    Rename head  --  Yes  --  --  Yes  Yes", 
            "title": "Features"
        }, 
        {
            "location": "/benchmark/#datasets", 
            "text": "", 
            "title": "Datasets"
        }, 
        {
            "location": "/benchmark/#dataset_a-large-number-of-short-sequences", 
            "text": "dataset_A came from  SILVA rRNA database .   SILVA_123_SSURef_tax_silva.fasta.gz   Only sampled subsets (~ 10%) are used:  fakit sample SILVA_123_SSURef_tax_silva.fasta.gz -p 0.1 -o dataset_A.fa.gz  Some tools do not support RNA sequences,  and are not able to directly read .gz file,  so the file are uncompressed, and converted to DNA by  fakit seq --rna2dna dataset_A.fa.gz   dataset_A.fa", 
            "title": "dataset_A - large number of short sequences"
        }, 
        {
            "location": "/benchmark/#dataset_b-small-number-of-large-sequences", 
            "text": "Human genome from  ensembl   Genome DNA:   Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz  GTF:   Homo_sapiens.GRCh38.84.gtf.gz  BED:  Homo_sapiens.GRCh38.84.bed.gz  was converted from  Homo_sapiens.GRCh38.84.gtf.gz  by   gtf2bed   with command zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c   Homo_sapiens.GRCh38.84.bed.gz    Only subsets of serveral chromosomes (chr18,19,20,21,22,Y) were used:  fakit grep Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -c 1 -p 18 -p 19 -p 20 -p 21 -p 22 -p Y  -o dataset_B.fa  Datasets summary:  $ fakit stat *.fa\nfile            seq_type    num_seqs       min_len       avg_len       max_len\ndataset_A.fa         DNA     175,364           900       1,419.6         3,725\ndataset_B.fa         DNA           6    46,709,983    59,698,489    80,373,285", 
            "title": "dataset_B - small number of large sequences"
        }, 
        {
            "location": "/benchmark/#chr1", 
            "text": "DNA and gtf/bed data of Chr1 were used for testing of extracting subsequence:    chr1.fa.gz  fakit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz    chr1.gtf.gz  zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c   chr1.gtf.gz    chr1.bed.gz  zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c   chr1.bed.gz", 
            "title": "Chr1"
        }, 
        {
            "location": "/benchmark/#platform", 
            "text": "PC:   CPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads  RAM: DDR3 1600MHz, 12GB  SSD: SAMSUNG 850 EVO 250G, SATA-3  OS: Fedora 23 (Scientific KDE spin),  Kernal: 4.4.3-300.fc23.x86_64   Softwares:   Perl: perl 5, version 22, subversion 1 (v5.22.1) built for x86_64-linux-thread-multi  Python: Python 2.7.10 (default, Sep  8 2015, 17:20:17) [GCC 5.1.1 20150618 (Red Hat 5.1.1-4)] on linux2", 
            "title": "Platform"
        }, 
        {
            "location": "/benchmark/#automatic-benchmark-and-plotting-scripts", 
            "text": "Scripts are available at:   https://github.com/shenwei356/fakit/tree/master/benchmark  All tests were repeated 4 times.", 
            "title": "Automatic benchmark and plotting scripts"
        }, 
        {
            "location": "/benchmark/#test-1-reverse-complement", 
            "text": "", 
            "title": "Test 1. Reverse Complement"
        }, 
        {
            "location": "/benchmark/#commands", 
            "text": "revcom_biogo  ( source ,\n  binary  ),\n a tool written in Golang using  biogo  package,\n is also used for comparison of FASTA file parsing performance.  echo == fakit\nfor f in dataset_{A,B}.fa; do echo data: $f; time fakit seq -r -p $f   $f.fakit.rc; done\n\necho == fasta_utilities\nfor f in dataset_{A,B}.fa; do echo data: $f; time reverse_complement.pl $f   .$f.fautil.rc; done\n\necho == pyfaidx\nfor f in dataset_{A,B}.fa; do echo data: $f; time faidx -c -r $f   $f.pyfaidx.rc; done\n\necho == seqmagick\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqmagick convert --reverse-complement $f -   $f.seqmagick.rc; done\n\necho == seqtk\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqtk seq -r $f   $f.seqtk.rc; done\n\necho == biogo\nfor f in dataset_{A,B}.fa; do echo data: $f; time ./revcom_biogo $f   $f.biogo.rc; done", 
            "title": "Commands"
        }, 
        {
            "location": "/benchmark/#test-2-extract-sequencs-by-id-list", 
            "text": "", 
            "title": "Test 2. Extract sequencs by ID list"
        }, 
        {
            "location": "/benchmark/#id-lists", 
            "text": "ID lists come from sampling 80% of the corresponding dataset and shuffling.  $ fakit sample -p 0.8 dataset_A.fa | fakit shuffle | fakit seq -n -i   ids_A.txt\n$ wc -l ids_A.txt\n140261 ids_A.txt\n$ head -n 2 ids_A.txt\nGQ103704.1.1352\nFR853054.1.1478\n\n$ fakit sample -p 0.8 dataset_B.fa | fakit shuffle | fakit seq -n -i    ids_B.txt\n$ wc -l ids_B.txt\n4 ids_B.txt\n$ cat ids_B.txt\nY\n18\n22\n21", 
            "title": "ID lists"
        }, 
        {
            "location": "/benchmark/#commands_1", 
            "text": "echo == fakit\nfor g in A B; do echo data: dataset_$g.fa; time fakit grep -f ids_$g.txt dataset_$g.fa   ids_$g.txt.fakit.fa; done\n\necho == fasta_utilities\nfor g in A B; do echo data: dataset_$g.fa; time in_list.pl -files ids_$g.txt dataset_$g.fa   ids_$g.txt.fautil.fa; done\n\necho == seqmagick\nfor g in A B; do echo data: dataset_$g.fa; time seqmagick convert --include-from-file ids_$g.txt dataset_$g.fa -   ids_$g.txt.seqmagic.fa; done\n\necho == seqtk\nfor g in A B; do echo data: dataset_$g.fa; time seqtk subseq  dataset_$g.fa ids_$g.txt   ids_$g.txt.seqtk.fa; done", 
            "title": "Commands"
        }, 
        {
            "location": "/benchmark/#test-3-sampling", 
            "text": "", 
            "title": "Test 3. Sampling"
        }, 
        {
            "location": "/benchmark/#commands_2", 
            "text": "Sample by number  n=1000\n\necho == fakit\nfor f in dataset_{A,B}.fa; do echo data: $f; time fakit sample -n $n $f   $f.sample.fakit.fa; done\n\necho == fasta_utilities\nfor f in dataset_{A,B}.fa; do echo data: $f; time subset_fasta.pl -size $n $f   $f.sample.fautil.fa; done\n\necho == seqmagick\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqmagick convert --sample $n $f -   $f.sample.seqmagick.fa; done\n\necho == seqtk\nfor f in dataset_{A,B}.fa; do echo data: $f; time seqtk sample $f $n   $f.sample.seqtk.fa; done", 
            "title": "Commands"
        }, 
        {
            "location": "/benchmark/#test-4-remove-duplicated-sequences", 
            "text": "", 
            "title": "Test 4. Remove duplicated sequences"
        }, 
        {
            "location": "/benchmark/#dataset", 
            "text": "10% or 20% sequences were randomly extract sequences from dataset_A.fa \nor dataset_B.fa and merge dback and then shuffled.  $ cat  (fakit sample -p 0.1 dataset_A.fa) dataset_A.fa | fakit shuffle   dataset_A_dup.fasta\n$ cat  (fakit sample -p 0.2 dataset_B.fa) dataset_B.fa | fakit shuffle   dataset_B_dup.fasta  Numbers:  dataset_A_dup.fasta: 175364 + 17411 = 192775\ndataset_B_dup.fasta: 6 + 2 = 8  Unique seqs:  $ fakit fa2tab dataset_A_dup.fasta  | cut -f 2 | sort | uniq | wc -l\n161864\n$ fakit fa2tab dataset_B_dup.fasta  | cut -f 2 | sort | uniq | wc -l\n6", 
            "title": "Dataset"
        }, 
        {
            "location": "/benchmark/#commands_3", 
            "text": "By sequence  echo == fakit\nfor f in dataset_{A,B}_dup.fasta; do echo data: $f; time fakit rmdup -s $f   $f.rmdup.fakit.fa; done\n\necho == seqmagick\nfor f in dataset_{A,B}_dup.fasta; do echo data: $f; time seqmagick convert --deduplicate-sequences $f -   $f.rmdup.seqmagick.fa; done", 
            "title": "Commands"
        }, 
        {
            "location": "/benchmark/#test-5-extract-subsequencs-by-bed-file", 
            "text": "", 
            "title": "Test 5. Extract subsequencs by BED file"
        }, 
        {
            "location": "/benchmark/#commands_4", 
            "text": "echo ==  fakit\necho data: chr1.fa.gz; time fakit subseq -c 1 chr1.fa.gz --bed chr1.bed.gz   chr1.bed.gz.fakit.fa\n\necho ==  seqtk\necho data: chr1.fa.gz; time seqtk subseq chr1.fa.gz chr1.bed.gz   chr1.bed.gz.seqtk.fa  TODO: bedtools", 
            "title": "Commands"
        }, 
        {
            "location": "/benchmark/#result", 
            "text": "All tests were repeated 4 times.  Result shows that the self-implemented FASTA parsing module has better performance than the  Biogo , a bioinformatics library for Go.", 
            "title": "Result"
        }, 
        {
            "location": "/benchmark/#performance-comparison-with-other-tools", 
            "text": "Fakit used all CPUs (4 for my computer) by default.", 
            "title": "Performance comparison with other tools"
        }, 
        {
            "location": "/benchmark/#speedup-with-multi-threads", 
            "text": "", 
            "title": "Speedup with multi-threads"
        }
    ]
}